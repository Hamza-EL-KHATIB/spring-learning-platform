{
  "id": "spring-core-concepts",
  "title": "Spring Core Concepts",
  "topics": [
    {
      "title": "IoC",
      "multi-content": [
        {
          "title": "description",
          "simple-content": "Inversion of Control (IoC) is a design principle where the control of object creation and lifecycle is transferred from the application code to an external container or framework."
        },
        {
          "title": "definition",
          "simple-content": "A design principle where the control of object creation and dependency management is delegated to an external container, enhancing modularity and testability."
        },
        {
          "title": "benefits",
          "multi-content": [
            "Decouples component creation from component usage",
            "Promotes modular design and testability",
            "Enables flexible application architecture",
            "Forms the foundation for dependency injection",
            "Loose coupling between components",
            "Better testability through easier mocking"
          ]
        },
        {
          "title": "code_examples",
          "multi-content": [
            {
              "title": "without_ioc",
              "simple-content": "public class UserService {\n    private UserRepository userRepository = new UserRepositoryImpl();\n}"
            },
            {
              "title": "with_ioc",
              "simple-content": "public class UserService {\n    private UserRepository userRepository;\n    \n    // Container injects the dependency\n    public UserService(UserRepository userRepository) {\n        this.userRepository = userRepository;\n    }\n}"
            }
          ]
        }
      ]
    },
    {
      "title": "Dependency Injection",
      "multi-content": [
        {
          "title": "description",
          "simple-content": "A specific pattern of implementing IoC where object dependencies are provided from an external source rather than created internally."
        },
        {
          "title": "definition",
          "simple-content": "A pattern in which an object's dependencies are provided by an external source (usually the IoC container) rather than the object instantiating them itself, promoting loose coupling."
        },
        {
          "title": "types",
          "multi-content": [
            {
              "title": "Constructor Injection",
              "multi-content": [
                {
                  "title": "description",
                  "simple-content": "Dependencies provided via constructor"
                },
                {
                  "title": "best_for",
                  "simple-content": "Required dependencies, immutable objects"
                },
                {
                  "title": "example",
                  "simple-content": "public Service(Dependency d) {...}"
                },
                {
                  "title": "advantages",
                  "multi-content": [
                    "Ensures required dependencies are provided",
                    "Promotes immutability (dependencies can be final)",
                    "Makes dependencies explicit and visible at construction",
                    "Easier to test and provide mocks",
                    "Works without DI container",
                    "Detects circular dependencies at compile time"
                  ]
                }
              ]
            },
            {
              "title": "Setter Injection",
              "multi-content": [
                {
                  "title": "description",
                  "simple-content": "Dependencies provided via setter methods"
                },
                {
                  "title": "best_for",
                  "simple-content": "Optional dependencies, reconfigurable objects"
                },
                {
                  "title": "example",
                  "simple-content": "public void setDependency(Dependency d) {...}"
                },
                {
                  "title": "advantages",
                  "multi-content": [
                    "Allows optional dependencies",
                    "Provides flexibility in dependency management",
                    "Supports runtime modification of dependencies"
                  ]
                }
              ]
            },
            {
              "title": "Field Injection",
              "multi-content": [
                {
                  "title": "description",
                  "simple-content": "Dependencies injected directly into fields"
                },
                {
                  "title": "best_for",
                  "simple-content": "Simple cases (generally discouraged)"
                },
                {
                  "title": "example",
                  "simple-content": "@Autowired private Dependency d;"
                },
                {
                  "title": "advantages",
                  "multi-content": [
                    "Less boilerplate code",
                    "Simpler to write"
                  ]
                },
                {
                  "title": "disadvantages",
                  "multi-content": [
                    "Harder to test",
                    "Cannot declare fields as final",
                    "Hidden dependencies"
                  ]
                }
              ]
            }
          ]
        },
        {
          "title": "code_examples",
          "multi-content": [
            {
              "title": "constructor_injection",
              "simple-content": "@Service\npublic class UserService {\n    private final UserRepository userRepository;\n    \n    @Autowired // Optional in Spring 4.3+ with single constructor\n    public UserService(UserRepository userRepository) {\n        this.userRepository = userRepository;\n    }\n}"
            },
            {
              "title": "setter_injection",
              "simple-content": "@Service\npublic class UserService {\n    private UserRepository userRepository;\n    \n    @Autowired\n    public void setUserRepository(UserRepository userRepository) {\n        this.userRepository = userRepository;\n    }\n}"
            },
            {
              "title": "field_injection",
              "simple-content": "@Service\npublic class UserService {\n    @Autowired\n    private UserRepository userRepository;\n}"
            }
          ]
        }
      ]
    },
    {
      "title": "IoC vs DI vs Spring IoC Container",
      "multi-content": [
        {
          "title": "description",
          "simple-content": "Understanding the differences between Inversion of Control (IoC) as a design principle, Dependency Injection (DI) as a design pattern, and Spring IoC Container as a specific implementation."
        },
        {
          "title": "fundamental_definitions",
          "multi-content": [
            {
              "title": "Inversion of Control (IoC)",
              "multi-content": [
                {
                  "title": "definition",
                  "simple-content": "IoC is a broad design principle where control of object creation, object lifecycle, and object dependencies is transferred to a container or framework. The main idea is to invert the traditional flow of control: in the traditional approach, your code calls a library when needed; in the IoC approach, the framework calls your code at the appropriate time."
                },
                {
                  "title": "purpose",
                  "simple-content": "Decouple execution from implementation"
                },
                {
                  "title": "level",
                  "simple-content": "Design principle"
                }
              ]
            },
            {
              "title": "Dependency Injection (DI)",
              "multi-content": [
                {
                  "title": "definition",
                  "simple-content": "DI is a specific pattern for implementing IoC where dependencies are 'injected' into objects rather than having objects create or find them themselves."
                },
                {
                  "title": "purpose",
                  "simple-content": "Decouple component creation from their usage"
                },
                {
                  "title": "level",
                  "simple-content": "Design pattern"
                }
              ]
            },
            {
              "title": "Spring IoC Container",
              "multi-content": [
                {
                  "title": "definition",
                  "simple-content": "The specific implementation in Spring that manages beans and injects dependencies"
                },
                {
                  "title": "purpose",
                  "simple-content": "Automate DI and manage lifecycle"
                },
                {
                  "title": "level",
                  "simple-content": "Implementation"
                }
              ]
            }
          ]
        },
        {
          "title": "code_examples",
          "multi-content": [
            {
              "title": "without_ioc",
              "simple-content": "public class UserService {\n    // UserService directly creates its dependency\n    private UserRepository userRepository = new UserRepositoryImpl();\n    \n    public User getUser(Long id) {\n        return userRepository.findById(id);\n    }\n}"
            },
            {
              "title": "with_di",
              "simple-content": "public class UserService {\n    // UserRepository is injected, not created\n    private final UserRepository userRepository;\n    \n    // Constructor injection\n    public UserService(UserRepository userRepository) {\n        this.userRepository = userRepository;\n    }\n    \n    public User getUser(Long id) {\n        return userRepository.findById(id);\n    }\n}"
            }
          ]
        },
        {
          "title": "di_types",
          "multi-content": [
            {
              "title": "Constructor Injection",
              "multi-content": [
                {
                  "title": "description",
                  "simple-content": "Dependencies are provided via constructor (preferred method)"
                },
                {
                  "title": "example",
                  "simple-content": "public UserService(UserRepository userRepository) {\n    this.userRepository = userRepository;\n}"
                }
              ]
            },
            {
              "title": "Setter Injection",
              "multi-content": [
                {
                  "title": "description",
                  "simple-content": "Dependencies are provided via setter methods"
                },
                {
                  "title": "example",
                  "simple-content": "@Autowired\npublic void setUserRepository(UserRepository userRepository) {\n    this.userRepository = userRepository;\n}"
                }
              ]
            },
            {
              "title": "Field Injection",
              "multi-content": [
                {
                  "title": "description",
                  "simple-content": "Dependencies are injected directly into fields (not recommended)"
                },
                {
                  "title": "example",
                  "simple-content": "@Autowired\nprivate UserRepository userRepository;"
                }
              ]
            }
          ]
        },
        {
          "title": "spring_ioc_container",
          "multi-content": [
            {
              "title": "description",
              "simple-content": "The Spring IoC Container is the concrete implementation of IoC in Spring, consisting of BeanFactory (base interface providing basic IoC functionality) and ApplicationContext (enhanced container with enterprise features, extending BeanFactory)."
            },
            {
              "title": "example",
              "simple-content": "// Spring IoC Container in action\nApplicationContext context = new ClassPathXmlApplicationContext(\"beans.xml\");\n// or\nApplicationContext context = new AnnotationConfigApplicationContext(AppConfig.class);\n\n// Retrieve a bean from the container\nUserService userService = context.getBean(UserService.class);"
            }
          ]
        }
      ]
    },
    {
      "title": "BeanLifecycle",
      "multi-content": [
        {
          "title": "description",
          "simple-content": "The lifecycle of a Spring bean in a Spring Boot application follows a specific sequence from initialization to destruction, with opportunities for customization at each stage."
        },
        {
          "title": "definition",
          "simple-content": "The complete process a Spring bean undergoes—from instantiation and dependency injection to initialization and eventual destruction—with opportunities for custom behavior at various stages."
        },
        {
          "title": "boot_specific_considerations",
          "simple-content": "Spring Boot follows the same bean lifecycle as Spring Framework, but adds auto-configuration, which influences how beans are created and initialized. Boot also initializes beans in a specific order to ensure dependencies are satisfied correctly."
        },
        {
          "title": "lifecycle_phases",
          "multi-content": [
            {
              "title": "Bean Definition",
              "multi-content": [
                {
                  "title": "description",
                  "simple-content": "Spring reads configuration and creates BeanDefinition objects"
                },
                {
                  "title": "events",
                  "multi-content": [
                    "Configuration metadata is loaded (annotations, XML, Java config)",
                    "BeanDefinition objects are created and registered with container",
                    "In Spring Boot, auto-configuration classes contribute additional bean definitions"
                  ]
                }
              ]
            },
            {
              "title": "Bean Instantiation",
              "multi-content": [
                {
                  "title": "description",
                  "simple-content": "Spring creates the bean instance"
                },
                {
                  "title": "events",
                  "multi-content": [
                    "Constructor is invoked",
                    "Factory method is called (if configured)"
                  ]
                }
              ]
            },
            {
              "title": "Property Population",
              "multi-content": [
                {
                  "title": "description",
                  "simple-content": "Dependencies are injected"
                },
                {
                  "title": "events",
                  "multi-content": [
                    "Properties are set",
                    "Dependencies are resolved and injected",
                    "In Spring Boot, properties from application.properties/yml are bound"
                  ]
                }
              ]
            },
            {
              "title": "Initialization",
              "multi-content": [
                {
                  "title": "description",
                  "simple-content": "Bean is initialized through callbacks"
                },
                {
                  "title": "events",
                  "multi-content": [
                    "BeanNameAware.setBeanName() is called",
                    "BeanFactoryAware.setBeanFactory() is called",
                    "ApplicationContextAware.setApplicationContext() is called",
                    "BeanPostProcessor.postProcessBeforeInitialization() methods are called",
                    "@PostConstruct methods are called",
                    "InitializingBean.afterPropertiesSet() is called",
                    "Custom init-method is called",
                    "BeanPostProcessor.postProcessAfterInitialization() methods are called"
                  ]
                }
              ]
            },
            {
              "title": "Bean Usage",
              "multi-content": [
                {
                  "title": "description",
                  "simple-content": "Bean is ready for use by the application"
                },
                {
                  "title": "boot_feature",
                  "simple-content": "Spring Boot completes initialization of all beans before application is considered ready"
                }
              ]
            },
            {
              "title": "Destruction",
              "multi-content": [
                {
                  "title": "description",
                  "simple-content": "Bean is destroyed when context is closed"
                },
                {
                  "title": "events",
                  "multi-content": [
                    "@PreDestroy methods are called",
                    "DisposableBean.destroy() is called",
                    "Custom destroy-method is called"
                  ]
                }
              ]
            }
          ]
        },
        {
          "title": "boot_specific_examples",
          "multi-content": [
            {
              "title": "using_application_events",
              "simple-content": "@Component\npublic class BootLifecycleBean {\n    private final Logger logger = LoggerFactory.getLogger(BootLifecycleBean.class);\n    \n    @EventListener(ApplicationReadyEvent.class)\n    public void onApplicationReady() {\n        logger.info(\"Application is fully started and ready to accept requests\");\n        // Do post-startup initialization\n    }\n    \n    @EventListener(ApplicationFailedEvent.class)\n    public void onApplicationFailed() {\n        logger.error(\"Application failed to start\");\n        // Perform cleanup or notification\n    }\n}"
            },
            {
              "title": "using_commandlinerunner",
              "simple-content": "@Component\npublic class StartupTaskRunner implements CommandLineRunner {\n    private final UserService userService;\n    \n    public StartupTaskRunner(UserService userService) {\n        this.userService = userService;\n    }\n    \n    @Override\n    public void run(String... args) throws Exception {\n        // Executed after the application context is loaded but before\n        // the application is fully started\n        System.out.println(\"Running startup tasks...\");\n        userService.performStartupChecks();\n    }\n}"
            }
          ]
        }
      ]
    },
    {
      "title": "BeanScopes",
      "multi-content": [
        {
          "title": "description",
          "simple-content": "Bean scopes define a bean's lifecycle, visibility, and the number of instances created in a Spring Boot application."
        },
        {
          "title": "definition",
          "simple-content": "Defines the lifecycle and visibility of a bean within the container. Each scope determines when a new instance is created and how long it lives."
        },
        {
          "title": "scope_types",
          "multi-content": [
            {
              "title": "singleton",
              "multi-content": [
                {
                  "title": "description",
                  "simple-content": "Default scope; one instance per Spring container"
                },
                {
                  "title": "instances",
                  "simple-content": "Single"
                },
                {
                  "title": "lifecycle",
                  "simple-content": "Container lifecycle"
                },
                {
                  "title": "best_for",
                  "simple-content": "Stateless services and repositories"
                },
                {
                  "title": "boot_usage",
                  "simple-content": "In Spring Boot, most auto-configured beans are singleton scope by default"
                }
              ]
            },
            {
              "title": "prototype",
              "multi-content": [
                {
                  "title": "description",
                  "simple-content": "New bean instance for each request/injection"
                },
                {
                  "title": "instances",
                  "simple-content": "Multiple"
                },
                {
                  "title": "lifecycle",
                  "simple-content": "From creation until no longer referenced"
                },
                {
                  "title": "best_for",
                  "simple-content": "Stateful objects like forms or shopping carts"
                }
              ]
            },
            {
              "title": "request",
              "multi-content": [
                {
                  "title": "description",
                  "simple-content": "One instance per HTTP request (web-aware)"
                },
                {
                  "title": "instances",
                  "simple-content": "Multiple"
                },
                {
                  "title": "lifecycle",
                  "simple-content": "HTTP request"
                },
                {
                  "title": "best_for",
                  "simple-content": "HTTP request-specific data"
                },
                {
                  "title": "boot_usage",
                  "simple-content": "Available automatically in Spring Boot web applications"
                }
              ]
            },
            {
              "title": "session",
              "multi-content": [
                {
                  "title": "description",
                  "simple-content": "One instance per HTTP session (web-aware)"
                },
                {
                  "title": "instances",
                  "simple-content": "Multiple"
                },
                {
                  "title": "lifecycle",
                  "simple-content": "HTTP session"
                },
                {
                  "title": "best_for",
                  "simple-content": "User-specific data in web applications"
                }
              ]
            },
            {
              "title": "application",
              "multi-content": [
                {
                  "title": "description",
                  "simple-content": "One instance per ServletContext (web-aware)"
                },
                {
                  "title": "instances",
                  "simple-content": "Single"
                },
                {
                  "title": "lifecycle",
                  "simple-content": "ServletContext lifecycle"
                },
                {
                  "title": "best_for",
                  "simple-content": "Application-wide beans"
                }
              ]
            },
            {
              "title": "websocket",
              "multi-content": [
                {
                  "title": "description",
                  "simple-content": "One instance per WebSocket (web-aware)"
                },
                {
                  "title": "instances",
                  "simple-content": "Multiple"
                },
                {
                  "title": "lifecycle",
                  "simple-content": "WebSocket lifecycle"
                },
                {
                  "title": "best_for",
                  "simple-content": "WebSocket-specific beans"
                }
              ]
            }
          ]
        },
        {
          "title": "code_examples",
          "multi-content": [
            {
              "title": "singleton_scope",
              "simple-content": "@Component\n@Scope(\"singleton\") // or simply @Component since singleton is default\npublic class UserService { /* ... */ }"
            },
            {
              "title": "prototype_scope",
              "simple-content": "@Component\n@Scope(\"prototype\")\npublic class ShoppingCart { /* ... */ }"
            },
            {
              "title": "request_scope",
              "simple-content": "@Component\n@RequestScope // or @Scope(value = \"request\", proxyMode = ScopedProxyMode.TARGET_CLASS)\npublic class RequestScopedBean { /* ... */ }"
            },
            {
              "title": "mixing_scopes",
              "simple-content": "// Problem: Injecting prototype into singleton\n@Component\npublic class SingletonBean {\n    @Autowired\n    private PrototypeBean prototypeBean; // Will always be the same instance!\n}\n\n// Solution 1: Scoped Proxy\n@Component\n@Scope(value = \"prototype\", proxyMode = ScopedProxyMode.TARGET_CLASS)\npublic class PrototypeBean { /* ... */ }\n\n// Solution 2: ObjectFactory\n@Component\npublic class SingletonBean {\n    @Autowired\n    private ObjectFactory<PrototypeBean> prototypeBeanFactory;\n    \n    public void doSomething() {\n        PrototypeBean prototypeBean = prototypeBeanFactory.getObject(); // New instance\n        // Use prototypeBean\n    }\n}"
            }
          ]
        },
        {
          "title": "boot_specific_features",
          "multi-content": [
            "Spring Boot automatically configures the necessary infrastructure for web-aware scopes",
            "The @RequestScope, @SessionScope, and @ApplicationScope annotations simplify scope configuration",
            "Spring Boot's DevTools module handles bean refreshing correctly across different scopes during development"
          ]
        }
      ]
    },
    {
      "title": "SpringConfiguration",
      "multi-content": [
        {
          "title": "description",
          "simple-content": "Different approaches to configure beans and wire dependencies in Spring applications."
        },
        {
          "title": "definition",
          "simple-content": "The process of defining beans, their dependencies, and other application settings to be managed by the Spring container."
        },
        {
          "title": "configuration_types",
          "multi-content": [
            {
              "title": "Java Configuration",
              "multi-content": [
                {
                  "title": "description",
                  "simple-content": "Using @Configuration and @Bean annotations in Java classes"
                },
                {
                  "title": "best_for",
                  "simple-content": "Type safety, refactoring friendliness, IDE support"
                },
                {
                  "title": "advantages",
                  "multi-content": [
                    "Type safety",
                    "Compile-time checks",
                    "Better refactoring support",
                    "IDE autocompletion",
                    "Programmatic configuration"
                  ]
                },
                {
                  "title": "example",
                  "simple-content": "@Configuration\npublic class AppConfig {\n    \n    @Bean\n    public UserRepository userRepository() {\n        return new JpaUserRepository();\n    }\n    \n    @Bean\n    public UserService userService(UserRepository userRepository) {\n        return new UserServiceImpl(userRepository);\n    }\n}"
                }
              ]
            },
            {
              "title": "Annotation-Based",
              "multi-content": [
                {
                  "title": "description",
                  "simple-content": "Using component scanning with @Component, @Service, etc."
                },
                {
                  "title": "best_for",
                  "simple-content": "Simplicity, reduced boilerplate, convention over configuration"
                },
                {
                  "title": "advantages",
                  "multi-content": [
                    "Less configuration code",
                    "Configuration closer to implementation",
                    "Automatic component detection",
                    "Clean, readable code"
                  ]
                },
                {
                  "title": "example",
                  "simple-content": "@Configuration\n@ComponentScan(basePackages = \"com.example\")\npublic class AppConfig {\n    // Configuration for component scanning\n}\n\n@Component\npublic class SimpleComponent { /* ... */ }\n\n@Repository\npublic class JpaUserRepository implements UserRepository { /* ... */ }\n\n@Service\npublic class UserServiceImpl implements UserService {\n    @Autowired\n    private UserRepository userRepository;\n    // Implementation\n}"
                }
              ]
            },
            {
              "title": "XML Configuration",
              "multi-content": [
                {
                  "title": "description",
                  "simple-content": "Using XML files with <bean> definitions"
                },
                {
                  "title": "best_for",
                  "simple-content": "External configuration, legacy systems"
                },
                {
                  "title": "advantages",
                  "multi-content": [
                    "No recompilation needed for configuration changes",
                    "Complete separation from code",
                    "Legacy Spring support",
                    "Explicit dependency wiring"
                  ]
                },
                {
                  "title": "example",
                  "simple-content": "<!-- applicationContext.xml -->\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n                           http://www.springframework.org/schema/beans/spring-beans.xsd\">\n\n    <bean id=\"userRepository\" class=\"com.example.JpaUserRepository\" />\n    \n    <bean id=\"userService\" class=\"com.example.UserServiceImpl\">\n        <constructor-arg ref=\"userRepository\" />\n    </bean>\n</beans>"
                }
              ]
            }
          ]
        },
        {
          "title": "common_annotations",
          "multi-content": [
            {
              "title": "@Configuration",
              "simple-content": "Indicates a class defines bean methods"
            },
            {
              "title": "@Bean",
              "simple-content": "Marks a method as producing a Spring bean"
            },
            {
              "title": "@Component",
              "simple-content": "Generic stereotype for Spring-managed components"
            },
            {
              "title": "@Repository",
              "simple-content": "Stereotype for persistence layer components"
            },
            {
              "title": "@Service",
              "simple-content": "Stereotype for service layer components"
            },
            {
              "title": "@Controller",
              "simple-content": "Stereotype for presentation layer components"
            },
            {
              "title": "@Autowired",
              "simple-content": "Marks a dependency injection point"
            },
            {
              "title": "@Qualifier",
              "simple-content": "Disambiguates which bean to inject"
            },
            {
              "title": "@Value",
              "simple-content": "Injects values from properties or expressions"
            },
            {
              "title": "@Profile",
              "simple-content": "Activates beans for specific environments"
            }
          ]
        }
      ]
    },
    {
      "title": "ComponentScanning",
      "multi-content": [
        {
          "title": "description",
          "simple-content": "The process by which Spring automatically identifies and registers beans from specified packages."
        },
        {
          "title": "definition",
          "simple-content": "A mechanism that allows Spring to detect and register Spring beans automatically by scanning specific base packages for classes with stereotype annotations."
        },
        {
          "title": "key_concepts",
          "multi-content": [
            {
              "title": "base_packages",
              "simple-content": "The starting points for component scanning, typically your application's root package"
            },
            {
              "title": "stereotype_annotations",
              "simple-content": "Markers for classes that should be automatically registered as beans (@Component and its specializations)"
            },
            {
              "title": "filters",
              "simple-content": "Rules to include or exclude certain classes from scanning"
            },
            {
              "title": "bean_naming",
              "simple-content": "How Spring automatically names scanned components (typically camelCase of class name)"
            }
          ]
        },
        {
          "title": "annotations",
          "multi-content": [
            {
              "title": "@Component",
              "simple-content": "Generic annotation for any Spring-managed component"
            },
            {
              "title": "@Service",
              "simple-content": "Indicates the class belongs to the service layer (business logic)"
            },
            {
              "title": "@Repository",
              "simple-content": "Indicates a persistence layer class with automatic exception translation"
            },
            {
              "title": "@Controller",
              "simple-content": "Indicates a web controller component"
            },
            {
              "title": "@RestController",
              "simple-content": "Combines @Controller and @ResponseBody for RESTful controllers"
            }
          ]
        },
        {
          "title": "code_examples",
          "multi-content": [
            {
              "title": "basic_scanning",
              "simple-content": "@Configuration\n@ComponentScan(basePackages = \"com.example\")\npublic class AppConfig {\n    // Configuration\n}"
            },
            {
              "title": "multiple_packages",
              "simple-content": "@Configuration\n@ComponentScan(basePackages = {\"com.example.service\", \"com.example.repository\"})\npublic class AppConfig {\n    // Configuration\n}"
            },
            {
              "title": "using_filters",
              "simple-content": "@Configuration\n@ComponentScan(\n    basePackages = \"com.example\",\n    includeFilters = @ComponentScan.Filter(type = FilterType.REGEX, pattern = \".*Repository\"),\n    excludeFilters = @ComponentScan.Filter(type = FilterType.ANNOTATION, classes = Deprecated.class)\n)\npublic class AppConfig {\n    // Configuration\n}"
            }
          ]
        },
        {
          "title": "scan_process",
          "multi-content": [
            "Spring searches base packages and sub-packages",
            "Finds classes with stereotype annotations",
            "Reads metadata from annotations",
            "Filters classes based on include/exclude rules",
            "Registers BeanDefinitions for matched classes",
            "Names beans (typically the uncapitalized class name)",
            "Processes additional annotations (like @Scope, @Lazy)"
          ]
        }
      ]
    },
    {
      "title": "DependencyResolution",
      "multi-content": [
        {
          "title": "description",
          "simple-content": "How Spring resolves dependencies and handles scenarios with multiple candidates."
        },
        {
          "title": "definition",
          "simple-content": "The process by which Spring identifies and selects the appropriate beans to inject when dependencies are declared."
        },
        {
          "title": "resolution_mechanisms",
          "multi-content": [
            {
              "title": "@Qualifier",
              "multi-content": [
                {
                  "title": "description",
                  "simple-content": "Specifies which bean to inject when multiple candidates exist"
                },
                {
                  "title": "example",
                  "simple-content": "@Service(\"premiumService\")\npublic class PremiumUserService implements UserService { /* ... */ }\n\n@Service(\"basicService\")\npublic class BasicUserService implements UserService { /* ... */ }\n\n@Component\npublic class UserController {\n    private final UserService userService;\n    \n    @Autowired\n    public UserController(@Qualifier(\"premiumService\") UserService userService) {\n        this.userService = userService;\n    }\n}"
                }
              ]
            },
            {
              "title": "@Primary",
              "multi-content": [
                {
                  "title": "description",
                  "simple-content": "Marks a bean as the primary candidate for autowiring"
                },
                {
                  "title": "example",
                  "simple-content": "@Service\n@Primary\npublic class PrimaryUserService implements UserService { /* ... */ }\n\n@Service\npublic class SecondaryUserService implements UserService { /* ... */ }\n\n@Component\npublic class UserController {\n    private final UserService userService;\n    \n    @Autowired\n    public UserController(UserService userService) {\n        // PrimaryUserService will be injected\n        this.userService = userService;\n    }\n}"
                }
              ]
            },
            {
              "title": "Bean Name Autowiring",
              "multi-content": [
                {
                  "title": "description",
                  "simple-content": "Matching by parameter/field name"
                },
                {
                  "title": "example",
                  "simple-content": "@Component(\"premiumService\")\npublic class PremiumUserService implements UserService { /* ... */ }\n\n@Component(\"basicService\")\npublic class BasicUserService implements UserService { /* ... */ }\n\n@Component\npublic class UserController {\n    private final UserService premiumService; // Name matches bean id\n    \n    @Autowired\n    public UserController(UserService premiumService) {\n        this.premiumService = premiumService;\n    }\n}"
                }
              ]
            }
          ]
        },
        {
          "title": "resolution_order",
          "multi-content": [
            "1. Exact type match (if only one bean of the required type exists)",
            "2. Match by @Qualifier if specified",
            "3. Match with @Primary bean if available",
            "4. Match by name (if parameter/field name matches a bean name)",
            "5. Throw exception if no unique bean can be determined"
          ]
        },
        {
          "title": "common_exceptions",
          "multi-content": [
            {
              "title": "NoSuchBeanDefinitionException",
              "simple-content": "No qualifying bean found"
            },
            {
              "title": "NoUniqueBeanDefinitionException",
              "simple-content": "Multiple qualifying beans found"
            },
            {
              "title": "BeanCreationException",
              "simple-content": "Error creating bean"
            }
          ]
        }
      ]
    },
    {
      "title": "CircularDependencies",
      "multi-content": [
        {
          "title": "description",
          "simple-content": "A situation where bean A depends on bean B, and bean B depends on bean A, either directly or indirectly."
        },
        {
          "title": "definition",
          "simple-content": "A circular dependency occurs when two or more beans depend on each other, creating a dependency cycle that can cause initialization issues."
        },
        {
          "title": "dependency_types",
          "multi-content": [
            {
              "title": "Constructor Injection Circularity",
              "multi-content": [
                {
                  "title": "resolvable",
                  "simple-content": "false"
                },
                {
                  "title": "description",
                  "simple-content": "Cannot be resolved by Spring"
                },
                {
                  "title": "example",
                  "simple-content": "@Component\npublic class BeanA {\n    private final BeanB beanB;\n    \n    @Autowired\n    public BeanA(BeanB beanB) {\n        this.beanB = beanB;\n    }\n}\n\n@Component\npublic class BeanB {\n    private final BeanA beanA;\n    \n    @Autowired\n    public BeanB(BeanA beanA) {\n        this.beanA = beanA;\n    }\n}"
                }
              ]
            },
            {
              "title": "Setter Injection Circularity",
              "multi-content": [
                {
                  "title": "resolvable",
                  "simple-content": "true"
                },
                {
                  "title": "description",
                  "simple-content": "Can be resolved by Spring"
                },
                {
                  "title": "example",
                  "simple-content": "@Component\npublic class BeanA {\n    private BeanB beanB;\n    \n    @Autowired\n    public void setBeanB(BeanB beanB) {\n        this.beanB = beanB;\n    }\n}\n\n@Component\npublic class BeanB {\n    private BeanA beanA;\n    \n    @Autowired\n    public void setBeanA(BeanA beanA) {\n        this.beanA = beanA;\n    }\n}"
                }
              ]
            }
          ]
        },
        {
          "title": "detection",
          "simple-content": "Spring detects circular dependencies during application startup and throws BeanCurrentlyInCreationException if they can't be resolved."
        },
        {
          "title": "resolution_strategies",
          "multi-content": [
            {
              "title": "Redesign Components",
              "multi-content": [
                {
                  "title": "recommendation",
                  "simple-content": "Best practice"
                },
                {
                  "title": "description",
                  "simple-content": "Rethink dependencies to eliminate circular references"
                },
                {
                  "title": "details",
                  "multi-content": [
                    "Extract shared functionality to a third service",
                    "Apply Dependency Inversion Principle",
                    "Use events for communication"
                  ]
                }
              ]
            },
            {
              "title": "Use Setter Injection",
              "multi-content": [
                {
                  "title": "description",
                  "simple-content": "Switch from constructor to setter injection"
                },
                {
                  "title": "caution",
                  "simple-content": "Creates possibility of partially initialized beans"
                }
              ]
            },
            {
              "title": "Use @Lazy Annotation",
              "multi-content": [
                {
                  "title": "description",
                  "simple-content": "Defer one side of the dependency"
                },
                {
                  "title": "example",
                  "simple-content": "@Component\npublic class BeanA {\n    private final BeanB beanB;\n    \n    @Autowired\n    public BeanA(@Lazy BeanB beanB) {\n        this.beanB = beanB;\n    }\n}"
                }
              ]
            },
            {
              "title": "Use Events",
              "multi-content": [
                {
                  "title": "description",
                  "simple-content": "Decouple communication using Spring's event system"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "title": "AOP",
      "multi-content": [
        {
          "title": "description",
          "simple-content": "Aspect-Oriented Programming (AOP) addresses cross-cutting concerns by separating them from the main business logic, promoting cleaner and more maintainable code. In Spring Boot, AOP is commonly used for logging, transaction management, security, and performance monitoring."
        },
        {
          "title": "definition",
          "simple-content": "A programming paradigm that separates cross-cutting concerns (like logging, security, or transaction management) from business logic using aspects, advices, join points, and pointcuts."
        },
        {
          "title": "spring_boot_implementation",
          "simple-content": "Spring Boot simplifies AOP by auto-configuring necessary dependencies when you include spring-boot-starter-aop in your project. This allows you to focus on writing your aspects rather than configuration details."
        },
        {
          "title": "code_examples",
          "multi-content": [
            {
              "title": "logging_aspect",
              "simple-content": "// Common Spring Boot logging aspect example\n@Aspect\n@Component\npublic class LoggingAspect {\n    private static final Logger log = LoggerFactory.getLogger(LoggingAspect.class);\n    \n    @Around(\"execution(* com.example.service.*.*(..))\")\n    public Object logMethodExecution(ProceedingJoinPoint joinPoint) throws Throwable {\n        String methodName = joinPoint.getSignature().getName();\n        log.info(\"Beginning execution of {}\", methodName);\n        \n        long start = System.currentTimeMillis();\n        Object result = joinPoint.proceed();\n        long executionTime = System.currentTimeMillis() - start;\n        \n        log.info(\"{} executed in {}ms\", methodName, executionTime);\n        return result;\n    }\n    \n    @AfterThrowing(pointcut = \"execution(* com.example.service.*.*(..))\" , throwing = \"exception\")\n    public void logException(JoinPoint joinPoint, Exception exception) {\n        log.error(\"Exception in {}.{}: {}\",\n            joinPoint.getSignature().getDeclaringTypeName(),\n            joinPoint.getSignature().getName(),\n            exception.getMessage());\n    }\n}"
            },
            {
              "title": "transaction_monitoring",
              "simple-content": "// Performance monitoring aspect for transactions\n@Aspect\n@Component\npublic class TransactionMonitoringAspect {\n    private static final Logger log = LoggerFactory.getLogger(TransactionMonitoringAspect.class);\n    \n    @Around(\"@annotation(org.springframework.transaction.annotation.Transactional)\")\n    public Object monitorTransactionPerformance(ProceedingJoinPoint joinPoint) throws Throwable {\n        String methodName = joinPoint.getSignature().getName();\n        log.info(\"Beginning transaction in method: {}\", methodName);\n        \n        long start = System.currentTimeMillis();\n        Object result = joinPoint.proceed();\n        long duration = System.currentTimeMillis() - start;\n        \n        log.info(\"Transaction completed in {}ms for method: {}\", duration, methodName);\n        return result;\n    }\n}"
            }
          ]
        },
        {
          "title": "boot_specific_considerations",
          "multi-content": [
            "Spring Boot's auto-configuration automatically detects @Aspect beans and registers them",
            "For comprehensive AOP, the spring-boot-starter-aop dependency must be included",
            "AspectJ weaving can be enabled through configuration properties",
            "AOP proxies are created at runtime using Spring's proxy creation mechanism",
            "Spring Boot's AOP implementation serves most common use cases, but for advanced scenarios, consider full AspectJ integration"
          ]
        },
        {
          "title": "key_concepts",
          "multi-content": [
            {
              "title": "Aspect",
              "simple-content": "A module that encapsulates a cross-cutting concern"
            },
            {
              "title": "Join Point",
              "simple-content": "A specific point in program execution (e.g., method execution)"
            },
            {
              "title": "Pointcut",
              "simple-content": "An expression that selects join points"
            },
            {
              "title": "Advice",
              "simple-content": "Action taken at a join point"
            },
            {
              "title": "Weaving",
              "simple-content": "Process of applying aspects to target objects"
            }
          ]
        },
        {
          "title": "advice_types",
          "multi-content": [
            {
              "title": "@Before",
              "multi-content": [
                {
                  "title": "description",
                  "simple-content": "Executes before join point"
                },
                {
                  "title": "use_cases",
                  "simple-content": "Validation, logging, security checks"
                },
                {
                  "title": "code_examples",
                  "multi-content": [
                    {
                      "title": "",
                      "simple-content": "@Before(\"execution(* com.example.service.*.*(..))\")\npublic void logBefore(JoinPoint joinPoint) {\n    System.out.println(\"Before executing: \" + joinPoint.getSignature().getName());\n}"
                    }
                  ]
                }
              ]
            },
            {
              "title": "@After",
              "multi-content": [
                {
                  "title": "description",
                  "simple-content": "Executes after join point (regardless of outcome)"
                },
                {
                  "title": "use_cases",
                  "simple-content": "Resource cleanup, auditing"
                }
              ]
            },
            {
              "title": "@AfterReturning",
              "multi-content": [
                {
                  "title": "description",
                  "simple-content": "Executes after successful join point completion"
                },
                {
                  "title": "use_cases",
                  "simple-content": "Result logging, caching"
                }
              ]
            },
            {
              "title": "@AfterThrowing",
              "multi-content": [
                {
                  "title": "description",
                  "simple-content": "Executes if join point throws exception"
                },
                {
                  "title": "use_cases",
                  "simple-content": "Exception handling, alerting"
                }
              ]
            },
            {
              "title": "@Around",
              "multi-content": [
                {
                  "title": "description",
                  "simple-content": "Surrounds join point execution"
                },
                {
                  "title": "use_cases",
                  "simple-content": "Transaction management, method timing"
                },
                {
                  "title": "example",
                  "simple-content": "@Around(\"execution(* com.example.service.*.*(..))\")\npublic Object logAround(ProceedingJoinPoint joinPoint) throws Throwable {\n    long start = System.currentTimeMillis();\n    \n    Object result = joinPoint.proceed();\n    \n    long end = System.currentTimeMillis();\n    System.out.println(\"Time taken: \" + (end - start) + \"ms\");\n    \n    return result;\n}"
                }
              ]
            }
          ]
        },
        {
          "title": "pointcut_expressions",
          "multi-content": [
            {
              "title": "code_examples",
              "multi-content": [
                {
                  "title": "All methods in service package",
                  "simple-content": "execution(* com.example.service.*.*(..))"
                },
                {
                  "title": "All methods in UserService interface",
                  "simple-content": "execution(* com.example.service.UserService+.*(..))"
                },
                {
                  "title": "All methods annotated with @Transactional",
                  "simple-content": "@annotation(org.springframework.transaction.annotation.Transactional)"
                },
                {
                  "title": "All public methods",
                  "simple-content": "execution(public * *(..))"
                }
              ]
            }
          ]
        },
        {
          "title": "code_examples",
          "multi-content": [
            {
              "title": "",
              "simple-content": "@Aspect\n@Component\npublic class LoggingAspect {\n    \n    // Define pointcut\n    @Pointcut(\"execution(* com.example.service.*.*(..))\")\n    public void serviceMethods() {}\n    \n    // Before advice\n    @Before(\"serviceMethods()\")\n    public void logBefore(JoinPoint joinPoint) {\n        System.out.println(\"Before executing: \" + joinPoint.getSignature().getName());\n    }\n    \n    // Around advice\n    @Around(\"@annotation(com.example.annotation.LogExecutionTime)\")\n    public Object logExecutionTime(ProceedingJoinPoint joinPoint) throws Throwable {\n        long start = System.currentTimeMillis();\n        \n        Object result = joinPoint.proceed();\n        \n        long end = System.currentTimeMillis();\n        System.out.println(\"Time taken: \" + (end - start) + \"ms\");\n        \n        return result;\n    }\n}"
            }
          ]
        }
      ]
    },
    {
      "title": "ApplicationContext",
      "multi-content": [
        {
          "title": "description",
          "simple-content": "An advanced IoC container that provides enterprise-level features beyond basic bean management."
        },
        {
          "title": "definition",
          "simple-content": "A central interface that provides configuration for an application, representing the Spring IoC container and responsible for instantiating, configuring, and assembling beans."
        },
        {
          "title": "key_features",
          "multi-content": [
            "Extends BeanFactory with enterprise features",
            "Provides event publication mechanism",
            "Supports internationalization (i18n)",
            "Resource loading capabilities",
            "Integration with AOP",
            "Eager bean initialization"
          ]
        },
        {
          "title": "context_types",
          "multi-content": [
            {
              "title": "AnnotationConfigApplicationContext",
              "simple-content": "For Java-based configuration"
            },
            {
              "title": "ClassPathXmlApplicationContext",
              "simple-content": "For XML configuration loaded from classpath"
            },
            {
              "title": "FileSystemXmlApplicationContext",
              "simple-content": "For XML configuration loaded from file system"
            },
            {
              "title": "WebApplicationContext",
              "simple-content": "For web applications"
            }
          ]
        },
        {
          "title": "vs_beanfactory",
          "multi-content": [
            {
              "title": "Bean Instantiation",
              "multi-content": [
                {
                  "title": "beanFactory",
                  "simple-content": "Lazy (on request)"
                },
                {
                  "title": "applicationContext",
                  "simple-content": "Eager (at startup)"
                }
              ]
            },
            {
              "title": "Event Publication",
              "multi-content": [
                {
                  "title": "beanFactory",
                  "simple-content": "Not supported"
                },
                {
                  "title": "applicationContext",
                  "simple-content": "Supported"
                }
              ]
            },
            {
              "title": "Resource Access",
              "multi-content": [
                {
                  "title": "beanFactory",
                  "simple-content": "Limited"
                },
                {
                  "title": "applicationContext",
                  "simple-content": "Enhanced"
                }
              ]
            }
          ]
        },
        {
          "title": "code_examples",
          "multi-content": [
            {
              "title": "creating_context",
              "simple-content": "// From Java configuration\nApplicationContext context = new AnnotationConfigApplicationContext(AppConfig.class);\n\n// From XML\nApplicationContext context = new ClassPathXmlApplicationContext(\"applicationContext.xml\");"
            },
            {
              "title": "getting_beans",
              "simple-content": "// By type\nUserService userService = context.getBean(UserService.class);\n\n// By name\nUserRepository userRepository = (UserRepository) context.getBean(\"userRepository\");\n\n// By name and type\nDataSource dataSource = context.getBean(\"primaryDataSource\", DataSource.class);"
            }
          ]
        }
      ]
    },
    {
      "title": "SpringExceptions",
      "multi-content": [
        {
          "title": "description",
          "simple-content": "Understanding common Spring exceptions and how to troubleshoot them effectively."
        },
        {
          "title": "key_exceptions",
          "multi-content": [
            {
              "title": "NoSuchBeanDefinitionException",
              "multi-content": [
                {
                  "title": "description",
                  "simple-content": "Occurs when Spring cannot find a bean of the requested type or name"
                },
                {
                  "title": "causes",
                  "multi-content": [
                    "Missing component scan configuration",
                    "Bean not properly defined",
                    "Bean outside scanned packages",
                    "Wrong qualifier or name specified",
                    "Bean not active under current profile"
                  ]
                },
                {
                  "title": "resolution",
                  "multi-content": [
                    "Check component scanning configuration",
                    "Ensure bean is properly annotated or defined",
                    "Verify package structure",
                    "Check profile configuration"
                  ]
                }
              ]
            },
            {
              "title": "UnsatisfiedDependencyException",
              "multi-content": [
                {
                  "title": "description",
                  "simple-content": "Occurs when a bean's dependencies cannot be resolved"
                },
                {
                  "title": "causes",
                  "multi-content": [
                    "Missing dependency bean",
                    "Ambiguous dependencies without proper disambiguation",
                    "Circular dependencies with constructor injection",
                    "Type mismatch in dependency"
                  ]
                },
                {
                  "title": "resolution",
                  "multi-content": [
                    "Ensure all dependencies are available",
                    "Use @Qualifier or @Primary for disambiguation",
                    "Check for circular dependencies",
                    "Verify type compatibility"
                  ]
                }
              ]
            },
            {
              "title": "BeanCreationException",
              "multi-content": [
                {
                  "title": "description",
                  "simple-content": "Occurs during bean instantiation process"
                },
                {
                  "title": "causes",
                  "multi-content": [
                    "Exception in bean constructor",
                    "Exception in @PostConstruct method",
                    "Bean initialization error",
                    "Circular dependencies"
                  ]
                },
                {
                  "title": "resolution",
                  "multi-content": [
                    "Check for exceptions in bean initialization",
                    "Debug initialization methods",
                    "Look for circular dependencies",
                    "Examine nested exceptions"
                  ]
                }
              ]
            },
            {
              "title": "BeanCurrentlyInCreationException",
              "multi-content": [
                {
                  "title": "description",
                  "simple-content": "Occurs with circular dependencies"
                },
                {
                  "title": "causes",
                  "multi-content": [
                    "Circular dependencies with constructor injection"
                  ]
                },
                {
                  "title": "resolution",
                  "multi-content": [
                    "Redesign components to eliminate circular dependency",
                    "Use setter injection instead of constructor injection",
                    "Use @Lazy annotation on one of the dependencies"
                  ]
                }
              ]
            }
          ]
        },
        {
          "title": "troubleshooting_approaches",
          "multi-content": [
            {
              "title": "Read the Stack Trace",
              "simple-content": "Carefully examine the exception message and stack trace"
            },
            {
              "title": "Enable Debug Logging",
              "simple-content": "Increase log level to get more information"
            },
            {
              "title": "Use ApplicationContext Events",
              "simple-content": "Listen to context events to identify issues"
            },
            {
              "title": "Inspect Bean Definitions",
              "simple-content": "Programmatically inspect bean definitions"
            }
          ]
        }
      ]
    }
  ]
}