{
  "id": "spring-core-concepts-fr",
  "title": "Concepts de Base de Spring",
  "topics": [
    {
      "title": "IoC",
      "multi-content": [
        {
          "title": "description",
          "simple-content": "L'Inversion de Contrôle (IoC) est un principe de conception où le contrôle de la création et du cycle de vie des objets est transféré du code de l'application à un conteneur ou un framework externe."
        },
        {
          "title": "définition",
          "simple-content": "Un principe de conception où le contrôle de la création d'objets et la gestion des dépendances est délégué à un conteneur externe, améliorant la modularité et la testabilité."
        },
        {
          "title": "avantages",
          "multi-content": [
            "Découple la création des composants de leur utilisation",
            "Favorise une conception modulaire et la testabilité",
            "Permet une architecture d'application flexible",
            "Forme la base pour l'injection de dépendances",
            "Couplage faible entre les composants",
            "Meilleure testabilité grâce à la facilité de mockage"
          ]
        },
        {
          "title": "code_examples",
          "multi-content": [
            {
              "title": "without_ioc",
              "simple-content": "public class UserService {\n    private UserRepository userRepository = new UserRepositoryImpl();\n}"
            },
            {
              "title": "with_ioc",
              "simple-content": "public class UserService {\n    private UserRepository userRepository;\n    \n    // Container injects the dependency\n    public UserService(UserRepository userRepository) {\n        this.userRepository = userRepository;\n    }\n}"
            }
          ]
        }
      ]
    },
    {
      "title": "Injection de Dépendances",
      "multi-content": [
        {
          "title": "description",
          "simple-content": "Un modèle spécifique d'implémentation de l'IoC où les dépendances d'un objet sont fournies par une source externe plutôt que créées en interne."
        },
        {
          "title": "définition",
          "simple-content": "Un modèle dans lequel les dépendances d'un objet sont fournies par une source externe (généralement le conteneur IoC) plutôt que l'objet les instanciant lui-même, favorisant un couplage faible."
        },
        {
          "title": "types",
          "multi-content": [
            {
              "title": "Injection par Constructeur",
              "multi-content": [
                {
                  "title": "description",
                  "simple-content": "Dépendances fournies via le constructeur"
                },
                {
                  "title": "idéal_pour",
                  "simple-content": "Dépendances requises, objets immuables"
                },
                {
                  "title": "exemple",
                  "simple-content": "public Service(Dependency d) {...}"
                },
                {
                  "title": "avantages",
                  "multi-content": [
                    "Garantit que les dépendances requises sont fournies",
                    "Favorise l'immuabilité (les dépendances peuvent être finales)",
                    "Rend les dépendances explicites et visibles à la construction",
                    "Plus facile à tester et à fournir des mocks",
                    "Fonctionne sans conteneur DI",
                    "Détecte les dépendances circulaires à la compilation"
                  ]
                }
              ]
            },
            {
              "title": "Injection par Setter",
              "multi-content": [
                {
                  "title": "description",
                  "simple-content": "Dépendances fournies via des méthodes setter"
                },
                {
                  "title": "idéal_pour",
                  "simple-content": "Dépendances optionnelles, objets reconfigurables"
                },
                {
                  "title": "exemple",
                  "simple-content": "public void setDependency(Dependency d) {...}"
                },
                {
                  "title": "avantages",
                  "multi-content": [
                    "Permet des dépendances optionnelles",
                    "Offre de la flexibilité dans la gestion des dépendances",
                    "Prend en charge la modification des dépendances à l'exécution"
                  ]
                }
              ]
            },
            {
              "title": "Injection par Champ",
              "multi-content": [
                {
                  "title": "description",
                  "simple-content": "Dépendances injectées directement dans les champs"
                },
                {
                  "title": "idéal_pour",
                  "simple-content": "Cas simples (généralement déconseillé)"
                },
                {
                  "title": "exemple",
                  "simple-content": "@Autowired private Dependency d;"
                },
                {
                  "title": "avantages",
                  "multi-content": [
                    "Moins de code standard",
                    "Plus simple à écrire"
                  ]
                },
                {
                  "title": "inconvénients",
                  "multi-content": [
                    "Plus difficile à tester",
                    "Impossible de déclarer les champs comme final",
                    "Dépendances cachées"
                  ]
                }
              ]
            }
          ]
        },
        {
          "title": "code_examples",
          "multi-content": [
            {
              "title": "constructor_injection",
              "simple-content": "@Service\npublic class UserService {\n    private final UserRepository userRepository;\n    \n    @Autowired // Optional in Spring 4.3+ with single constructor\n    public UserService(UserRepository userRepository) {\n        this.userRepository = userRepository;\n    }\n}"
            },
            {
              "title": "setter_injection",
              "simple-content": "@Service\npublic class UserService {\n    private UserRepository userRepository;\n    \n    @Autowired\n    public void setUserRepository(UserRepository userRepository) {\n        this.userRepository = userRepository;\n    }\n}"
            },
            {
              "title": "field_injection",
              "simple-content": "@Service\npublic class UserService {\n    @Autowired\n    private UserRepository userRepository;\n}"
            }
          ]
        }
      ]
    },
    {
      "title": "Cycle de Vie des Beans",
      "multi-content": [
        {
          "title": "description",
          "simple-content": "Le parcours d'un bean Spring de l'initialisation à la destruction, avec des opportunités de personnalisation à chaque étape."
        },
        {
          "title": "définition",
          "simple-content": "Le processus complet qu'un bean Spring subit—de l'instanciation et l'injection de dépendances à l'initialisation et l'éventuelle destruction—avec des opportunités de comportement personnalisé à diverses étapes."
        },
        {
          "title": "phases_du_cycle_de_vie",
          "multi-content": [
            {
              "title": "Définition du Bean",
              "multi-content": [
                {
                  "title": "description",
                  "simple-content": "Spring lit la configuration et crée des objets BeanDefinition"
                },
                {
                  "title": "événements",
                  "multi-content": [
                    "Les métadonnées de configuration sont chargées (annotations, XML, configuration Java)",
                    "Les objets BeanDefinition sont créés et enregistrés auprès du conteneur"
                  ]
                }
              ]
            },
            {
              "title": "Instanciation du Bean",
              "multi-content": [
                {
                  "title": "description",
                  "simple-content": "Spring crée l'instance du bean"
                },
                {
                  "title": "événements",
                  "multi-content": [
                    "Le constructeur est invoqué",
                    "La méthode factory est appelée (si configurée)"
                  ]
                }
              ]
            },
            {
              "title": "Population des Propriétés",
              "multi-content": [
                {
                  "title": "description",
                  "simple-content": "Les dépendances sont injectées"
                },
                {
                  "title": "événements",
                  "multi-content": [
                    "Les propriétés sont définies",
                    "Les dépendances sont résolues et injectées"
                  ]
                }
              ]
            },
            {
              "title": "Initialisation",
              "multi-content": [
                {
                  "title": "description",
                  "simple-content": "Le bean est initialisé via des callbacks"
                },
                {
                  "title": "événements",
                  "multi-content": [
                    "BeanNameAware.setBeanName() est appelé",
                    "BeanFactoryAware.setBeanFactory() est appelé",
                    "ApplicationContextAware.setApplicationContext() est appelé",
                    "Les méthodes BeanPostProcessor.postProcessBeforeInitialization() sont appelées",
                    "Les méthodes @PostConstruct sont appelées",
                    "InitializingBean.afterPropertiesSet() est appelé",
                    "La méthode init personnalisée est appelée",
                    "Les méthodes BeanPostProcessor.postProcessAfterInitialization() sont appelées"
                  ]
                }
              ]
            },
            {
              "title": "Utilisation du Bean",
              "multi-content": [
                {
                  "title": "description",
                  "simple-content": "Le bean est prêt à être utilisé par l'application"
                }
              ]
            },
            {
              "title": "Destruction",
              "multi-content": [
                {
                  "title": "description",
                  "simple-content": "Le bean est détruit lorsque le contexte est fermé"
                },
                {
                  "title": "événements",
                  "multi-content": [
                    "Les méthodes @PreDestroy sont appelées",
                    "DisposableBean.destroy() est appelé",
                    "La méthode destroy personnalisée est appelée"
                  ]
                }
              ]
            }
          ]
        },
        {
          "title": "méthodes_de_callback",
          "multi-content": [
            {
              "title": "initialisation",
              "multi-content": [
                {
                  "title": "basée_sur_annotation",
                  "simple-content": "@PostConstruct"
                },
                {
                  "title": "basée_sur_interface",
                  "simple-content": "InitializingBean.afterPropertiesSet()"
                },
                {
                  "title": "basée_sur_xml",
                  "simple-content": "attribut init-method"
                }
              ]
            },
            {
              "title": "destruction",
              "multi-content": [
                {
                  "title": "basée_sur_annotation",
                  "simple-content": "@PreDestroy"
                },
                {
                  "title": "basée_sur_interface",
                  "simple-content": "DisposableBean.destroy()"
                },
                {
                  "title": "basée_sur_xml",
                  "simple-content": "attribut destroy-method"
                }
              ]
            }
          ]
        },
        {
          "title": "exemple",
          "simple-content": "@Component\npublic class LifecycleBean implements InitializingBean, DisposableBean {\n    \n    // Constructor\n    public LifecycleBean() {\n        System.out.println(\"1. Constructor called\");\n    }\n    \n    // Setter injection\n    @Autowired\n    public void setDependency(SomeDependency dependency) {\n        System.out.println(\"2. Dependencies injected\");\n    }\n    \n    // Annotation-based initialization\n    @PostConstruct\n    public void postConstruct() {\n        System.out.println(\"3. @PostConstruct called\");\n    }\n    \n    // Interface-based initialization\n    @Override\n    public void afterPropertiesSet() throws Exception {\n        System.out.println(\"4. afterPropertiesSet() called\");\n    }\n    \n    // Custom initialization method\n    public void customInit() {\n        System.out.println(\"5. Custom init method called\");\n    }\n    \n    // Annotation-based destruction\n    @PreDestroy\n    public void preDestroy() {\n        System.out.println(\"6. @PreDestroy called\");\n    }\n    \n    // Interface-based destruction\n    @Override\n    public void destroy() throws Exception {\n        System.out.println(\"7. DisposableBean.destroy() called\");\n    }\n}"
        }
      ]
    },
    {
      "title": "Portées des Beans",
      "multi-content": [
        {
          "title": "description",
          "simple-content": "Les portées des beans définissent le cycle de vie d'un bean, sa visibilité et le nombre d'instances créées."
        },
        {
          "title": "définition",
          "simple-content": "Définit le cycle de vie et la visibilité d'un bean dans le conteneur. Chaque portée détermine quand une nouvelle instance est créée et combien de temps elle vit."
        },
        {
          "title": "types_de_portée",
          "multi-content": [
            {
              "title": "singleton",
              "multi-content": [
                {
                  "title": "description",
                  "simple-content": "Portée par défaut; une instance par conteneur Spring"
                },
                {
                  "title": "instances",
                  "simple-content": "Unique"
                },
                {
                  "title": "cycle_de_vie",
                  "simple-content": "Cycle de vie du conteneur"
                },
                {
                  "title": "idéal_pour",
                  "simple-content": "Services sans état et repositories"
                }
              ]
            },
            {
              "title": "prototype",
              "multi-content": [
                {
                  "title": "description",
                  "simple-content": "Nouvelle instance de bean pour chaque demande/injection"
                },
                {
                  "title": "instances",
                  "simple-content": "Multiples"
                },
                {
                  "title": "cycle_de_vie",
                  "simple-content": "De la création jusqu'à ce qu'il ne soit plus référencé"
                },
                {
                  "title": "idéal_pour",
                  "simple-content": "Objets avec état comme les formulaires ou les paniers d'achat"
                }
              ]
            },
            {
              "title": "request",
              "multi-content": [
                {
                  "title": "description",
                  "simple-content": "Une instance par requête HTTP (orienté web)"
                },
                {
                  "title": "instances",
                  "simple-content": "Multiples"
                },
                {
                  "title": "cycle_de_vie",
                  "simple-content": "Requête HTTP"
                },
                {
                  "title": "idéal_pour",
                  "simple-content": "Données spécifiques à la requête HTTP"
                }
              ]
            },
            {
              "title": "session",
              "multi-content": [
                {
                  "title": "description",
                  "simple-content": "Une instance par session HTTP (orienté web)"
                },
                {
                  "title": "instances",
                  "simple-content": "Multiples"
                },
                {
                  "title": "cycle_de_vie",
                  "simple-content": "Session HTTP"
                },
                {
                  "title": "idéal_pour",
                  "simple-content": "Données spécifiques à l'utilisateur dans les applications web"
                }
              ]
            },
            {
              "title": "application",
              "multi-content": [
                {
                  "title": "description",
                  "simple-content": "Une instance par ServletContext (orienté web)"
                },
                {
                  "title": "instances",
                  "simple-content": "Unique"
                },
                {
                  "title": "cycle_de_vie",
                  "simple-content": "Cycle de vie du ServletContext"
                },
                {
                  "title": "idéal_pour",
                  "simple-content": "Beans à l'échelle de l'application"
                }
              ]
            },
            {
              "title": "websocket",
              "multi-content": [
                {
                  "title": "description",
                  "simple-content": "Une instance par WebSocket (orienté web)"
                },
                {
                  "title": "instances",
                  "simple-content": "Multiples"
                },
                {
                  "title": "cycle_de_vie",
                  "simple-content": "Cycle de vie WebSocket"
                },
                {
                  "title": "idéal_pour",
                  "simple-content": "Beans spécifiques aux WebSockets"
                }
              ]
            }
          ]
        },
        {
          "title": "code_examples",
          "multi-content": [
            {
              "title": "singleton_scope",
              "simple-content": "@Component\n@Scope(\"singleton\") // or simply @Component since singleton is default\npublic class UserService { /* ... */ }"
            },
            {
              "title": "prototype_scope",
              "simple-content": "@Component\n@Scope(\"prototype\")\npublic class ShoppingCart { /* ... */ }"
            },
            {
              "title": "request_scope",
              "simple-content": "@Component\n@RequestScope // or @Scope(value = \"request\", proxyMode = ScopedProxyMode.TARGET_CLASS)\npublic class RequestScopedBean { /* ... */ }"
            },
            {
              "title": "mixing_scopes",
              "simple-content": "// Problem: Injecting prototype into singleton\n@Component\npublic class SingletonBean {\n    @Autowired\n    private PrototypeBean prototypeBean; // Will always be the same instance!\n}\n\n// Solution 1: Scoped Proxy\n@Component\n@Scope(value = \"prototype\", proxyMode = ScopedProxyMode.TARGET_CLASS)\npublic class PrototypeBean { /* ... */ }\n\n// Solution 2: ObjectFactory\n@Component\npublic class SingletonBean {\n    @Autowired\n    private ObjectFactory<PrototypeBean> prototypeBeanFactory;\n    \n    public void doSomething() {\n        PrototypeBean prototypeBean = prototypeBeanFactory.getObject(); // New instance\n        // Use prototypeBean\n    }\n}"
            }
          ]
        }
      ]
    },
    {
      "title": "Configuration Spring",
      "multi-content": [
        {
          "title": "description",
          "simple-content": "Différentes approches pour configurer les beans et gérer les dépendances dans les applications Spring."
        },
        {
          "title": "définition",
          "simple-content": "Le processus de définition des beans, leurs dépendances et autres paramètres d'application à gérer par le conteneur Spring."
        },
        {
          "title": "types_de_configuration",
          "multi-content": [
            {
              "title": "Configuration Java",
              "multi-content": [
                {
                  "title": "description",
                  "simple-content": "Utilisation des annotations @Configuration et @Bean dans les classes Java"
                },
                {
                  "title": "idéal_pour",
                  "simple-content": "Sécurité de type, facilité de refactoring, support IDE"
                },
                {
                  "title": "avantages",
                  "multi-content": [
                    "Sécurité de type",
                    "Vérifications à la compilation",
                    "Meilleur support de refactoring",
                    "Autocomplétion IDE",
                    "Configuration programmatique"
                  ]
                },
                {
                  "title": "exemple",
                  "simple-content": "@Configuration\npublic class AppConfig {\n    \n    @Bean\n    public UserRepository userRepository() {\n        return new JpaUserRepository();\n    }\n    \n    @Bean\n    public UserService userService(UserRepository userRepository) {\n        return new UserServiceImpl(userRepository);\n    }\n}"
                }
              ]
            },
            {
              "title": "Configuration par Annotations",
              "multi-content": [
                {
                  "title": "description",
                  "simple-content": "Utilisation du scan de composants avec @Component, @Service, etc."
                },
                {
                  "title": "idéal_pour",
                  "simple-content": "Simplicité, réduction du code standard, convention plutôt que configuration"
                },
                {
                  "title": "avantages",
                  "multi-content": [
                    "Moins de code de configuration",
                    "Configuration plus proche de l'implémentation",
                    "Détection automatique des composants",
                    "Code propre et lisible"
                  ]
                },
                {
                  "title": "exemple",
                  "simple-content": "@Configuration\n@ComponentScan(basePackages = \"com.example\")\npublic class AppConfig {\n    // Configuration for component scanning\n}\n\n@Component\npublic class SimpleComponent { /* ... */ }\n\n@Repository\npublic class JpaUserRepository implements UserRepository { /* ... */ }\n\n@Service\npublic class UserServiceImpl implements UserService {\n    @Autowired\n    private UserRepository userRepository;\n    // Implementation\n}"
                }
              ]
            },
            {
              "title": "Configuration XML",
              "multi-content": [
                {
                  "title": "description",
                  "simple-content": "Utilisation de fichiers XML avec définitions <bean>"
                },
                {
                  "title": "idéal_pour",
                  "simple-content": "Configuration externe, systèmes hérités"
                },
                {
                  "title": "avantages",
                  "multi-content": [
                    "Pas de recompilation nécessaire pour les changements de configuration",
                    "Séparation complète du code",
                    "Support pour Spring hérité",
                    "Câblage explicite des dépendances"
                  ]
                },
                {
                  "title": "exemple",
                  "simple-content": "<!-- applicationContext.xml -->\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n                           http://www.springframework.org/schema/beans/spring-beans.xsd\">\n\n    <bean id=\"userRepository\" class=\"com.example.JpaUserRepository\" />\n    \n    <bean id=\"userService\" class=\"com.example.UserServiceImpl\">\n        <constructor-arg ref=\"userRepository\" />\n    </bean>\n</beans>"
                }
              ]
            }
          ]
        },
        {
          "title": "annotations_courantes",
          "multi-content": [
            {
              "title": "@Configuration",
              "simple-content": "Indique qu'une classe définit des méthodes de bean"
            },
            {
              "title": "@Bean",
              "simple-content": "Marque une méthode comme produisant un bean Spring"
            },
            {
              "title": "@Component",
              "simple-content": "Stéréotype générique pour les composants gérés par Spring"
            },
            {
              "title": "@Repository",
              "simple-content": "Stéréotype pour les composants de la couche de persistance"
            },
            {
              "title": "@Service",
              "simple-content": "Stéréotype pour les composants de la couche de service"
            },
            {
              "title": "@Controller",
              "simple-content": "Stéréotype pour les composants de la couche de présentation"
            },
            {
              "title": "@Autowired",
              "simple-content": "Marque un point d'injection de dépendance"
            },
            {
              "title": "@Qualifier",
              "simple-content": "Désambiguïse quel bean injecter"
            },
            {
              "title": "@Value",
              "simple-content": "Injecte des valeurs depuis des propriétés ou des expressions"
            },
            {
              "title": "@Profile",
              "simple-content": "Active des beans pour des environnements spécifiques"
            }
          ]
        }
      ]
    },
    {
      "title": "Scan des Composants",
      "multi-content": [
        {
          "title": "description",
          "simple-content": "Le processus par lequel Spring identifie et enregistre automatiquement les beans à partir de packages spécifiés."
        },
        {
          "title": "définition",
          "simple-content": "Un mécanisme qui permet à Spring de détecter et d'enregistrer automatiquement des beans Spring en scannant des packages de base spécifiques pour des classes avec des annotations stéréotypées."
        },
        {
          "title": "concepts_clés",
          "multi-content": [
            {
              "title": "packages_de_base",
              "simple-content": "Les points de départ pour le scan des composants, généralement le package racine de votre application"
            },
            {
              "title": "annotations_stéréotypées",
              "simple-content": "Marqueurs pour les classes qui devraient être automatiquement enregistrées comme beans (@Component et ses spécialisations)"
            },
            {
              "title": "filtres",
              "simple-content": "Règles pour inclure ou exclure certaines classes du scan"
            },
            {
              "title": "nommage_des_beans",
              "simple-content": "Comment Spring nomme automatiquement les composants scannés (généralement nom de classe en camelCase)"
            }
          ]
        },
        {
          "title": "annotations",
          "multi-content": [
            {
              "title": "@Component",
              "simple-content": "Annotation générique pour tout composant géré par Spring"
            },
            {
              "title": "@Service",
              "simple-content": "Indique que la classe appartient à la couche de service (logique métier)"
            },
            {
              "title": "@Repository",
              "simple-content": "Indique une classe de couche de persistance avec traduction automatique des exceptions"
            },
            {
              "title": "@Controller",
              "simple-content": "Indique un composant contrôleur web"
            },
            {
              "title": "@RestController",
              "simple-content": "Combine @Controller et @ResponseBody pour les contrôleurs RESTful"
            }
          ]
        },
        {
          "title": "code_examples",
          "multi-content": [
            {
              "title": "basic_scanning",
              "simple-content": "@Configuration\n@ComponentScan(basePackages = \"com.example\")\npublic class AppConfig {\n    // Configuration\n}"
            },
            {
              "title": "multiple_packages",
              "simple-content": "@Configuration\n@ComponentScan(basePackages = {\"com.example.service\", \"com.example.repository\"})\npublic class AppConfig {\n    // Configuration\n}"
            },
            {
              "title": "using_filters",
              "simple-content": "@Configuration\n@ComponentScan(\n    basePackages = \"com.example\",\n    includeFilters = @ComponentScan.Filter(type = FilterType.REGEX, pattern = \".*Repository\"),\n    excludeFilters = @ComponentScan.Filter(type = FilterType.ANNOTATION, classes = Deprecated.class)\n)\npublic class AppConfig {\n    // Configuration\n}"
            }
          ]
        },
        {
          "title": "processus_de_scan",
          "multi-content": [
            "Spring recherche les packages de base et sous-packages",
            "Trouve les classes avec des annotations stéréotypées",
            "Lit les métadonnées à partir des annotations",
            "Filtre les classes en fonction des règles d'inclusion/exclusion",
            "Enregistre les BeanDefinitions pour les classes correspondantes",
            "Nomme les beans (généralement le nom de classe décapitalisé)",
            "Traite les annotations supplémentaires (comme @Scope, @Lazy)"
          ]
        }
      ]
    },
    {
      "title": "Résolution des Dépendances",
      "multi-content": [
        {
          "title": "description",
          "simple-content": "Comment Spring résout les dépendances et gère les scénarios avec plusieurs candidats."
        },
        {
          "title": "définition",
          "simple-content": "Le processus par lequel Spring identifie et sélectionne les beans appropriés à injecter lorsque des dépendances sont déclarées."
        },
        {
          "title": "mécanismes_de_résolution",
          "multi-content": [
            {
              "title": "@Qualifier",
              "multi-content": [
                {
                  "title": "description",
                  "simple-content": "Spécifie quel bean injecter lorsque plusieurs candidats existent"
                },
                {
                  "title": "exemple",
                  "simple-content": "@Service(\"premiumService\")\npublic class PremiumUserService implements UserService { /* ... */ }\n\n@Service(\"basicService\")\npublic class BasicUserService implements UserService { /* ... */ }\n\n@Component\npublic class UserController {\n    private final UserService userService;\n    \n    @Autowired\n    public UserController(@Qualifier(\"premiumService\") UserService userService) {\n        this.userService = userService;\n    }\n}"
                }
              ]
            },
            {
              "title": "@Primary",
              "multi-content": [
                {
                  "title": "description",
                  "simple-content": "Marque un bean comme candidat principal pour l'autowiring"
                },
                {
                  "title": "exemple",
                  "simple-content": "@Service\n@Primary\npublic class PrimaryUserService implements UserService { /* ... */ }\n\n@Service\npublic class SecondaryUserService implements UserService { /* ... */ }\n\n@Component\npublic class UserController {\n    private final UserService userService;\n    \n    @Autowired\n    public UserController(UserService userService) {\n        // PrimaryUserService will be injected\n        this.userService = userService;\n    }\n}"
                }
              ]
            },
            {
              "title": "Autowiring par Nom de Bean",
              "multi-content": [
                {
                  "title": "description",
                  "simple-content": "Correspondance par nom de paramètre/champ"
                },
                {
                  "title": "exemple",
                  "simple-content": "@Component(\"premiumService\")\npublic class PremiumUserService implements UserService { /* ... */ }\n\n@Component(\"basicService\")\npublic class BasicUserService implements UserService { /* ... */ }\n\n@Component\npublic class UserController {\n    private final UserService premiumService; // Name matches bean id\n    \n    @Autowired\n    public UserController(UserService premiumService) {\n        this.premiumService = premiumService;\n    }\n}"
                }
              ]
            }
          ]
        },
        {
          "title": "ordre_de_résolution",
          "multi-content": [
            "1. Correspondance exacte de type (si un seul bean du type requis existe)",
            "2. Correspondance par @Qualifier si spécifié",
            "3. Correspondance avec le bean @Primary si disponible",
            "4. Correspondance par nom (si le nom du paramètre/champ correspond à un nom de bean)",
            "5. Lance une exception si aucun bean unique ne peut être déterminé"
          ]
        },
        {
          "title": "exceptions_courantes",
          "multi-content": [
            {
              "title": "NoSuchBeanDefinitionException",
              "simple-content": "Aucun bean qualifié trouvé"
            },
            {
              "title": "NoUniqueBeanDefinitionException",
              "simple-content": "Plusieurs beans qualifiés trouvés"
            },
            {
              "title": "BeanCreationException",
              "simple-content": "Erreur lors de la création du bean"
            }
          ]
        }
      ]
    },
    {
      "title": "Dépendances Circulaires",
      "multi-content": [
        {
          "title": "description",
          "simple-content": "Une situation où le bean A dépend du bean B, et le bean B dépend du bean A, directement ou indirectement."
        },
        {
          "title": "définition",
          "simple-content": "Une dépendance circulaire survient lorsque deux ou plusieurs beans dépendent l'un de l'autre, créant un cycle de dépendances qui peut causer des problèmes d'initialisation."
        },
        {
          "title": "types_de_dépendance",
          "multi-content": [
            {
              "title": "Circularité d'Injection par Constructeur",
              "multi-content": [
                {
                  "title": "résolvable",
                  "simple-content": "false"
                },
                {
                  "title": "description",
                  "simple-content": "Ne peut pas être résolu par Spring"
                },
                {
                  "title": "exemple",
                  "simple-content": "@Component\npublic class BeanA {\n    private final BeanB beanB;\n    \n    @Autowired\n    public BeanA(BeanB beanB) {\n        this.beanB = beanB;\n    }\n}\n\n@Component\npublic class BeanB {\n    private final BeanA beanA;\n    \n    @Autowired\n    public BeanB(BeanA beanA) {\n        this.beanA = beanA;\n    }\n}"
                }
              ]
            },
            {
              "title": "Circularité d'Injection par Setter",
              "multi-content": [
                {
                  "title": "résolvable",
                  "simple-content": "true"
                },
                {
                  "title": "description",
                  "simple-content": "Peut être résolu par Spring"
                },
                {
                  "title": "exemple",
                  "simple-content": "@Component\npublic class BeanA {\n    private BeanB beanB;\n    \n    @Autowired\n    public void setBeanB(BeanB beanB) {\n        this.beanB = beanB;\n    }\n}\n\n@Component\npublic class BeanB {\n    private BeanA beanA;\n    \n    @Autowired\n    public void setBeanA(BeanA beanA) {\n        this.beanA = beanA;\n    }\n}"
                }
              ]
            }
          ]
        },
        {
          "title": "détection",
          "simple-content": "Spring détecte les dépendances circulaires lors du démarrage de l'application et lance BeanCurrentlyInCreationException si elles ne peuvent pas être résolues."
        },
        {
          "title": "stratégies_de_résolution",
          "multi-content": [
            {
              "title": "Reconcevoir les Composants",
              "multi-content": [
                {
                  "title": "recommandation",
                  "simple-content": "Meilleure pratique"
                },
                {
                  "title": "description",
                  "simple-content": "Repenser les dépendances pour éliminer les références circulaires"
                },
                {
                  "title": "détails",
                  "multi-content": [
                    "Extraire la fonctionnalité partagée vers un troisième service",
                    "Appliquer le Principe d'Inversion de Dépendance",
                    "Utiliser des événements pour la communication"
                  ]
                }
              ]
            },
            {
              "title": "Utiliser l'Injection par Setter",
              "multi-content": [
                {
                  "title": "description",
                  "simple-content": "Passer de l'injection par constructeur à l'injection par setter"
                },
                {
                  "title": "mise_en_garde",
                  "simple-content": "Crée la possibilité de beans partiellement initialisés"
                }
              ]
            },
            {
              "title": "Utiliser l'Annotation @Lazy",
              "multi-content": [
                {
                  "title": "description",
                  "simple-content": "Différer un côté de la dépendance"
                },
                {
                  "title": "exemple",
                  "simple-content": "@Component\npublic class BeanA {\n    private final BeanB beanB;\n    \n    @Autowired\n    public BeanA(@Lazy BeanB beanB) {\n        this.beanB = beanB;\n    }\n}"
                }
              ]
            },
            {
              "title": "Utiliser des Événements",
              "multi-content": [
                {
                  "title": "description",
                  "simple-content": "Découpler la communication en utilisant le système d'événements de Spring"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "title": "AOP",
      "multi-content": [
        {
          "title": "description",
          "simple-content": "L'AOP aborde les préoccupations transversales en les séparant de la logique métier principale, favorisant un code plus propre et plus maintenable."
        },
        {
          "title": "définition",
          "simple-content": "Un paradigme de programmation qui sépare les préoccupations transversales (comme la journalisation, la sécurité ou la gestion des transactions) de la logique métier en utilisant des aspects, des conseils, des points de jointure et des points de coupure."
        },
        {
          "title": "concepts_clés",
          "multi-content": [
            {
              "title": "Aspect",
              "simple-content": "Un module qui encapsule une préoccupation transversale"
            },
            {
              "title": "Point de Jointure",
              "simple-content": "Un point spécifique dans l'exécution du programme (par exemple, l'exécution d'une méthode)"
            },
            {
              "title": "Point de Coupure",
              "simple-content": "Une expression qui sélectionne des points de jointure"
            },
            {
              "title": "Conseil",
              "simple-content": "Action prise à un point de jointure"
            },
            {
              "title": "Tissage",
              "simple-content": "Processus d'application des aspects aux objets cibles"
            }
          ]
        },
        {
          "title": "types_de_conseil",
          "multi-content": [
            {
              "title": "@Before",
              "multi-content": [
                {
                  "title": "description",
                  "simple-content": "S'exécute avant le point de jointure"
                },
                {
                  "title": "cas_d_utilisation",
                  "simple-content": "Validation, journalisation, vérifications de sécurité"
                },
                {
                  "title": "code_examples",
                  "multi-content": [
                    {
                      "title": "",
                      "simple-content": "@Before(\"execution(* com.example.service.*.*(..))\")\npublic void logBefore(JoinPoint joinPoint) {\n    System.out.println(\"Before executing: \" + joinPoint.getSignature().getName());\n}"
                    }
                  ]
                }
              ]
            },
            {
              "title": "@After",
              "multi-content": [
                {
                  "title": "description",
                  "simple-content": "S'exécute après le point de jointure (indépendamment du résultat)"
                },
                {
                  "title": "cas_d_utilisation",
                  "simple-content": "Nettoyage des ressources, audit"
                }
              ]
            },
            {
              "title": "@AfterReturning",
              "multi-content": [
                {
                  "title": "description",
                  "simple-content": "S'exécute après la réussite du point de jointure"
                },
                {
                  "title": "cas_d_utilisation",
                  "simple-content": "Journalisation des résultats, mise en cache"
                }
              ]
            },
            {
              "title": "@AfterThrowing",
              "multi-content": [
                {
                  "title": "description",
                  "simple-content": "S'exécute si le point de jointure lance une exception"
                },
                {
                  "title": "cas_d_utilisation",
                  "simple-content": "Gestion des exceptions, alertes"
                }
              ]
            },
            {
              "title": "@Around",
              "multi-content": [
                {
                  "title": "description",
                  "simple-content": "Entoure l'exécution du point de jointure"
                },
                {
                  "title": "cas_d_utilisation",
                  "simple-content": "Gestion des transactions, chronométrage des méthodes"
                },
                {
                  "title": "exemple",
                  "simple-content": "@Around(\"execution(* com.example.service.*.*(..))\")\npublic Object logAround(ProceedingJoinPoint joinPoint) throws Throwable {\n    long start = System.currentTimeMillis();\n    \n    Object result = joinPoint.proceed();\n    \n    long end = System.currentTimeMillis();\n    System.out.println(\"Time taken: \" + (end - start) + \"ms\");\n    \n    return result;\n}"
                }
              ]
            }
          ]
        },
        {
          "title": "expressions_de_pointcut",
          "multi-content": [
            {
              "title": "code_examples",
              "multi-content": [
                {
                  "title": "Toutes les méthodes dans le package service",
                  "simple-content": "execution(* com.example.service.*.*(..))"
                },
                {
                  "title": "Toutes les méthodes dans l'interface UserService",
                  "simple-content": "execution(* com.example.service.UserService+.*(..))"
                },
                {
                  "title": "Toutes les méthodes annotées avec @Transactional",
                  "simple-content": "@annotation(org.springframework.transaction.annotation.Transactional)"
                },
                {
                  "title": "Toutes les méthodes publiques",
                  "simple-content": "execution(public * *(..))"
                }
              ]
            }
          ]
        },
        {
          "title": "code_examples",
          "multi-content": [
            {
              "title": "",
              "simple-content": "@Aspect\n@Component\npublic class LoggingAspect {\n    \n    // Define pointcut\n    @Pointcut(\"execution(* com.example.service.*.*(..))\")\n    public void serviceMethods() {}\n    \n    // Before advice\n    @Before(\"serviceMethods()\")\n    public void logBefore(JoinPoint joinPoint) {\n        System.out.println(\"Before executing: \" + joinPoint.getSignature().getName());\n    }\n    \n    // Around advice\n    @Around(\"@annotation(com.example.annotation.LogExecutionTime)\")\n    public Object logExecutionTime(ProceedingJoinPoint joinPoint) throws Throwable {\n        long start = System.currentTimeMillis();\n        \n        Object result = joinPoint.proceed();\n        \n        long end = System.currentTimeMillis();\n        System.out.println(\"Time taken: \" + (end - start) + \"ms\");\n        \n        return result;\n    }\n}"
            }
          ]
        }
      ]
    },
    {
      "title": "Contexte d'Application",
      "multi-content": [
        {
          "title": "description",
          "simple-content": "Un conteneur IoC avancé qui fournit des fonctionnalités de niveau entreprise au-delà de la gestion de base des beans."
        },
        {
          "title": "définition",
          "simple-content": "Une interface centrale qui fournit la configuration pour une application, représentant le conteneur IoC Spring et responsable de l'instanciation, la configuration et l'assemblage des beans."
        },
        {
          "title": "fonctionnalités_clés",
          "multi-content": [
            "Étend BeanFactory avec des fonctionnalités d'entreprise",
            "Fournit un mécanisme de publication d'événements",
            "Prend en charge l'internationalisation (i18n)",
            "Capacités de chargement de ressources",
            "Intégration avec AOP",
            "Initialisation avide des beans"
          ]
        },
        {
          "title": "types_de_contexte",
          "multi-content": [
            {
              "title": "AnnotationConfigApplicationContext",
              "simple-content": "Pour la configuration basée sur Java"
            },
            {
              "title": "ClassPathXmlApplicationContext",
              "simple-content": "Pour la configuration XML chargée depuis le classpath"
            },
            {
              "title": "FileSystemXmlApplicationContext",
              "simple-content": "Pour la configuration XML chargée depuis le système de fichiers"
            },
            {
              "title": "WebApplicationContext",
              "simple-content": "Pour les applications web"
            }
          ]
        },
        {
          "title": "vs_beanfactory",
          "multi-content": [
            {
              "title": "Instanciation de Bean",
              "multi-content": [
                {
                  "title": "beanFactory",
                  "simple-content": "Paresseuse (sur demande)"
                },
                {
                  "title": "applicationContext",
                  "simple-content": "Avide (au démarrage)"
                }
              ]
            },
            {
              "title": "Publication d'Événements",
              "multi-content": [
                {
                  "title": "beanFactory",
                  "simple-content": "Non pris en charge"
                },
                {
                  "title": "applicationContext",
                  "simple-content": "Pris en charge"
                }
              ]
            },
            {
              "title": "Accès aux Ressources",
              "multi-content": [
                {
                  "title": "beanFactory",
                  "simple-content": "Limité"
                },
                {
                  "title": "applicationContext",
                  "simple-content": "Amélioré"
                }
              ]
            }
          ]
        },
        {
          "title": "code_examples",
          "multi-content": [
            {
              "title": "creating_context",
              "simple-content": "// From Java configuration\nApplicationContext context = new AnnotationConfigApplicationContext(AppConfig.class);\n\n// From XML\nApplicationContext context = new ClassPathXmlApplicationContext(\"applicationContext.xml\");"
            },
            {
              "title": "getting_beans",
              "simple-content": "// By type\nUserService userService = context.getBean(UserService.class);\n\n// By name\nUserRepository userRepository = (UserRepository) context.getBean(\"userRepository\");\n\n// By name and type\nDataSource dataSource = context.getBean(\"primaryDataSource\", DataSource.class);"
            }
          ]
        }
      ]
    },
    {
      "title": "Spring Boot vs Framework",
      "multi-content": [
        {
          "title": "description",
          "simple-content": "Comprendre les différences entre Spring Boot et le Framework Spring de base aide à clarifier leur relation et leurs cas d'utilisation."
        },
        {
          "title": "définition",
          "simple-content": "Spring Boot est un framework dogmatique construit sur Spring qui simplifie le développement d'applications en fournissant l'auto-configuration, des dépendances de démarrage et des serveurs embarqués, réduisant considérablement la configuration standard."
        },
        {
          "title": "différences_clés",
          "multi-content": [
            {
              "title": "Configuration",
              "multi-content": [
                {
                  "title": "spring_framework",
                  "simple-content": "Configuration explicite et manuelle requise"
                },
                {
                  "title": "spring_boot",
                  "simple-content": "Auto-configuration avec des valeurs par défaut sensées"
                }
              ]
            },
            {
              "title": "Installation",
              "multi-content": [
                {
                  "title": "spring_framework",
                  "simple-content": "Plus de code standard, plusieurs fichiers de configuration"
                },
                {
                  "title": "spring_boot",
                  "simple-content": "Code d'installation minimal, convention plutôt que configuration"
                }
              ]
            },
            {
              "title": "Déploiement",
              "multi-content": [
                {
                  "title": "spring_framework",
                  "simple-content": "Déploiement WAR traditionnel ou application autonome"
                },
                {
                  "title": "spring_boot",
                  "simple-content": "Serveur embarqué, JAR autonome avec tout inclus"
                }
              ]
            },
            {
              "title": "Dépendances",
              "multi-content": [
                {
                  "title": "spring_framework",
                  "simple-content": "Gestion manuelle des dépendances et coordination des versions"
                },
                {
                  "title": "spring_boot",
                  "simple-content": "Dépendances de démarrage avec des ensembles de versions compatibles et testées"
                }
              ]
            }
          ]
        },
        {
          "title": "fonctionnalités_spring_boot",
          "multi-content": [
            {
              "title": "Auto-configuration",
              "simple-content": "Configure automatiquement les beans en fonction des dépendances du classpath"
            },
            {
              "title": "Dépendances de Démarrage",
              "simple-content": "Ensembles sélectionnés de dépendances pour les cas d'utilisation courants"
            },
            {
              "title": "Serveurs Embarqués",
              "simple-content": "Serveurs d'applications intégrés pour un déploiement simple"
            },
            {
              "title": "Actuator",
              "simple-content": "Fonctionnalités prêtes pour la production pour surveiller et gérer les applications"
            }
          ]
        },
        {
          "title": "code_examples",
          "multi-content": [
            {
              "title": "spring_framework_config",
              "simple-content": "// Spring Framework - explicit ViewResolver configuration\n@Configuration\npublic class WebConfig implements WebMvcConfigurer {\n    @Bean\n    public ViewResolver viewResolver() {\n        InternalResourceViewResolver resolver = new InternalResourceViewResolver();\n        resolver.setPrefix(\"/WEB-INF/views/\");\n        resolver.setSuffix(\".jsp\");\n        return resolver;\n    }\n    // Many more beans...\n}"
            },
            {
              "title": "spring_boot_config",
              "simple-content": "// Spring Boot - auto-configuration handles it\n@SpringBootApplication\npublic class Application {\n    public static void main(String[] args) {\n        SpringApplication.run(Application.class, args);\n    }\n    // That's it! Configuration via application.properties\n}"
            }
          ]
        }
      ]
    },
    {
      "title": "Exceptions Spring",
      "multi-content": [
        {
          "title": "description",
          "simple-content": "Comprendre les exceptions Spring courantes et comment les résoudre efficacement."
        },
        {
          "title": "exceptions_clés",
          "multi-content": [
            {
              "title": "NoSuchBeanDefinitionException",
              "multi-content": [
                {
                  "title": "description",
                  "simple-content": "Se produit lorsque Spring ne trouve pas de bean du type ou du nom demandé"
                },
                {
                  "title": "causes",
                  "multi-content": [
                    "Configuration de scan de composants manquante",
                    "Bean non correctement défini",
                    "Bean en dehors des packages scannés",
                    "Qualifier ou nom incorrect spécifié",
                    "Bean non actif sous le profil actuel"
                  ]
                },
                {
                  "title": "résolution",
                  "multi-content": [
                    "Vérifier la configuration de scan des composants",
                    "S'assurer que le bean est correctement annoté ou défini",
                    "Vérifier la structure des packages",
                    "Vérifier la configuration du profil"
                  ]
                }
              ]
            },
            {
              "title": "UnsatisfiedDependencyException",
              "multi-content": [
                {
                  "title": "description",
                  "simple-content": "Se produit lorsque les dépendances d'un bean ne peuvent pas être résolues"
                },
                {
                  "title": "causes",
                  "multi-content": [
                    "Bean de dépendance manquant",
                    "Dépendances ambiguës sans désambiguïsation appropriée",
                    "Dépendances circulaires avec injection par constructeur",
                    "Incompatibilité de type dans la dépendance"
                  ]
                },
                {
                  "title": "résolution",
                  "multi-content": [
                    "S'assurer que toutes les dépendances sont disponibles",
                    "Utiliser @Qualifier ou @Primary pour la désambiguïsation",
                    "Vérifier les dépendances circulaires",
                    "Vérifier la compatibilité des types"
                  ]
                }
              ]
            },
            {
              "title": "BeanCreationException",
              "multi-content": [
                {
                  "title": "description",
                  "simple-content": "Se produit pendant le processus d'instanciation du bean"
                },
                {
                  "title": "causes",
                  "multi-content": [
                    "Exception dans le constructeur du bean",
                    "Exception dans la méthode @PostConstruct",
                    "Erreur d'initialisation du bean",
                    "Dépendances circulaires"
                  ]
                },
                {
                  "title": "résolution",
                  "multi-content": [
                    "Vérifier les exceptions dans l'initialisation du bean",
                    "Déboguer les méthodes d'initialisation",
                    "Rechercher les dépendances circulaires",
                    "Examiner les exceptions imbriquées"
                  ]
                }
              ]
            },
            {
              "title": "BeanCurrentlyInCreationException",
              "multi-content": [
                {
                  "title": "description",
                  "simple-content": "Se produit avec des dépendances circulaires"
                },
                {
                  "title": "causes",
                  "multi-content": [
                    "Dépendances circulaires avec injection par constructeur"
                  ]
                },
                {
                  "title": "résolution",
                  "multi-content": [
                    "Reconcevoir les composants pour éliminer la dépendance circulaire",
                    "Utiliser l'injection par setter au lieu de l'injection par constructeur",
                    "Utiliser l'annotation @Lazy sur l'une des dépendances"
                  ]
                }
              ]
            }
          ]
        },
        {
          "title": "approches_de_dépannage",
          "multi-content": [
            {
              "title": "Lire la Trace de la Pile",
              "simple-content": "Examiner attentivement le message d'exception et la trace de la pile"
            },
            {
              "title": "Activer la Journalisation de Débogage",
              "simple-content": "Augmenter le niveau de journalisation pour obtenir plus d'informations"
            },
            {
              "title": "Utiliser les Événements de ApplicationContext",
              "simple-content": "Écouter les événements de contexte pour identifier les problèmes"
            },
            {
              "title": "Inspecter les Définitions de Bean",
              "simple-content": "Inspecter programmatiquement les définitions de bean"
            }
          ]
        }
      ]
    }
  ]
}