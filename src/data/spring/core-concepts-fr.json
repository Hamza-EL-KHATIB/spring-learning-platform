{
  "id": "spring-core-concepts",
  "title": "Concepts Fondamentaux de Spring",
  "topics": [
    {
      "title": "IoC",
      "multi-content": [
        {
          "title": "description",
          "simple-content": "L'Inversion de Contrôle (IoC) est un principe de conception où le contrôle de la création d'objets et du cycle de vie est transféré du code de l'application à un conteneur ou framework externe."
        },
        {
          "title": "definition",
          "simple-content": "Un principe de conception où le contrôle de la création d'objets et de la gestion des dépendances est délégué à un conteneur externe, améliorant la modularité et la testabilité."
        },
        {
          "title": "benefits",
          "multi-content": [
            "Découple la création de composants de leur utilisation",
            "Favorise une conception modulaire et la testabilité",
            "Permet une architecture d'application flexible",
            "Constitue la base pour l'injection de dépendances",
            "Couplage faible entre les composants",
            "Meilleure testabilité grâce à une simulation plus facile"
          ]
        },
        {
          "title": "code_examples",
          "multi-content": [
            {
              "title": "without_ioc",
              "simple-content": "public class UserService {\n    private UserRepository userRepository = new UserRepositoryImpl();\n}"
            },
            {
              "title": "with_ioc",
              "simple-content": "public class UserService {\n    private UserRepository userRepository;\n    \n    // Container injects the dependency\n    public UserService(UserRepository userRepository) {\n        this.userRepository = userRepository;\n    }\n}"
            }
          ]
        }
      ]
    },
    {
      "title": "Injection de Dépendances",
      "multi-content": [
        {
          "title": "description",
          "simple-content": "Un modèle spécifique de mise en œuvre de l'IoC où les dépendances d'objets sont fournies par une source externe plutôt que créées en interne."
        },
        {
          "title": "definition",
          "simple-content": "Un modèle dans lequel les dépendances d'un objet sont fournies par une source externe (généralement le conteneur IoC) plutôt que l'objet les instanciant lui-même, favorisant ainsi un couplage faible."
        },
        {
          "title": "types",
          "multi-content": [
            {
              "title": "Injection par Constructeur",
              "multi-content": [
                {
                  "title": "description",
                  "simple-content": "Dépendances fournies via le constructeur"
                },
                {
                  "title": "best_for",
                  "simple-content": "Dépendances requises, objets immuables"
                },
                {
                  "title": "example",
                  "simple-content": "public Service(Dependency d) {...}"
                },
                {
                  "title": "advantages",
                  "multi-content": [
                    "Garantit que les dépendances requises sont fournies",
                    "Favorise l'immuabilité (les dépendances peuvent être final)",
                    "Rend les dépendances explicites et visibles à la construction",
                    "Plus facile à tester et à simuler",
                    "Fonctionne sans conteneur DI",
                    "Détecte les dépendances circulaires à la compilation"
                  ]
                }
              ]
            },
            {
              "title": "Injection par Setter",
              "multi-content": [
                {
                  "title": "description",
                  "simple-content": "Dépendances fournies via des méthodes setter"
                },
                {
                  "title": "best_for",
                  "simple-content": "Dépendances optionnelles, objets reconfigurables"
                },
                {
                  "title": "example",
                  "simple-content": "public void setDependency(Dependency d) {...}"
                },
                {
                  "title": "advantages",
                  "multi-content": [
                    "Permet des dépendances optionnelles",
                    "Offre de la flexibilité dans la gestion des dépendances",
                    "Prend en charge la modification des dépendances à l'exécution"
                  ]
                }
              ]
            },
            {
              "title": "Injection par Champ",
              "multi-content": [
                {
                  "title": "description",
                  "simple-content": "Dépendances injectées directement dans les champs"
                },
                {
                  "title": "best_for",
                  "simple-content": "Cas simples (généralement déconseillé)"
                },
                {
                  "title": "example",
                  "simple-content": "@Autowired private Dependency d;"
                },
                {
                  "title": "advantages",
                  "multi-content": [
                    "Moins de code standard",
                    "Plus simple à écrire"
                  ]
                },
                {
                  "title": "disadvantages",
                  "multi-content": [
                    "Plus difficile à tester",
                    "Impossible de déclarer les champs comme final",
                    "Dépendances cachées"
                  ]
                }
              ]
            }
          ]
        },
        {
          "title": "code_examples",
          "multi-content": [
            {
              "title": "constructor_injection",
              "simple-content": "@Service\npublic class UserService {\n    private final UserRepository userRepository;\n    \n    @Autowired // Optional in Spring 4.3+ with single constructor\n    public UserService(UserRepository userRepository) {\n        this.userRepository = userRepository;\n    }\n}"
            },
            {
              "title": "setter_injection",
              "simple-content": "@Service\npublic class UserService {\n    private UserRepository userRepository;\n    \n    @Autowired\n    public void setUserRepository(UserRepository userRepository) {\n        this.userRepository = userRepository;\n    }\n}"
            },
            {
              "title": "field_injection",
              "simple-content": "@Service\npublic class UserService {\n    @Autowired\n    private UserRepository userRepository;\n}"
            }
          ]
        }
      ]
    },
    {
      "title": "IoC vs DI vs Conteneur IoC Spring",
      "multi-content": [
        {
          "title": "description",
          "simple-content": "Comprendre les différences entre l'Inversion de Contrôle (IoC) en tant que principe de conception, l'Injection de Dépendances (DI) en tant que modèle de conception, et le Conteneur IoC Spring en tant qu'implémentation spécifique."
        },
        {
          "title": "fundamental_definitions",
          "multi-content": [
            {
              "title": "Inversion de Contrôle (IoC)",
              "multi-content": [
                {
                  "title": "definition",
                  "simple-content": "L'IoC est un principe de conception large où le contrôle de la création d'objets, du cycle de vie des objets et des dépendances des objets est transféré à un conteneur ou à un framework. L'idée principale est d'inverser le flux traditionnel de contrôle : dans l'approche traditionnelle, votre code appelle une bibliothèque au besoin ; dans l'approche IoC, le framework appelle votre code au moment approprié."
                },
                {
                  "title": "purpose",
                  "simple-content": "Découpler l'exécution de l'implémentation"
                },
                {
                  "title": "level",
                  "simple-content": "Principe de conception"
                }
              ]
            },
            {
              "title": "Injection de Dépendances (DI)",
              "multi-content": [
                {
                  "title": "definition",
                  "simple-content": "Le DI est un modèle spécifique pour implémenter l'IoC où les dépendances sont 'injectées' dans les objets plutôt que d'avoir des objets qui les créent ou les trouvent eux-mêmes."
                },
                {
                  "title": "purpose",
                  "simple-content": "Découpler la création des composants de leur utilisation"
                },
                {
                  "title": "level",
                  "simple-content": "Modèle de conception"
                }
              ]
            },
            {
              "title": "Conteneur IoC Spring",
              "multi-content": [
                {
                  "title": "definition",
                  "simple-content": "L'implémentation spécifique dans Spring qui gère les beans et injecte les dépendances"
                },
                {
                  "title": "purpose",
                  "simple-content": "Automatiser l'injection de dépendances et gérer le cycle de vie"
                },
                {
                  "title": "level",
                  "simple-content": "Implémentation"
                }
              ]
            }
          ]
        },
        {
          "title": "code_examples",
          "multi-content": [
            {
              "title": "without_ioc",
              "simple-content": "public class UserService {\n    // UserService directly creates its dependency\n    private UserRepository userRepository = new UserRepositoryImpl();\n    \n    public User getUser(Long id) {\n        return userRepository.findById(id);\n    }\n}"
            },
            {
              "title": "with_di",
              "simple-content": "public class UserService {\n    // UserRepository is injected, not created\n    private final UserRepository userRepository;\n    \n    // Constructor injection\n    public UserService(UserRepository userRepository) {\n        this.userRepository = userRepository;\n    }\n    \n    public User getUser(Long id) {\n        return userRepository.findById(id);\n    }\n}"
            }
          ]
        },
        {
          "title": "di_types",
          "multi-content": [
            {
              "title": "Injection par Constructeur",
              "multi-content": [
                {
                  "title": "description",
                  "simple-content": "Les dépendances sont fournies via le constructeur (méthode préférée)"
                },
                {
                  "title": "example",
                  "simple-content": "public UserService(UserRepository userRepository) {\n    this.userRepository = userRepository;\n}"
                }
              ]
            },
            {
              "title": "Injection par Setter",
              "multi-content": [
                {
                  "title": "description",
                  "simple-content": "Les dépendances sont fournies via des méthodes setter"
                },
                {
                  "title": "example",
                  "simple-content": "@Autowired\npublic void setUserRepository(UserRepository userRepository) {\n    this.userRepository = userRepository;\n}"
                }
              ]
            },
            {
              "title": "Injection par Champ",
              "multi-content": [
                {
                  "title": "description",
                  "simple-content": "Les dépendances sont injectées directement dans les champs (non recommandé)"
                },
                {
                  "title": "example",
                  "simple-content": "@Autowired\nprivate UserRepository userRepository;"
                }
              ]
            }
          ]
        },
        {
          "title": "spring_ioc_container",
          "multi-content": [
            {
              "title": "description",
              "simple-content": "Le Conteneur IoC Spring est l'implémentation concrète de l'IoC dans Spring, composé de BeanFactory (interface de base fournissant les fonctionnalités IoC de base) et ApplicationContext (conteneur amélioré avec des fonctionnalités d'entreprise, étendant BeanFactory)."
            },
            {
              "title": "example",
              "simple-content": "// Spring IoC Container in action\nApplicationContext context = new ClassPathXmlApplicationContext(\"beans.xml\");\n// or\nApplicationContext context = new AnnotationConfigApplicationContext(AppConfig.class);\n\n// Retrieve a bean from the container\nUserService userService = context.getBean(UserService.class);"
            }
          ]
        }
      ]
    },
    {
      "title": "Cycle de Vie des Beans",
      "multi-content": [
        {
          "title": "description",
          "simple-content": "Le cycle de vie d'un bean Spring dans une application Spring Boot suit une séquence spécifique de l'initialisation à la destruction, avec des opportunités de personnalisation à chaque étape."
        },
        {
          "title": "definition",
          "simple-content": "Le processus complet qu'un bean Spring subit — de l'instanciation et l'injection de dépendances à l'initialisation et la destruction éventuelle — avec des possibilités de comportement personnalisé à différentes étapes."
        },
        {
          "title": "boot_specific_considerations",
          "simple-content": "Spring Boot suit le même cycle de vie des beans que le framework Spring, mais ajoute l'auto-configuration, qui influence la façon dont les beans sont créés et initialisés. Boot initialise également les beans dans un ordre spécifique pour garantir que les dépendances sont correctement satisfaites."
        },
        {
          "title": "lifecycle_phases",
          "multi-content": [
            {
              "title": "Définition du Bean",
              "multi-content": [
                {
                  "title": "description",
                  "simple-content": "Spring lit la configuration et crée des objets BeanDefinition"
                },
                {
                  "title": "events",
                  "multi-content": [
                    "Les métadonnées de configuration sont chargées (annotations, XML, configuration Java)",
                    "Les objets BeanDefinition sont créés et enregistrés auprès du conteneur",
                    "Dans Spring Boot, les classes d'auto-configuration contribuent à des définitions de beans supplémentaires"
                  ]
                }
              ]
            },
            {
              "title": "Instanciation du Bean",
              "multi-content": [
                {
                  "title": "description",
                  "simple-content": "Spring crée l'instance du bean"
                },
                {
                  "title": "events",
                  "multi-content": [
                    "Le constructeur est invoqué",
                    "La méthode factory est appelée (si configurée)"
                  ]
                }
              ]
            },
            {
              "title": "Remplissage des Propriétés",
              "multi-content": [
                {
                  "title": "description",
                  "simple-content": "Les dépendances sont injectées"
                },
                {
                  "title": "events",
                  "multi-content": [
                    "Les propriétés sont définies",
                    "Les dépendances sont résolues et injectées",
                    "Dans Spring Boot, les propriétés de application.properties/yml sont liées"
                  ]
                }
              ]
            },
            {
              "title": "Initialisation",
              "multi-content": [
                {
                  "title": "description",
                  "simple-content": "Le bean est initialisé via des callbacks"
                },
                {
                  "title": "events",
                  "multi-content": [
                    "BeanNameAware.setBeanName() est appelé",
                    "BeanFactoryAware.setBeanFactory() est appelé",
                    "ApplicationContextAware.setApplicationContext() est appelé",
                    "Les méthodes BeanPostProcessor.postProcessBeforeInitialization() sont appelées",
                    "Les méthodes @PostConstruct sont appelées",
                    "InitializingBean.afterPropertiesSet() est appelé",
                    "La méthode d'initialisation personnalisée (init-method) est appelée",
                    "Les méthodes BeanPostProcessor.postProcessAfterInitialization() sont appelées"
                  ]
                }
              ]
            },
            {
              "title": "Utilisation du Bean",
              "multi-content": [
                {
                  "title": "description",
                  "simple-content": "Le bean est prêt à être utilisé par l'application"
                },
                {
                  "title": "boot_feature",
                  "simple-content": "Spring Boot complète l'initialisation de tous les beans avant que l'application ne soit considérée comme prête"
                }
              ]
            },
            {
              "title": "Destruction",
              "multi-content": [
                {
                  "title": "description",
                  "simple-content": "Le bean est détruit lorsque le contexte est fermé"
                },
                {
                  "title": "events",
                  "multi-content": [
                    "Les méthodes @PreDestroy sont appelées",
                    "DisposableBean.destroy() est appelé",
                    "La méthode de destruction personnalisée (destroy-method) est appelée"
                  ]
                }
              ]
            }
          ]
        },
        {
          "title": "boot_specific_examples",
          "multi-content": [
            {
              "title": "using_application_events",
              "simple-content": "@Component\npublic class BootLifecycleBean {\n    private final Logger logger = LoggerFactory.getLogger(BootLifecycleBean.class);\n    \n    @EventListener(ApplicationReadyEvent.class)\n    public void onApplicationReady() {\n        logger.info(\"Application is fully started and ready to accept requests\");\n        // Do post-startup initialization\n    }\n    \n    @EventListener(ApplicationFailedEvent.class)\n    public void onApplicationFailed() {\n        logger.error(\"Application failed to start\");\n        // Perform cleanup or notification\n    }\n}"
            },
            {
              "title": "using_commandlinerunner",
              "simple-content": "@Component\npublic class StartupTaskRunner implements CommandLineRunner {\n    private final UserService userService;\n    \n    public StartupTaskRunner(UserService userService) {\n        this.userService = userService;\n    }\n    \n    @Override\n    public void run(String... args) throws Exception {\n        // Executed after the application context is loaded but before\n        // the application is fully started\n        System.out.println(\"Running startup tasks...\");\n        userService.performStartupChecks();\n    }\n}"
            }
          ]
        }
      ]
    },
    {
      "title": "Portées des Beans",
      "multi-content": [
        {
          "title": "description",
          "simple-content": "Les portées des beans définissent le cycle de vie d'un bean, sa visibilité et le nombre d'instances créées dans une application Spring Boot."
        },
        {
          "title": "definition",
          "simple-content": "Définit le cycle de vie et la visibilité d'un bean au sein du conteneur. Chaque portée détermine quand une nouvelle instance est créée et combien de temps elle vit."
        },
        {
          "title": "scope_types",
          "multi-content": [
            {
              "title": "singleton",
              "multi-content": [
                {
                  "title": "description",
                  "simple-content": "Portée par défaut ; une instance par conteneur Spring"
                },
                {
                  "title": "instances",
                  "simple-content": "Unique"
                },
                {
                  "title": "lifecycle",
                  "simple-content": "Cycle de vie du conteneur"
                },
                {
                  "title": "best_for",
                  "simple-content": "Services sans état et repositories"
                },
                {
                  "title": "boot_usage",
                  "simple-content": "Dans Spring Boot, la plupart des beans auto-configurés sont de portée singleton par défaut"
                }
              ]
            },
            {
              "title": "prototype",
              "multi-content": [
                {
                  "title": "description",
                  "simple-content": "Nouvelle instance de bean pour chaque demande/injection"
                },
                {
                  "title": "instances",
                  "simple-content": "Multiple"
                },
                {
                  "title": "lifecycle",
                  "simple-content": "De la création jusqu'à ce qu'il ne soit plus référencé"
                },
                {
                  "title": "best_for",
                  "simple-content": "Objets avec état comme les formulaires ou les paniers d'achat"
                }
              ]
            },
            {
              "title": "request",
              "multi-content": [
                {
                  "title": "description",
                  "simple-content": "Une instance par requête HTTP (web-aware)"
                },
                {
                  "title": "instances",
                  "simple-content": "Multiple"
                },
                {
                  "title": "lifecycle",
                  "simple-content": "Requête HTTP"
                },
                {
                  "title": "best_for",
                  "simple-content": "Données spécifiques à la requête HTTP"
                },
                {
                  "title": "boot_usage",
                  "simple-content": "Disponible automatiquement dans les applications web Spring Boot"
                }
              ]
            },
            {
              "title": "session",
              "multi-content": [
                {
                  "title": "description",
                  "simple-content": "Une instance par session HTTP (web-aware)"
                },
                {
                  "title": "instances",
                  "simple-content": "Multiple"
                },
                {
                  "title": "lifecycle",
                  "simple-content": "Session HTTP"
                },
                {
                  "title": "best_for",
                  "simple-content": "Données spécifiques à l'utilisateur dans les applications web"
                }
              ]
            },
            {
              "title": "application",
              "multi-content": [
                {
                  "title": "description",
                  "simple-content": "Une instance par ServletContext (web-aware)"
                },
                {
                  "title": "instances",
                  "simple-content": "Unique"
                },
                {
                  "title": "lifecycle",
                  "simple-content": "Cycle de vie du ServletContext"
                },
                {
                  "title": "best_for",
                  "simple-content": "Beans à l'échelle de l'application"
                }
              ]
            },
            {
              "title": "websocket",
              "multi-content": [
                {
                  "title": "description",
                  "simple-content": "Une instance par WebSocket (web-aware)"
                },
                {
                  "title": "instances",
                  "simple-content": "Multiple"
                },
                {
                  "title": "lifecycle",
                  "simple-content": "Cycle de vie WebSocket"
                },
                {
                  "title": "best_for",
                  "simple-content": "Beans spécifiques à WebSocket"
                }
              ]
            }
          ]
        },
        {
          "title": "code_examples",
          "multi-content": [
            {
              "title": "singleton_scope",
              "simple-content": "@Component\n@Scope(\"singleton\") // or simply @Component since singleton is default\npublic class UserService { /* ... */ }"
            },
            {
              "title": "prototype_scope",
              "simple-content": "@Component\n@Scope(\"prototype\")\npublic class ShoppingCart { /* ... */ }"
            },
            {
              "title": "request_scope",
              "simple-content": "@Component\n@RequestScope // or @Scope(value = \"request\", proxyMode = ScopedProxyMode.TARGET_CLASS)\npublic class RequestScopedBean { /* ... */ }"
            },
            {
              "title": "mixing_scopes",
              "simple-content": "// Problem: Injecting prototype into singleton\n@Component\npublic class SingletonBean {\n    @Autowired\n    private PrototypeBean prototypeBean; // Will always be the same instance!\n}\n\n// Solution 1: Scoped Proxy\n@Component\n@Scope(value = \"prototype\", proxyMode = ScopedProxyMode.TARGET_CLASS)\npublic class PrototypeBean { /* ... */ }\n\n// Solution 2: ObjectFactory\n@Component\npublic class SingletonBean {\n    @Autowired\n    private ObjectFactory<PrototypeBean> prototypeBeanFactory;\n    \n    public void doSomething() {\n        PrototypeBean prototypeBean = prototypeBeanFactory.getObject(); // New instance\n        // Use prototypeBean\n    }\n}"
            }
          ]
        },
        {
          "title": "boot_specific_features",
          "multi-content": [
            "Spring Boot configure automatiquement l'infrastructure nécessaire pour les portées web-aware",
            "Les annotations @RequestScope, @SessionScope et @ApplicationScope simplifient la configuration des portées",
            "Le module DevTools de Spring Boot gère correctement l'actualisation des beans à travers différentes portées pendant le développement"
          ]
        }
      ]
    },
    {
      "title": "Configuration Spring",
      "multi-content": [
        {
          "title": "description",
          "simple-content": "Différentes approches pour configurer les beans et connecter les dépendances dans les applications Spring."
        },
        {
          "title": "definition",
          "simple-content": "Le processus de définition des beans, de leurs dépendances et d'autres paramètres d'application à gérer par le conteneur Spring."
        },
        {
          "title": "configuration_types",
          "multi-content": [
            {
              "title": "Configuration Java",
              "multi-content": [
                {
                  "title": "description",
                  "simple-content": "Utilisation des annotations @Configuration et @Bean dans les classes Java"
                },
                {
                  "title": "best_for",
                  "simple-content": "Sécurité de type, facilité de refactoring, support IDE"
                },
                {
                  "title": "advantages",
                  "multi-content": [
                    "Sécurité de type",
                    "Vérifications à la compilation",
                    "Meilleur support de refactoring",
                    "Autocomplétion IDE",
                    "Configuration programmatique"
                  ]
                },
                {
                  "title": "example",
                  "simple-content": "@Configuration\npublic class AppConfig {\n    \n    @Bean\n    public UserRepository userRepository() {\n        return new JpaUserRepository();\n    }\n    \n    @Bean\n    public UserService userService(UserRepository userRepository) {\n        return new UserServiceImpl(userRepository);\n    }\n}"
                }
              ]
            },
            {
              "title": "Basée sur les Annotations",
              "multi-content": [
                {
                  "title": "description",
                  "simple-content": "Utilisation du scan de composants avec @Component, @Service, etc."
                },
                {
                  "title": "best_for",
                  "simple-content": "Simplicité, réduction du code standard, convention plutôt que configuration"
                },
                {
                  "title": "advantages",
                  "multi-content": [
                    "Moins de code de configuration",
                    "Configuration plus proche de l'implémentation",
                    "Détection automatique des composants",
                    "Code propre et lisible"
                  ]
                },
                {
                  "title": "example",
                  "simple-content": "@Configuration\n@ComponentScan(basePackages = \"com.example\")\npublic class AppConfig {\n    // Configuration for component scanning\n}\n\n@Component\npublic class SimpleComponent { /* ... */ }\n\n@Repository\npublic class JpaUserRepository implements UserRepository { /* ... */ }\n\n@Service\npublic class UserServiceImpl implements UserService {\n    @Autowired\n    private UserRepository userRepository;\n    // Implementation\n}"
                }
              ]
            },
            {
              "title": "Configuration XML",
              "multi-content": [
                {
                  "title": "description",
                  "simple-content": "Utilisation de fichiers XML avec des définitions <bean>"
                },
                {
                  "title": "best_for",
                  "simple-content": "Configuration externe, systèmes hérités"
                },
                {
                  "title": "advantages",
                  "multi-content": [
                    "Pas besoin de recompilation pour les changements de configuration",
                    "Séparation complète du code",
                    "Support Spring hérité",
                    "Câblage explicite des dépendances"
                  ]
                },
                {
                  "title": "example",
                  "simple-content": "<!-- applicationContext.xml -->\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n                           http://www.springframework.org/schema/beans/spring-beans.xsd\">\n\n    <bean id=\"userRepository\" class=\"com.example.JpaUserRepository\" />\n    \n    <bean id=\"userService\" class=\"com.example.UserServiceImpl\">\n        <constructor-arg ref=\"userRepository\" />\n    </bean>\n</beans>"
                }
              ]
            }
          ]
        },
        {
          "title": "common_annotations",
          "multi-content": [
            {
              "title": "@Configuration",
              "simple-content": "Indique qu'une classe définit des méthodes bean"
            },
            {
              "title": "@Bean",
              "simple-content": "Marque une méthode comme produisant un bean Spring"
            },
            {
              "title": "@Component",
              "simple-content": "Stéréotype générique pour les composants gérés par Spring"
            },
            {
              "title": "@Repository",
              "simple-content": "Stéréotype pour les composants de la couche de persistance"
            },
            {
              "title": "@Service",
              "simple-content": "Stéréotype pour les composants de la couche de service"
            },
            {
              "title": "@Controller",
              "simple-content": "Stéréotype pour les composants de la couche de présentation"
            },
            {
              "title": "@Autowired",
              "simple-content": "Marque un point d'injection de dépendance"
            },
            {
              "title": "@Qualifier",
              "simple-content": "Désambiguïse quel bean injecter"
            },
            {
              "title": "@Value",
              "simple-content": "Injecte des valeurs à partir de propriétés ou d'expressions"
            },
            {
              "title": "@Profile",
              "simple-content": "Active des beans pour des environnements spécifiques"
            }
          ]
        }
      ]
    },
    {
      "title": "Scan de Composants",
      "multi-content": [
        {
          "title": "description",
          "simple-content": "Le processus par lequel Spring identifie et enregistre automatiquement les beans à partir de packages spécifiés."
        },
        {
          "title": "definition",
          "simple-content": "Un mécanisme qui permet à Spring de détecter et d'enregistrer automatiquement les beans Spring en scannant des packages de base spécifiques pour les classes avec des annotations stéréotypes."
        },
        {
          "title": "key_concepts",
          "multi-content": [
            {
              "title": "base_packages",
              "simple-content": "Les points de départ pour le scan de composants, généralement le package racine de votre application"
            },
            {
              "title": "stereotype_annotations",
              "simple-content": "Marqueurs pour les classes qui doivent être automatiquement enregistrées comme beans (@Component et ses spécialisations)"
            },
            {
              "title": "filters",
              "simple-content": "Règles pour inclure ou exclure certaines classes du scan"
            },
            {
              "title": "bean_naming",
              "simple-content": "Comment Spring nomme automatiquement les composants scannés (généralement le nom de classe en camelCase)"
            }
          ]
        },
        {
          "title": "annotations",
          "multi-content": [
            {
              "title": "@Component",
              "simple-content": "Annotation générique pour tout composant géré par Spring"
            },
            {
              "title": "@Service",
              "simple-content": "Indique que la classe appartient à la couche de service (logique métier)"
            },
            {
              "title": "@Repository",
              "simple-content": "Indique une classe de la couche de persistance avec traduction automatique des exceptions"
            },
            {
              "title": "@Controller",
              "simple-content": "Indique un composant contrôleur web"
            },
            {
              "title": "@RestController",
              "simple-content": "Combine @Controller et @ResponseBody pour les contrôleurs RESTful"
            }
          ]
        },
        {
          "title": "code_examples",
          "multi-content": [
            {
              "title": "basic_scanning",
              "simple-content": "@Configuration\n@ComponentScan(basePackages = \"com.example\")\npublic class AppConfig {\n    // Configuration\n}"
            },
            {
              "title": "multiple_packages",
              "simple-content": "@Configuration\n@ComponentScan(basePackages = {\"com.example.service\", \"com.example.repository\"})\npublic class AppConfig {\n    // Configuration\n}"
            },
            {
              "title": "using_filters",
              "simple-content": "@Configuration\n@ComponentScan(\n    basePackages = \"com.example\",\n    includeFilters = @ComponentScan.Filter(type = FilterType.REGEX, pattern = \".*Repository\"),\n    excludeFilters = @ComponentScan.Filter(type = FilterType.ANNOTATION, classes = Deprecated.class)\n)\npublic class AppConfig {\n    // Configuration\n}"
            }
          ]
        },
        {
          "title": "scan_process",
          "multi-content": [
            "Spring recherche les packages de base et les sous-packages",
            "Trouve les classes avec des annotations stéréotypes",
            "Lit les métadonnées des annotations",
            "Filtre les classes en fonction des règles d'inclusion/exclusion",
            "Enregistre les BeanDefinitions pour les classes correspondantes",
            "Nomme les beans (généralement le nom de classe avec première lettre en minuscule)",
            "Traite les annotations supplémentaires (comme @Scope, @Lazy)"
          ]
        }
      ]
    },
    {
      "title": "Résolution de Dépendances",
      "multi-content": [
        {
          "title": "description",
          "simple-content": "Comment Spring résout les dépendances et gère les scénarios avec plusieurs candidats."
        },
        {
          "title": "definition",
          "simple-content": "Le processus par lequel Spring identifie et sélectionne les beans appropriés à injecter lorsque des dépendances sont déclarées."
        },
        {
          "title": "resolution_mechanisms",
          "multi-content": [
            {
              "title": "@Qualifier",
              "multi-content": [
                {
                  "title": "description",
                  "simple-content": "Spécifie quel bean injecter lorsque plusieurs candidats existent"
                },
                {
                  "title": "example",
                  "simple-content": "@Service(\"premiumService\")\npublic class PremiumUserService implements UserService { /* ... */ }\n\n@Service(\"basicService\")\npublic class BasicUserService implements UserService { /* ... */ }\n\n@Component\npublic class UserController {\n    private final UserService userService;\n    \n    @Autowired\n    public UserController(@Qualifier(\"premiumService\") UserService userService) {\n        this.userService = userService;\n    }\n}"
                }
              ]
            },
            {
              "title": "@Primary",
              "multi-content": [
                {
                  "title": "description",
                  "simple-content": "Marque un bean comme candidat principal pour l'autowiring"
                },
                {
                  "title": "example",
                  "simple-content": "@Service\n@Primary\npublic class PrimaryUserService implements UserService { /* ... */ }\n\n@Service\npublic class SecondaryUserService implements UserService { /* ... */ }\n\n@Component\npublic class UserController {\n    private final UserService userService;\n    \n    @Autowired\n    public UserController(UserService userService) {\n        // PrimaryUserService will be injected\n        this.userService = userService;\n    }\n}"
                }
              ]
            },
            {
              "title": "Autowiring par Nom de Bean",
              "multi-content": [
                {
                  "title": "description",
                  "simple-content": "Correspondance par nom de paramètre/champ"
                },
                {
                  "title": "example",
                  "simple-content": "@Component(\"premiumService\")\npublic class PremiumUserService implements UserService { /* ... */ }\n\n@Component(\"basicService\")\npublic class BasicUserService implements UserService { /* ... */ }\n\n@Component\npublic class UserController {\n    private final UserService premiumService; // Name matches bean id\n    \n    @Autowired\n    public UserController(UserService premiumService) {\n        this.premiumService = premiumService;\n    }\n}"
                }
              ]
            }
          ]
        },
        {
          "title": "resolution_order",
          "multi-content": [
            "1. Correspondance exacte du type (si un seul bean du type requis existe)",
            "2. Correspondance par @Qualifier si spécifié",
            "3. Correspondance avec le bean @Primary si disponible",
            "4. Correspondance par nom (si le nom du paramètre/champ correspond à un nom de bean)",
            "5. Lancer une exception si aucun bean unique ne peut être déterminé"
          ]
        },
        {
          "title": "common_exceptions",
          "multi-content": [
            {
              "title": "NoSuchBeanDefinitionException",
              "simple-content": "Aucun bean qualifié trouvé"
            },
            {
              "title": "NoUniqueBeanDefinitionException",
              "simple-content": "Plusieurs beans qualifiés trouvés"
            },
            {
              "title": "BeanCreationException",
              "simple-content": "Erreur lors de la création du bean"
            }
          ]
        }
      ]
    },
    {
      "title": "Dépendances Circulaires",
      "multi-content": [
        {
          "title": "description",
          "simple-content": "Une situation où le bean A dépend du bean B, et le bean B dépend du bean A, soit directement soit indirectement."
        },
        {
          "title": "definition",
          "simple-content": "Une dépendance circulaire se produit lorsque deux beans ou plus dépendent l'un de l'autre, créant un cycle de dépendances qui peut causer des problèmes d'initialisation."
        },
        {
          "title": "dependency_types",
          "multi-content": [
            {
              "title": "Circularité d'Injection par Constructeur",
              "multi-content": [
                {
                  "title": "resolvable",
                  "simple-content": "false"
                },
                {
                  "title": "description",
                  "simple-content": "Ne peut pas être résolue par Spring"
                },
                {
                  "title": "example",
                  "simple-content": "@Component\npublic class BeanA {\n    private final BeanB beanB;\n    \n    @Autowired\n    public BeanA(BeanB beanB) {\n        this.beanB = beanB;\n    }\n}\n\n@Component\npublic class BeanB {\n    private final BeanA beanA;\n    \n    @Autowired\n    public BeanB(BeanA beanA) {\n        this.beanA = beanA;\n    }\n}"
                }
              ]
            },
            {
              "title": "Circularité d'Injection par Setter",
              "multi-content": [
                {
                  "title": "resolvable",
                  "simple-content": "true"
                },
                {
                  "title": "description",
                  "simple-content": "Peut être résolue par Spring"
                },
                {
                  "title": "example",
                  "simple-content": "@Component\npublic class BeanA {\n    private BeanB beanB;\n    \n    @Autowired\n    public void setBeanB(BeanB beanB) {\n        this.beanB = beanB;\n    }\n}\n\n@Component\npublic class BeanB {\n    private BeanA beanA;\n    \n    @Autowired\n    public void setBeanA(BeanA beanA) {\n        this.beanA = beanA;\n    }\n}"
                }
              ]
            }
          ]
        },
        {
          "title": "detection",
          "simple-content": "Spring détecte les dépendances circulaires lors du démarrage de l'application et lance BeanCurrentlyInCreationException si elles ne peuvent pas être résolues."
        },
        {
          "title": "resolution_strategies",
          "multi-content": [
            {
              "title": "Redessiner les Composants",
              "multi-content": [
                {
                  "title": "recommendation",
                  "simple-content": "Meilleure pratique"
                },
                {
                  "title": "description",
                  "simple-content": "Repenser les dépendances pour éliminer les références circulaires"
                },
                {
                  "title": "details",
                  "multi-content": [
                    "Extraire les fonctionnalités partagées vers un troisième service",
                    "Appliquer le Principe d'Inversion de Dépendance",
                    "Utiliser des événements pour la communication"
                  ]
                }
              ]
            },
            {
              "title": "Utiliser l'Injection par Setter",
              "multi-content": [
                {
                  "title": "description",
                  "simple-content": "Passer de l'injection par constructeur à l'injection par setter"
                },
                {
                  "title": "caution",
                  "simple-content": "Crée la possibilité de beans partiellement initialisés"
                }
              ]
            },
            {
              "title": "Utiliser l'Annotation @Lazy",
              "multi-content": [
                {
                  "title": "description",
                  "simple-content": "Différer un côté de la dépendance"
                },
                {
                  "title": "example",
                  "simple-content": "@Component\npublic class BeanA {\n    private final BeanB beanB;\n    \n    @Autowired\n    public BeanA(@Lazy BeanB beanB) {\n        this.beanB = beanB;\n    }\n}"
                }
              ]
            },
            {
              "title": "Utiliser des Événements",
              "multi-content": [
                {
                  "title": "description",
                  "simple-content": "Découpler la communication en utilisant le système d'événements de Spring"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "title": "AOP",
      "multi-content": [
        {
          "title": "description",
          "simple-content": "La Programmation Orientée Aspect (AOP) aborde les préoccupations transversales en les séparant de la logique métier principale, favorisant un code plus propre et plus maintenable. Dans Spring Boot, l'AOP est couramment utilisée pour la journalisation, la gestion des transactions, la sécurité et la surveillance des performances."
        },
        {
          "title": "definition",
          "simple-content": "Un paradigme de programmation qui sépare les préoccupations transversales (comme la journalisation, la sécurité ou la gestion des transactions) de la logique métier en utilisant des aspects, des conseils, des points de jonction et des pointcuts."
        },
        {
          "title": "spring_boot_implementation",
          "simple-content": "Spring Boot simplifie l'AOP en configurant automatiquement les dépendances nécessaires lorsque vous incluez spring-boot-starter-aop dans votre projet. Cela vous permet de vous concentrer sur l'écriture de vos aspects plutôt que sur les détails de configuration."
        },
        {
          "title": "code_examples",
          "multi-content": [
            {
              "title": "logging_aspect",
              "simple-content": "// Common Spring Boot logging aspect example\n@Aspect\n@Component\npublic class LoggingAspect {\n    private static final Logger log = LoggerFactory.getLogger(LoggingAspect.class);\n    \n    @Around(\"execution(* com.example.service.*.*(..))\")\n    public Object logMethodExecution(ProceedingJoinPoint joinPoint) throws Throwable {\n        String methodName = joinPoint.getSignature().getName();\n        log.info(\"Beginning execution of {}\", methodName);\n        \n        long start = System.currentTimeMillis();\n        Object result = joinPoint.proceed();\n        long executionTime = System.currentTimeMillis() - start;\n        \n        log.info(\"{} executed in {}ms\", methodName, executionTime);\n        return result;\n    }\n    \n    @AfterThrowing(pointcut = \"execution(* com.example.service.*.*(..))\" , throwing = \"exception\")\n    public void logException(JoinPoint joinPoint, Exception exception) {\n        log.error(\"Exception in {}.{}: {}\",\n            joinPoint.getSignature().getDeclaringTypeName(),\n            joinPoint.getSignature().getName(),\n            exception.getMessage());\n    }\n}"
            },
            {
              "title": "transaction_monitoring",
              "simple-content": "// Performance monitoring aspect for transactions\n@Aspect\n@Component\npublic class TransactionMonitoringAspect {\n    private static final Logger log = LoggerFactory.getLogger(TransactionMonitoringAspect.class);\n    \n    @Around(\"@annotation(org.springframework.transaction.annotation.Transactional)\")\n    public Object monitorTransactionPerformance(ProceedingJoinPoint joinPoint) throws Throwable {\n        String methodName = joinPoint.getSignature().getName();\n        log.info(\"Beginning transaction in method: {}\", methodName);\n        \n        long start = System.currentTimeMillis();\n        Object result = joinPoint.proceed();\n        long duration = System.currentTimeMillis() - start;\n        \n        log.info(\"Transaction completed in {}ms for method: {}\", duration, methodName);\n        return result;\n    }\n}"
            }
          ]
        },
        {
          "title": "boot_specific_considerations",
          "multi-content": [
            "L'auto-configuration de Spring Boot détecte automatiquement les beans @Aspect et les enregistre",
            "Pour une AOP complète, la dépendance spring-boot-starter-aop doit être incluse",
            "Le tissage AspectJ peut être activé via des propriétés de configuration",
            "Les proxies AOP sont créés à l'exécution en utilisant le mécanisme de création de proxy de Spring",
            "L'implémentation AOP de Spring Boot répond à la plupart des cas d'utilisation courants, mais pour des scénarios avancés, envisagez l'intégration complète d'AspectJ"
          ]
        },
        {
          "title": "key_concepts",
          "multi-content": [
            {
              "title": "Aspect",
              "simple-content": "Un module qui encapsule une préoccupation transversale"
            },
            {
              "title": "Point de Jonction",
              "simple-content": "Un point spécifique dans l'exécution du programme (par exemple, l'exécution d'une méthode)"
            },
            {
              "title": "Pointcut",
              "simple-content": "Une expression qui sélectionne les points de jonction"
            },
            {
              "title": "Conseil",
              "simple-content": "Action prise à un point de jonction"
            },
            {
              "title": "Tissage",
              "simple-content": "Processus d'application des aspects aux objets cibles"
            }
          ]
        },
        {
          "title": "advice_types",
          "multi-content": [
            {
              "title": "@Before",
              "multi-content": [
                {
                  "title": "description",
                  "simple-content": "S'exécute avant le point de jonction"
                },
                {
                  "title": "use_cases",
                  "simple-content": "Validation, journalisation, contrôles de sécurité"
                },
                {
                  "title": "code_examples",
                  "multi-content": [
                    {
                      "title": "",
                      "simple-content": "@Before(\"execution(* com.example.service.*.*(..))\")\npublic void logBefore(JoinPoint joinPoint) {\n    System.out.println(\"Before executing: \" + joinPoint.getSignature().getName());\n}"
                    }
                  ]
                }
              ]
            },
            {
              "title": "@After",
              "multi-content": [
                {
                  "title": "description",
                  "simple-content": "S'exécute après le point de jonction (indépendamment du résultat)"
                },
                {
                  "title": "use_cases",
                  "simple-content": "Nettoyage des ressources, audit"
                }
              ]
            },
            {
              "title": "@AfterReturning",
              "multi-content": [
                {
                  "title": "description",
                  "simple-content": "S'exécute après l'achèvement réussi du point de jonction"
                },
                {
                  "title": "use_cases",
                  "simple-content": "Journalisation des résultats, mise en cache"
                }
              ]
            },
            {
              "title": "@AfterThrowing",
              "multi-content": [
                {
                  "title": "description",
                  "simple-content": "S'exécute si le point de jonction lance une exception"
                },
                {
                  "title": "use_cases",
                  "simple-content": "Gestion des exceptions, alertes"
                }
              ]
            },
            {
              "title": "@Around",
              "multi-content": [
                {
                  "title": "description",
                  "simple-content": "Entoure l'exécution du point de jonction"
                },
                {
                  "title": "use_cases",
                  "simple-content": "Gestion des transactions, chronométrage des méthodes"
                },
                {
                  "title": "example",
                  "simple-content": "@Around(\"execution(* com.example.service.*.*(..))\")\npublic Object logAround(ProceedingJoinPoint joinPoint) throws Throwable {\n    long start = System.currentTimeMillis();\n    \n    Object result = joinPoint.proceed();\n    \n    long end = System.currentTimeMillis();\n    System.out.println(\"Time taken: \" + (end - start) + \"ms\");\n    \n    return result;\n}"
                }
              ]
            }
          ]
        },
        {
          "title": "pointcut_expressions",
          "multi-content": [
            {
              "title": "code_examples",
              "multi-content": [
                {
                  "title": "Toutes les méthodes dans le package service",
                  "simple-content": "execution(* com.example.service.*.*(..))"
                },
                {
                  "title": "Toutes les méthodes dans l'interface UserService",
                  "simple-content": "execution(* com.example.service.UserService+.*(..))"
                },
                {
                  "title": "Toutes les méthodes annotées avec @Transactional",
                  "simple-content": "@annotation(org.springframework.transaction.annotation.Transactional)"
                },
                {
                  "title": "Toutes les méthodes publiques",
                  "simple-content": "execution(public * *(..))"
                }
              ]
            }
          ]
        },
        {
          "title": "code_examples",
          "multi-content": [
            {
              "title": "",
              "simple-content": "@Aspect\n@Component\npublic class LoggingAspect {\n    \n    // Define pointcut\n    @Pointcut(\"execution(* com.example.service.*.*(..))\")\n    public void serviceMethods() {}\n    \n    // Before advice\n    @Before(\"serviceMethods()\")\n    public void logBefore(JoinPoint joinPoint) {\n        System.out.println(\"Before executing: \" + joinPoint.getSignature().getName());\n    }\n    \n    // Around advice\n    @Around(\"@annotation(com.example.annotation.LogExecutionTime)\")\n    public Object logExecutionTime(ProceedingJoinPoint joinPoint) throws Throwable {\n        long start = System.currentTimeMillis();\n        \n        Object result = joinPoint.proceed();\n        \n        long end = System.currentTimeMillis();\n        System.out.println(\"Time taken: \" + (end - start) + \"ms\");\n        \n        return result;\n    }\n}"
            }
          ]
        }
      ]
    },
    {
      "title": "ApplicationContext",
      "multi-content": [
        {
          "title": "description",
          "simple-content": "Un conteneur IoC avancé qui fournit des fonctionnalités de niveau entreprise au-delà de la gestion basique des beans."
        },
        {
          "title": "definition",
          "simple-content": "Une interface centrale qui fournit la configuration pour une application, représentant le conteneur IoC de Spring et responsable de l'instanciation, de la configuration et de l'assemblage des beans."
        },
        {
          "title": "key_features",
          "multi-content": [
            "Étend BeanFactory avec des fonctionnalités d'entreprise",
            "Fournit un mécanisme de publication d'événements",
            "Prend en charge l'internationalisation (i18n)",
            "Capacités de chargement de ressources",
            "Intégration avec AOP",
            "Initialisation précoce des beans"
          ]
        },
        {
          "title": "context_types",
          "multi-content": [
            {
              "title": "AnnotationConfigApplicationContext",
              "simple-content": "Pour la configuration basée sur Java"
            },
            {
              "title": "ClassPathXmlApplicationContext",
              "simple-content": "Pour la configuration XML chargée depuis le classpath"
            },
            {
              "title": "FileSystemXmlApplicationContext",
              "simple-content": "Pour la configuration XML chargée depuis le système de fichiers"
            },
            {
              "title": "WebApplicationContext",
              "simple-content": "Pour les applications web"
            }
          ]
        },
        {
          "title": "vs_beanfactory",
          "multi-content": [
            {
              "title": "Instanciation des Beans",
              "multi-content": [
                {
                  "title": "beanFactory",
                  "simple-content": "Paresseuse (sur demande)"
                },
                {
                  "title": "applicationContext",
                  "simple-content": "Précoce (au démarrage)"
                }
              ]
            },
            {
              "title": "Publication d'Événements",
              "multi-content": [
                {
                  "title": "beanFactory",
                  "simple-content": "Non prise en charge"
                },
                {
                  "title": "applicationContext",
                  "simple-content": "Prise en charge"
                }
              ]
            },
            {
              "title": "Accès aux Ressources",
              "multi-content": [
                {
                  "title": "beanFactory",
                  "simple-content": "Limité"
                },
                {
                  "title": "applicationContext",
                  "simple-content": "Amélioré"
                }
              ]
            }
          ]
        },
        {
          "title": "code_examples",
          "multi-content": [
            {
              "title": "creating_context",
              "simple-content": "// From Java configuration\nApplicationContext context = new AnnotationConfigApplicationContext(AppConfig.class);\n\n// From XML\nApplicationContext context = new ClassPathXmlApplicationContext(\"applicationContext.xml\");"
            },
            {
              "title": "getting_beans",
              "simple-content": "// By type\nUserService userService = context.getBean(UserService.class);\n\n// By name\nUserRepository userRepository = (UserRepository) context.getBean(\"userRepository\");\n\n// By name and type\nDataSource dataSource = context.getBean(\"primaryDataSource\", DataSource.class);"
            }
          ]
        }
      ]
    },
    {
      "title": "Exceptions Spring",
      "multi-content": [
        {
          "title": "description",
          "simple-content": "Comprendre les exceptions Spring courantes et comment les dépanner efficacement."
        },
        {
          "title": "key_exceptions",
          "multi-content": [
            {
              "title": "NoSuchBeanDefinitionException",
              "multi-content": [
                {
                  "title": "description",
                  "simple-content": "Se produit lorsque Spring ne peut pas trouver un bean du type ou du nom demandé"
                },
                {
                  "title": "causes",
                  "multi-content": [
                    "Configuration de scan de composants manquante",
                    "Bean non correctement défini",
                    "Bean en dehors des packages scannés",
                    "Mauvais qualificateur ou nom spécifié",
                    "Bean non actif sous le profil actuel"
                  ]
                },
                {
                  "title": "resolution",
                  "multi-content": [
                    "Vérifier la configuration de scan des composants",
                    "S'assurer que le bean est correctement annoté ou défini",
                    "Vérifier la structure des packages",
                    "Vérifier la configuration du profil"
                  ]
                }
              ]
            },
            {
              "title": "UnsatisfiedDependencyException",
              "multi-content": [
                {
                  "title": "description",
                  "simple-content": "Se produit lorsque les dépendances d'un bean ne peuvent pas être résolues"
                },
                {
                  "title": "causes",
                  "multi-content": [
                    "Bean de dépendance manquant",
                    "Dépendances ambiguës sans désambiguïsation appropriée",
                    "Dépendances circulaires avec injection par constructeur",
                    "Inadéquation de type dans la dépendance"
                  ]
                },
                {
                  "title": "resolution",
                  "multi-content": [
                    "S'assurer que toutes les dépendances sont disponibles",
                    "Utiliser @Qualifier ou @Primary pour la désambiguïsation",
                    "Vérifier les dépendances circulaires",
                    "Vérifier la compatibilité des types"
                  ]
                }
              ]
            },
            {
              "title": "BeanCreationException",
              "multi-content": [
                {
                  "title": "description",
                  "simple-content": "Se produit pendant le processus d'instanciation du bean"
                },
                {
                  "title": "causes",
                  "multi-content": [
                    "Exception dans le constructeur de bean",
                    "Exception dans la méthode @PostConstruct",
                    "Erreur d'initialisation de bean",
                    "Dépendances circulaires"
                  ]
                },
                {
                  "title": "resolution",
                  "multi-content": [
                    "Vérifier les exceptions dans l'initialisation du bean",
                    "Déboguer les méthodes d'initialisation",
                    "Rechercher les dépendances circulaires",
                    "Examiner les exceptions imbriquées"
                  ]
                }
              ]
            },
            {
              "title": "BeanCurrentlyInCreationException",
              "multi-content": [
                {
                  "title": "description",
                  "simple-content": "Se produit avec des dépendances circulaires"
                },
                {
                  "title": "causes",
                  "multi-content": [
                    "Dépendances circulaires avec injection par constructeur"
                  ]
                },
                {
                  "title": "resolution",
                  "multi-content": [
                    "Redessiner les composants pour éliminer la dépendance circulaire",
                    "Utiliser l'injection par setter au lieu de l'injection par constructeur",
                    "Utiliser l'annotation @Lazy sur l'une des dépendances"
                  ]
                }
              ]
            }
          ]
        },
        {
          "title": "troubleshooting_approaches",
          "multi-content": [
            {
              "title": "Lire la Trace de la Pile",
              "simple-content": "Examiner attentivement le message d'exception et la trace de la pile"
            },
            {
              "title": "Activer la Journalisation de Débogage",
              "simple-content": "Augmenter le niveau de journalisation pour obtenir plus d'informations"
            },
            {
              "title": "Utiliser les Événements ApplicationContext",
              "simple-content": "Écouter les événements du contexte pour identifier les problèmes"
            },
            {
              "title": "Inspecter les Définitions de Beans",
              "simple-content": "Inspecter programmatiquement les définitions de beans"
            }
          ]
        }
      ]
    }
  ]
}