{
  "id": "spring-core-concepts",
  "title": "Concepts Fondamentaux de Spring",
  "topics": [
    {
      "title": "IoC",
      "multi-content": [
        {
          "title": "description",
          "simple-content": "L'Inversion de Contrôle (IoC) est un principe de conception où le contrôle de la création d'objets et de leur cycle de vie est transféré du code de l'application à un conteneur ou framework externe."
        },
        {
          "title": "definition",
          "simple-content": "Un principe de conception où le contrôle de la création d'objets et de la gestion des dépendances est délégué à un conteneur externe, améliorant la modularité et la testabilité."
        },
        {
          "title": "benefits",
          "multi-content": [
            "Découple la création de composants de leur utilisation",
            "Favorise une conception modulaire et la testabilité",
            "Permet une architecture d'application flexible",
            "Forme la base pour l'injection de dépendances",
            "Couplage faible entre les composants",
            "Meilleure testabilité grâce à une simulation plus facile"
          ]
        },
        {
          "title": "example",
          "multi-content": [
            {
              "title": "without_ioc",
              "simple-content": "public class UserService {\n    private UserRepository userRepository = new UserRepositoryImpl();\n}"
            },
            {
              "title": "with_ioc",
              "simple-content": "public class UserService {\n    private UserRepository userRepository;\n    \n    // Le conteneur injecte la dépendance\n    public UserService(UserRepository userRepository) {\n        this.userRepository = userRepository;\n    }\n}"
            }
          ]
        }
      ]
    },
    {
      "title": "DependencyInjection",
      "multi-content": [
        {
          "title": "description",
          "simple-content": "Un modèle spécifique de mise en œuvre de l'IoC où les dépendances d'objets sont fournies par une source externe plutôt que créées en interne."
        },
        {
          "title": "definition",
          "simple-content": "Un modèle dans lequel les dépendances d'un objet sont fournies par une source externe (généralement le conteneur IoC) plutôt que l'objet les instanciant lui-même, favorisant un couplage faible."
        },
        {
          "title": "types",
          "multi-content": [
            {
              "title": "Constructor Injection",
              "multi-content": [
                {
                  "title": "description",
                  "simple-content": "Dépendances fournies via le constructeur"
                },
                {
                  "title": "best_for",
                  "simple-content": "Dépendances requises, objets immuables"
                },
                {
                  "title": "example",
                  "simple-content": "public Service(Dependency d) {...}"
                },
                {
                  "title": "advantages",
                  "multi-content": [
                    "Garantit que les dépendances requises sont fournies",
                    "Favorise l'immuabilité (les dépendances peuvent être finales)",
                    "Rend les dépendances explicites et visibles lors de la construction",
                    "Plus facile à tester et à simuler",
                    "Fonctionne sans conteneur DI",
                    "Détecte les dépendances circulaires à la compilation"
                  ]
                }
              ]
            },
            {
              "title": "Setter Injection",
              "multi-content": [
                {
                  "title": "description",
                  "simple-content": "Dépendances fournies via des méthodes setter"
                },
                {
                  "title": "best_for",
                  "simple-content": "Dépendances optionnelles, objets reconfigurables"
                },
                {
                  "title": "example",
                  "simple-content": "public void setDependency(Dependency d) {...}"
                },
                {
                  "title": "advantages",
                  "multi-content": [
                    "Permet des dépendances optionnelles",
                    "Offre de la flexibilité dans la gestion des dépendances",
                    "Prend en charge la modification des dépendances à l'exécution"
                  ]
                }
              ]
            },
            {
              "title": "Field Injection",
              "multi-content": [
                {
                  "title": "description",
                  "simple-content": "Dépendances injectées directement dans les champs"
                },
                {
                  "title": "best_for",
                  "simple-content": "Cas simples (généralement déconseillé)"
                },
                {
                  "title": "example",
                  "simple-content": "@Autowired private Dependency d;"
                },
                {
                  "title": "advantages",
                  "multi-content": [
                    "Moins de code passe-partout",
                    "Plus simple à écrire"
                  ]
                },
                {
                  "title": "disadvantages",
                  "multi-content": [
                    "Plus difficile à tester",
                    "Impossible de déclarer les champs comme final",
                    "Dépendances cachées"
                  ]
                }
              ]
            }
          ]
        },
        {
          "title": "code_examples",
          "multi-content": [
            {
              "title": "constructor_injection",
              "simple-content": "@Service\npublic class UserService {\n    private final UserRepository userRepository;\n    \n    @Autowired // Optionnel dans Spring 4.3+ avec un seul constructeur\n    public UserService(UserRepository userRepository) {\n        this.userRepository = userRepository;\n    }\n}"
            },
            {
              "title": "setter_injection",
              "simple-content": "@Service\npublic class UserService {\n    private UserRepository userRepository;\n    \n    @Autowired\n    public void setUserRepository(UserRepository userRepository) {\n        this.userRepository = userRepository;\n    }\n}"
            },
            {
              "title": "field_injection",
              "simple-content": "@Service\npublic class UserService {\n    @Autowired\n    private UserRepository userRepository;\n}"
            }
          ]
        }
      ]
    },
    {
      "title": "BeanLifecycle",
      "multi-content": [
        {
          "title": "description",
          "simple-content": "Le parcours d'un bean Spring de l'initialisation à la destruction, avec des possibilités de personnalisation à chaque étape."
        },
        {
          "title": "definition",
          "simple-content": "Le processus complet qu'un bean Spring subit, de l'instanciation et l'injection de dépendances à l'initialisation et à la destruction éventuelle, avec des opportunités de comportement personnalisé à diverses étapes."
        },
        {
          "title": "lifecycle_phases",
          "multi-content": [
            {
              "title": "Bean Definition",
              "multi-content": [
                {
                  "title": "description",
                  "simple-content": "Spring lit la configuration et crée des objets BeanDefinition"
                },
                {
                  "title": "events",
                  "multi-content": [
                    "Les métadonnées de configuration sont chargées (annotations, XML, config Java)",
                    "Les objets BeanDefinition sont créés et enregistrés dans le conteneur"
                  ]
                }
              ]
            },
            {
              "title": "Bean Instantiation",
              "multi-content": [
                {
                  "title": "description",
                  "simple-content": "Spring crée l'instance du bean"
                },
                {
                  "title": "events",
                  "multi-content": [
                    "Le constructeur est invoqué",
                    "La méthode factory est appelée (si configurée)"
                  ]
                }
              ]
            },
            {
              "title": "Property Population",
              "multi-content": [
                {
                  "title": "description",
                  "simple-content": "Les dépendances sont injectées"
                },
                {
                  "title": "events",
                  "multi-content": [
                    "Les propriétés sont définies",
                    "Les dépendances sont résolues et injectées"
                  ]
                }
              ]
            },
            {
              "title": "Initialization",
              "multi-content": [
                {
                  "title": "description",
                  "simple-content": "Le bean est initialisé via des callbacks"
                },
                {
                  "title": "events",
                  "multi-content": [
                    "BeanNameAware.setBeanName() est appelé",
                    "BeanFactoryAware.setBeanFactory() est appelé",
                    "ApplicationContextAware.setApplicationContext() est appelé",
                    "Les méthodes BeanPostProcessor.postProcessBeforeInitialization() sont appelées",
                    "Les méthodes @PostConstruct sont appelées",
                    "InitializingBean.afterPropertiesSet() est appelé",
                    "La méthode init-method personnalisée est appelée",
                    "Les méthodes BeanPostProcessor.postProcessAfterInitialization() sont appelées"
                  ]
                }
              ]
            },
            {
              "title": "Bean Usage",
              "multi-content": [
                {
                  "title": "description",
                  "simple-content": "Le bean est prêt à être utilisé par l'application"
                }
              ]
            },
            {
              "title": "Destruction",
              "multi-content": [
                {
                  "title": "description",
                  "simple-content": "Le bean est détruit lorsque le contexte est fermé"
                },
                {
                  "title": "events",
                  "multi-content": [
                    "Les méthodes @PreDestroy sont appelées",
                    "DisposableBean.destroy() est appelé",
                    "La méthode destroy-method personnalisée est appelée"
                  ]
                }
              ]
            }
          ]
        },
        {
          "title": "callback_methods",
          "multi-content": [
            {
              "title": "initialization",
              "multi-content": [
                {
                  "title": "annotation_based",
                  "simple-content": "@PostConstruct"
                },
                {
                  "title": "interface_based",
                  "simple-content": "InitializingBean.afterPropertiesSet()"
                },
                {
                  "title": "xml_based",
                  "simple-content": "attribut init-method"
                }
              ]
            },
            {
              "title": "destruction",
              "multi-content": [
                {
                  "title": "annotation_based",
                  "simple-content": "@PreDestroy"
                },
                {
                  "title": "interface_based",
                  "simple-content": "DisposableBean.destroy()"
                },
                {
                  "title": "xml_based",
                  "simple-content": "attribut destroy-method"
                }
              ]
            }
          ]
        },
        {
          "title": "example",
          "simple-content": "@Component\npublic class LifecycleBean implements InitializingBean, DisposableBean {\n    \n    // Constructeur\n    public LifecycleBean() {\n        System.out.println(\"1. Constructeur appelé\");\n    }\n    \n    // Injection par setter\n    @Autowired\n    public void setDependency(SomeDependency dependency) {\n        System.out.println(\"2. Dépendances injectées\");\n    }\n    \n    // Initialisation basée sur annotation\n    @PostConstruct\n    public void postConstruct() {\n        System.out.println(\"3. @PostConstruct appelé\");\n    }\n    \n    // Initialisation basée sur interface\n    @Override\n    public void afterPropertiesSet() throws Exception {\n        System.out.println(\"4. afterPropertiesSet() appelé\");\n    }\n    \n    // Méthode d'initialisation personnalisée\n    public void customInit() {\n        System.out.println(\"5. Méthode d'initialisation personnalisée appelée\");\n    }\n    \n    // Destruction basée sur annotation\n    @PreDestroy\n    public void preDestroy() {\n        System.out.println(\"6. @PreDestroy appelé\");\n    }\n    \n    // Destruction basée sur interface\n    @Override\n    public void destroy() throws Exception {\n        System.out.println(\"7. DisposableBean.destroy() appelé\");\n    }\n}"
        }
      ]
    },
    {
      "title": "BeanScopes",
      "multi-content": [
        {
          "title": "description",
          "simple-content": "Les portées de bean définissent le cycle de vie d'un bean, sa visibilité et le nombre d'instances créées."
        },
        {
          "title": "definition",
          "simple-content": "Définit le cycle de vie et la visibilité d'un bean dans le conteneur. Chaque portée détermine quand une nouvelle instance est créée et combien de temps elle vit."
        },
        {
          "title": "scope_types",
          "multi-content": [
            {
              "title": "singleton",
              "multi-content": [
                {
                  "title": "description",
                  "simple-content": "Portée par défaut; une instance par conteneur Spring"
                },
                {
                  "title": "instances",
                  "simple-content": "Unique"
                },
                {
                  "title": "lifecycle",
                  "simple-content": "Cycle de vie du conteneur"
                },
                {
                  "title": "best_for",
                  "simple-content": "Services et repositories sans état"
                }
              ]
            },
            {
              "title": "prototype",
              "multi-content": [
                {
                  "title": "description",
                  "simple-content": "Nouvelle instance de bean pour chaque demande/injection"
                },
                {
                  "title": "instances",
                  "simple-content": "Multiple"
                },
                {
                  "title": "lifecycle",
                  "simple-content": "De la création jusqu'à ce qu'il ne soit plus référencé"
                },
                {
                  "title": "best_for",
                  "simple-content": "Objets avec état comme les formulaires ou paniers d'achat"
                }
              ]
            },
            {
              "title": "request",
              "multi-content": [
                {
                  "title": "description",
                  "simple-content": "Une instance par requête HTTP (compatible web)"
                },
                {
                  "title": "instances",
                  "simple-content": "Multiple"
                },
                {
                  "title": "lifecycle",
                  "simple-content": "Requête HTTP"
                },
                {
                  "title": "best_for",
                  "simple-content": "Données spécifiques à la requête HTTP"
                }
              ]
            },
            {
              "title": "session",
              "multi-content": [
                {
                  "title": "description",
                  "simple-content": "Une instance par session HTTP (compatible web)"
                },
                {
                  "title": "instances",
                  "simple-content": "Multiple"
                },
                {
                  "title": "lifecycle",
                  "simple-content": "Session HTTP"
                },
                {
                  "title": "best_for",
                  "simple-content": "Données spécifiques à l'utilisateur dans les applications web"
                }
              ]
            },
            {
              "title": "application",
              "multi-content": [
                {
                  "title": "description",
                  "simple-content": "Une instance par ServletContext (compatible web)"
                },
                {
                  "title": "instances",
                  "simple-content": "Unique"
                },
                {
                  "title": "lifecycle",
                  "simple-content": "Cycle de vie du ServletContext"
                },
                {
                  "title": "best_for",
                  "simple-content": "Beans à l'échelle de l'application"
                }
              ]
            },
            {
              "title": "websocket",
              "multi-content": [
                {
                  "title": "description",
                  "simple-content": "Une instance par WebSocket (compatible web)"
                },
                {
                  "title": "instances",
                  "simple-content": "Multiple"
                },
                {
                  "title": "lifecycle",
                  "simple-content": "Cycle de vie WebSocket"
                },
                {
                  "title": "best_for",
                  "simple-content": "Beans spécifiques aux WebSockets"
                }
              ]
            }
          ]
        },
        {
          "title": "examples",
          "multi-content": [
            {
              "title": "singleton_scope",
              "simple-content": "@Component\n@Scope(\"singleton\") // ou simplement @Component puisque singleton est la valeur par défaut\npublic class UserService { /* ... */ }"
            },
            {
              "title": "prototype_scope",
              "simple-content": "@Component\n@Scope(\"prototype\")\npublic class ShoppingCart { /* ... */ }"
            },
            {
              "title": "request_scope",
              "simple-content": "@Component\n@RequestScope // ou @Scope(value = \"request\", proxyMode = ScopedProxyMode.TARGET_CLASS)\npublic class RequestScopedBean { /* ... */ }"
            },
            {
              "title": "mixing_scopes",
              "simple-content": "// Problème: Injection d'un prototype dans un singleton\n@Component\npublic class SingletonBean {\n    @Autowired\n    private PrototypeBean prototypeBean; // Ce sera toujours la même instance!\n}\n\n// Solution 1: Proxy Scopé\n@Component\n@Scope(value = \"prototype\", proxyMode = ScopedProxyMode.TARGET_CLASS)\npublic class PrototypeBean { /* ... */ }\n\n// Solution 2: ObjectFactory\n@Component\npublic class SingletonBean {\n    @Autowired\n    private ObjectFactory<PrototypeBean> prototypeBeanFactory;\n    \n    public void doSomething() {\n        PrototypeBean prototypeBean = prototypeBeanFactory.getObject(); // Nouvelle instance\n        // Utiliser prototypeBean\n    }\n}"
            }
          ]
        }
      ]
    },
    {
      "title": "SpringConfiguration",
      "multi-content": [
        {
          "title": "description",
          "simple-content": "Différentes approches pour configurer les beans et câbler les dépendances dans les applications Spring."
        },
        {
          "title": "definition",
          "simple-content": "Le processus de définition des beans, de leurs dépendances et d'autres paramètres d'application à gérer par le conteneur Spring."
        },
        {
          "title": "configuration_types",
          "multi-content": [
            {
              "title": "Java Configuration",
              "multi-content": [
                {
                  "title": "description",
                  "simple-content": "Utilisation des annotations @Configuration et @Bean dans les classes Java"
                },
                {
                  "title": "best_for",
                  "simple-content": "Sécurité de type, facilité de refactorisation, support IDE"
                },
                {
                  "title": "advantages",
                  "multi-content": [
                    "Sécurité de type",
                    "Vérifications à la compilation",
                    "Meilleure prise en charge du refactoring",
                    "Autocomplétion IDE",
                    "Configuration programmatique"
                  ]
                },
                {
                  "title": "example",
                  "simple-content": "@Configuration\npublic class AppConfig {\n    \n    @Bean\n    public UserRepository userRepository() {\n        return new JpaUserRepository();\n    }\n    \n    @Bean\n    public UserService userService(UserRepository userRepository) {\n        return new UserServiceImpl(userRepository);\n    }\n}"
                }
              ]
            },
            {
              "title": "Annotation-Based",
              "multi-content": [
                {
                  "title": "description",
                  "simple-content": "Utilisation du scan de composants avec @Component, @Service, etc."
                },
                {
                  "title": "best_for",
                  "simple-content": "Simplicité, réduction du code standard, convention plutôt que configuration"
                },
                {
                  "title": "advantages",
                  "multi-content": [
                    "Moins de code de configuration",
                    "Configuration plus proche de l'implémentation",
                    "Détection automatique des composants",
                    "Code propre et lisible"
                  ]
                },
                {
                  "title": "example",
                  "simple-content": "@Configuration\n@ComponentScan(basePackages = \"com.example\")\npublic class AppConfig {\n    // Configuration pour le scan de composants\n}\n\n@Component\npublic class SimpleComponent { /* ... */ }\n\n@Repository\npublic class JpaUserRepository implements UserRepository { /* ... */ }\n\n@Service\npublic class UserServiceImpl implements UserService {\n    @Autowired\n    private UserRepository userRepository;\n    // Implémentation\n}"
                }
              ]
            },
            {
              "title": "XML Configuration",
              "multi-content": [
                {
                  "title": "description",
                  "simple-content": "Utilisation de fichiers XML avec des définitions <bean>"
                },
                {
                  "title": "best_for",
                  "simple-content": "Configuration externe, systèmes hérités"
                },
                {
                  "title": "advantages",
                  "multi-content": [
                    "Pas de recompilation nécessaire pour les changements de configuration",
                    "Séparation complète du code",
                    "Support Spring hérité",
                    "Câblage explicite des dépendances"
                  ]
                },
                {
                  "title": "example",
                  "simple-content": "<!-- applicationContext.xml -->\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n                           http://www.springframework.org/schema/beans/spring-beans.xsd\">\n\n    <bean id=\"userRepository\" class=\"com.example.JpaUserRepository\" />\n    \n    <bean id=\"userService\" class=\"com.example.UserServiceImpl\">\n        <constructor-arg ref=\"userRepository\" />\n    </bean>\n</beans>"
                }
              ]
            }
          ]
        },
        {
          "title": "common_annotations",
          "multi-content": [
            {
              "title": "@Configuration",
              "simple-content": "Indique qu'une classe définit des méthodes de bean"
            },
            {
              "title": "@Bean",
              "simple-content": "Marque une méthode comme produisant un bean Spring"
            },
            {
              "title": "@Component",
              "simple-content": "Stéréotype générique pour les composants gérés par Spring"
            },
            {
              "title": "@Repository",
              "simple-content": "Stéréotype pour les composants de la couche de persistance"
            },
            {
              "title": "@Service",
              "simple-content": "Stéréotype pour les composants de la couche de service"
            },
            {
              "title": "@Controller",
              "simple-content": "Stéréotype pour les composants de la couche de présentation"
            },
            {
              "title": "@Autowired",
              "simple-content": "Marque un point d'injection de dépendance"
            },
            {
              "title": "@Qualifier",
              "simple-content": "Désambiguïse quel bean injecter"
            },
            {
              "title": "@Value",
              "simple-content": "Injecte des valeurs à partir de propriétés ou d'expressions"
            },
            {
              "title": "@Profile",
              "simple-content": "Active des beans pour des environnements spécifiques"
            }
          ]
        }
      ]
    },
    {
      "title": "ComponentScanning",
      "multi-content": [
        {
          "title": "description",
          "simple-content": "Le processus par lequel Spring identifie et enregistre automatiquement les beans à partir des packages spécifiés."
        },
        {
          "title": "definition",
          "simple-content": "Un mécanisme qui permet à Spring de détecter et d'enregistrer automatiquement les beans Spring en scannant des packages de base spécifiques pour les classes avec des annotations stéréotypées."
        },
        {
          "title": "key_concepts",
          "multi-content": [
            {
              "title": "base_packages",
              "simple-content": "Les points de départ pour le scan de composants, généralement le package racine de votre application"
            },
            {
              "title": "stereotype_annotations",
              "simple-content": "Marqueurs pour les classes qui devraient être automatiquement enregistrées comme beans (@Component et ses spécialisations)"
            },
            {
              "title": "filters",
              "simple-content": "Règles pour inclure ou exclure certaines classes du scan"
            },
            {
              "title": "bean_naming",
              "simple-content": "Comment Spring nomme automatiquement les composants scannés (généralement nom de classe en camelCase)"
            }
          ]
        },
        {
          "title": "annotations",
          "multi-content": [
            {
              "title": "@Component",
              "simple-content": "Annotation générique pour tout composant géré par Spring"
            },
            {
              "title": "@Service",
              "simple-content": "Indique que la classe appartient à la couche de service (logique métier)"
            },
            {
              "title": "@Repository",
              "simple-content": "Indique une classe de couche de persistance avec traduction automatique des exceptions"
            },
            {
              "title": "@Controller",
              "simple-content": "Indique un composant contrôleur web"
            },
            {
              "title": "@RestController",
              "simple-content": "Combine @Controller et @ResponseBody pour les contrôleurs RESTful"
            }
          ]
        },
        {
          "title": "examples",
          "multi-content": [
            {
              "title": "basic_scanning",
              "simple-content": "@Configuration\n@ComponentScan(basePackages = \"com.example\")\npublic class AppConfig {\n    // Configuration\n}"
            },
            {
              "title": "multiple_packages",
              "simple-content": "@Configuration\n@ComponentScan(basePackages = {\"com.example.service\", \"com.example.repository\"})\npublic class AppConfig {\n    // Configuration\n}"
            },
            {
              "title": "using_filters",
              "simple-content": "@Configuration\n@ComponentScan(\n    basePackages = \"com.example\",\n    includeFilters = @ComponentScan.Filter(type = FilterType.REGEX, pattern = \".*Repository\"),\n    excludeFilters = @ComponentScan.Filter(type = FilterType.ANNOTATION, classes = Deprecated.class)\n)\npublic class AppConfig {\n    // Configuration\n}"
            }
          ]
        },
        {
          "title": "scan_process",
          "multi-content": [
            "Spring recherche les packages de base et sous-packages",
            "Trouve les classes avec des annotations stéréotypées",
            "Lit les métadonnées des annotations",
            "Filtre les classes en fonction des règles d'inclusion/exclusion",
            "Enregistre les BeanDefinitions pour les classes correspondantes",
            "Nomme les beans (généralement le nom de classe avec première lettre en minuscule)",
            "Traite les annotations supplémentaires (comme @Scope, @Lazy)"
          ]
        }
      ]
    },
    {
      "title": "DependencyResolution",
      "multi-content": [
        {
          "title": "description",
          "simple-content": "Comment Spring résout les dépendances et gère les scénarios avec plusieurs candidats."
        },
        {
          "title": "definition",
          "simple-content": "Le processus par lequel Spring identifie et sélectionne les beans appropriés à injecter lorsque des dépendances sont déclarées."
        },
        {
          "title": "resolution_mechanisms",
          "multi-content": [
            {
              "title": "@Qualifier",
              "multi-content": [
                {
                  "title": "description",
                  "simple-content": "Spécifie quel bean injecter lorsque plusieurs candidats existent"
                },
                {
                  "title": "example",
                  "simple-content": "@Service(\"premiumService\")\npublic class PremiumUserService implements UserService { /* ... */ }\n\n@Service(\"basicService\")\npublic class BasicUserService implements UserService { /* ... */ }\n\n@Component\npublic class UserController {\n    private final UserService userService;\n    \n    @Autowired\n    public UserController(@Qualifier(\"premiumService\") UserService userService) {\n        this.userService = userService;\n    }\n}"
                }
              ]
            },
            {
              "title": "@Primary",
              "multi-content": [
                {
                  "title": "description",
                  "simple-content": "Marque un bean comme candidat principal pour l'autowiring"
                },
                {
                  "title": "example",
                  "simple-content": "@Service\n@Primary\npublic class PrimaryUserService implements UserService { /* ... */ }\n\n@Service\npublic class SecondaryUserService implements UserService { /* ... */ }\n\n@Component\npublic class UserController {\n    private final UserService userService;\n    \n    @Autowired\n    public UserController(UserService userService) {\n        // PrimaryUserService sera injecté\n        this.userService = userService;\n    }\n}"
                }
              ]
            },
            {
              "title": "Bean Name Autowiring",
              "multi-content": [
                {
                  "title": "description",
                  "simple-content": "Correspondance par nom de paramètre/champ"
                },
                {
                  "title": "example",
                  "simple-content": "@Component(\"premiumService\")\npublic class PremiumUserService implements UserService { /* ... */ }\n\n@Component(\"basicService\")\npublic class BasicUserService implements UserService { /* ... */ }\n\n@Component\npublic class UserController {\n    private final UserService premiumService; // Le nom correspond à l'id du bean\n    \n    @Autowired\n    public UserController(UserService premiumService) {\n        this.premiumService = premiumService;\n    }\n}"
                }
              ]
            }
          ]
        },
        {
          "title": "resolution_order",
          "multi-content": [
            "1. Correspondance exacte de type (si un seul bean du type requis existe)",
            "2. Correspondance par @Qualifier si spécifié",
            "3. Correspondance avec bean @Primary si disponible",
            "4. Correspondance par nom (si le nom du paramètre/champ correspond à un nom de bean)",
            "5. Lance une exception si aucun bean unique ne peut être déterminé"
          ]
        },
        {
          "title": "common_exceptions",
          "multi-content": [
            {
              "title": "NoSuchBeanDefinitionException",
              "simple-content": "Aucun bean qualifié trouvé"
            },
            {
              "title": "NoUniqueBeanDefinitionException",
              "simple-content": "Plusieurs beans qualifiés trouvés"
            },
            {
              "title": "BeanCreationException",
              "simple-content": "Erreur lors de la création d'un bean"
            }
          ]
        }
      ]
    },
    {
      "title": "CircularDependencies",
      "multi-content": [
        {
          "title": "description",
          "simple-content": "Une situation où le bean A dépend du bean B, et le bean B dépend du bean A, directement ou indirectement."
        },
        {
          "title": "definition",
          "simple-content": "Une dépendance circulaire se produit lorsque deux beans ou plus dépendent l'un de l'autre, créant un cycle de dépendance qui peut causer des problèmes d'initialisation."
        },
        {
          "title": "dependency_types",
          "multi-content": [
            {
              "title": "Constructor Injection Circularity",
              "multi-content": [
                {
                  "title": "resolvable",
                  "simple-content": "false"
                },
                {
                  "title": "description",
                  "simple-content": "Ne peut pas être résolu par Spring"
                },
                {
                  "title": "example",
                  "simple-content": "@Component\npublic class BeanA {\n    private final BeanB beanB;\n    \n    @Autowired\n    public BeanA(BeanB beanB) {\n        this.beanB = beanB;\n    }\n}\n\n@Component\npublic class BeanB {\n    private final BeanA beanA;\n    \n    @Autowired\n    public BeanB(BeanA beanA) {\n        this.beanA = beanA;\n    }\n}"
                }
              ]
            },
            {
              "title": "Setter Injection Circularity",
              "multi-content": [
                {
                  "title": "resolvable",
                  "simple-content": "true"
                },
                {
                  "title": "description",
                  "simple-content": "Peut être résolu par Spring"
                },
                {
                  "title": "example",
                  "simple-content": "@Component\npublic class BeanA {\n    private BeanB beanB;\n    \n    @Autowired\n    public void setBeanB(BeanB beanB) {\n        this.beanB = beanB;\n    }\n}\n\n@Component\npublic class BeanB {\n    private BeanA beanA;\n    \n    @Autowired\n    public void setBeanA(BeanA beanA) {\n        this.beanA = beanA;\n    }\n}"
                }
              ]
            }
          ]
        },
        {
          "title": "detection",
          "simple-content": "Spring détecte les dépendances circulaires pendant le démarrage de l'application et lance BeanCurrentlyInCreationException si elles ne peuvent pas être résolues."
        },
        {
          "title": "resolution_strategies",
          "multi-content": [
            {
              "title": "Redesign Components",
              "multi-content": [
                {
                  "title": "recommendation",
                  "simple-content": "Bonne pratique"
                },
                {
                  "title": "description",
                  "simple-content": "Repenser les dépendances pour éliminer les références circulaires"
                },
                {
                  "title": "details",
                  "multi-content": [
                    "Extraire les fonctionnalités partagées vers un troisième service",
                    "Appliquer le Principe d'Inversion de Dépendance",
                    "Utiliser des événements pour la communication"
                  ]
                }
              ]
            },
            {
              "title": "Use Setter Injection",
              "multi-content": [
                {
                  "title": "description",
                  "simple-content": "Passer de l'injection par constructeur à l'injection par setter"
                },
                {
                  "title": "caution",
                  "simple-content": "Crée la possibilité de beans partiellement initialisés"
                }
              ]
            },
            {
              "title": "Use @Lazy Annotation",
              "multi-content": [
                {
                  "title": "description",
                  "simple-content": "Différer un côté de la dépendance"
                },
                {
                  "title": "example",
                  "simple-content": "@Component\npublic class BeanA {\n    private final BeanB beanB;\n    \n    @Autowired\n    public BeanA(@Lazy BeanB beanB) {\n        this.beanB = beanB;\n    }\n}"
                }
              ]
            },
            {
              "title": "Use Events",
              "multi-content": [
                {
                  "title": "description",
                  "simple-content": "Découpler la communication en utilisant le système d'événements de Spring"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "title": "AOP",
      "multi-content": [
        {
          "title": "description",
          "simple-content": "L'AOP traite les préoccupations transversales en les séparant de la logique métier principale, favorisant un code plus propre et plus maintenable."
        },
        {
          "title": "definition",
          "simple-content": "Un paradigme de programmation qui sépare les préoccupations transversales (comme la journalisation, la sécurité ou la gestion des transactions) de la logique métier en utilisant des aspects, des conseils, des points de jonction et des pointcuts."
        },
        {
          "title": "key_concepts",
          "multi-content": [
            {
              "title": "Aspect",
              "simple-content": "Un module qui encapsule une préoccupation transversale"
            },
            {
              "title": "Join Point",
              "simple-content": "Un point spécifique dans l'exécution du programme (par exemple, l'exécution d'une méthode)"
            },
            {
              "title": "Pointcut",
              "simple-content": "Une expression qui sélectionne les points de jonction"
            },
            {
              "title": "Advice",
              "simple-content": "Action prise à un point de jonction"
            },
            {
              "title": "Weaving",
              "simple-content": "Processus d'application des aspects aux objets cibles"
            }
          ]
        },
        {
          "title": "advice_types",
          "multi-content": [
            {
              "title": "@Before",
              "multi-content": [
                {
                  "title": "description",
                  "simple-content": "S'exécute avant le point de jonction"
                },
                {
                  "title": "use_cases",
                  "simple-content": "Validation, journalisation, contrôles de sécurité"
                },
                {
                  "title": "example",
                  "simple-content": "@Before(\"execution(* com.example.service.*.*(..))\")\npublic void logBefore(JoinPoint joinPoint) {\n    System.out.println(\"Avant l'exécution de: \" + joinPoint.getSignature().getName());\n}"
                }
              ]
            },
            {
              "title": "@After",
              "multi-content": [
                {
                  "title": "description",
                  "simple-content": "S'exécute après le point de jonction (quel que soit le résultat)"
                },
                {
                  "title": "use_cases",
                  "simple-content": "Nettoyage des ressources, audit"
                }
              ]
            },
            {
              "title": "@AfterReturning",
              "multi-content": [
                {
                  "title": "description",
                  "simple-content": "S'exécute après la complétion réussie du point de jonction"
                },
                {
                  "title": "use_cases",
                  "simple-content": "Journalisation des résultats, mise en cache"
                }
              ]
            },
            {
              "title": "@AfterThrowing",
              "multi-content": [
                {
                  "title": "description",
                  "simple-content": "S'exécute si le point de jonction lance une exception"
                },
                {
                  "title": "use_cases",
                  "simple-content": "Gestion des exceptions, alertes"
                }
              ]
            },
            {
              "title": "@Around",
              "multi-content": [
                {
                  "title": "description",
                  "simple-content": "Entoure l'exécution du point de jonction"
                },
                {
                  "title": "use_cases",
                  "simple-content": "Gestion des transactions, chronométrage des méthodes"
                },
                {
                  "title": "example",
                  "simple-content": "@Around(\"execution(* com.example.service.*.*(..))\")\npublic Object logAround(ProceedingJoinPoint joinPoint) throws Throwable {\n    long start = System.currentTimeMillis();\n    \n    Object result = joinPoint.proceed();\n    \n    long end = System.currentTimeMillis();\n    System.out.println(\"Temps pris: \" + (end - start) + \"ms\");\n    \n    return result;\n}"
                }
              ]
            }
          ]
        },
        {
          "title": "pointcut_expressions",
          "multi-content": [
            {
              "title": "All methods in service package",
              "simple-content": "execution(* com.example.service.*.*(..))"
            },
            {
              "title": "All methods in UserService interface",
              "simple-content": "execution(* com.example.service.UserService+.*(..))"
            },
            {
              "title": "All methods annotated with @Transactional",
              "simple-content": "@annotation(org.springframework.transaction.annotation.Transactional)"
            },
            {
              "title": "All public methods",
              "simple-content": "execution(public * *(..))"
            }
          ]
        },
        {
          "title": "example",
          "simple-content": "@Aspect\n@Component\npublic class LoggingAspect {\n    \n    // Définir pointcut\n    @Pointcut(\"execution(* com.example.service.*.*(..))\")\n    public void serviceMethods() {}\n    \n    // Conseil Before\n    @Before(\"serviceMethods()\")\n    public void logBefore(JoinPoint joinPoint) {\n        System.out.println(\"Avant l'exécution de: \" + joinPoint.getSignature().getName());\n    }\n    \n    // Conseil Around\n    @Around(\"@annotation(com.example.annotation.LogExecutionTime)\")\n    public Object logExecutionTime(ProceedingJoinPoint joinPoint) throws Throwable {\n        long start = System.currentTimeMillis();\n        \n        Object result = joinPoint.proceed();\n        \n        long end = System.currentTimeMillis();\n        System.out.println(\"Temps pris: \" + (end - start) + \"ms\");\n        \n        return result;\n    }\n}"
        }
      ]
    },
    {
      "title": "ApplicationContext",
      "multi-content": [
        {
          "title": "description",
          "simple-content": "Un conteneur IoC avancé qui fournit des fonctionnalités de niveau entreprise au-delà de la gestion de base des beans."
        },
        {
          "title": "definition",
          "simple-content": "Une interface centrale qui fournit la configuration pour une application, représentant le conteneur IoC Spring et responsable de l'instanciation, de la configuration et de l'assemblage des beans."
        },
        {
          "title": "key_features",
          "multi-content": [
            "Étend BeanFactory avec des fonctionnalités d'entreprise",
            "Fournit un mécanisme de publication d'événements",
            "Prend en charge l'internationalisation (i18n)",
            "Capacités de chargement de ressources",
            "Intégration avec AOP",
            "Initialisation avide des beans"
          ]
        },
        {
          "title": "context_types",
          "multi-content": [
            {
              "title": "AnnotationConfigApplicationContext",
              "simple-content": "Pour la configuration basée sur Java"
            },
            {
              "title": "ClassPathXmlApplicationContext",
              "simple-content": "Pour la configuration XML chargée depuis le classpath"
            },
            {
              "title": "FileSystemXmlApplicationContext",
              "simple-content": "Pour la configuration XML chargée depuis le système de fichiers"
            },
            {
              "title": "WebApplicationContext",
              "simple-content": "Pour les applications web"
            }
          ]
        },
        {
          "title": "vs_beanfactory",
          "multi-content": [
            {
              "title": "Bean Instantiation",
              "multi-content": [
                {
                  "title": "beanFactory",
                  "simple-content": "Paresseux (sur demande)"
                },
                {
                  "title": "applicationContext",
                  "simple-content": "Avide (au démarrage)"
                }
              ]
            },
            {
              "title": "Event Publication",
              "multi-content": [
                {
                  "title": "beanFactory",
                  "simple-content": "Non pris en charge"
                },
                {
                  "title": "applicationContext",
                  "simple-content": "Pris en charge"
                }
              ]
            },
            {
              "title": "Resource Access",
              "multi-content": [
                {
                  "title": "beanFactory",
                  "simple-content": "Limité"
                },
                {
                  "title": "applicationContext",
                  "simple-content": "Amélioré"
                }
              ]
            }
          ]
        },
        {
          "title": "examples",
          "multi-content": [
            {
              "title": "creating_context",
              "simple-content": "// À partir de la configuration Java\nApplicationContext context = new AnnotationConfigApplicationContext(AppConfig.class);\n\n// À partir de XML\nApplicationContext context = new ClassPathXmlApplicationContext(\"applicationContext.xml\");"
            },
            {
              "title": "getting_beans",
              "simple-content": "// Par type\nUserService userService = context.getBean(UserService.class);\n\n// Par nom\nUserRepository userRepository = (UserRepository) context.getBean(\"userRepository\");\n\n// Par nom et type\nDataSource dataSource = context.getBean(\"primaryDataSource\", DataSource.class);"
            }
          ]
        }
      ]
    },
    {
      "title": "SpringBootVsFramework",
      "multi-content": [
        {
          "title": "description",
          "simple-content": "Comprendre les différences entre Spring Boot et le framework Spring Core aide à clarifier leur relation et leurs cas d'utilisation."
        },
        {
          "title": "definition",
          "simple-content": "Spring Boot est un framework prescriptif construit sur Spring qui simplifie le développement d'applications en fournissant une auto-configuration, des dépendances starter et des serveurs embarqués, réduisant significativement la configuration boilerplate."
        },
        {
          "title": "key_differences",
          "multi-content": [
            {
              "title": "Configuration",
              "multi-content": [
                {
                  "title": "spring_framework",
                  "simple-content": "Configuration explicite et manuelle requise"
                },
                {
                  "title": "spring_boot",
                  "simple-content": "Auto-configuration avec des valeurs par défaut sensées"
                }
              ]
            },
            {
              "title": "Setup",
              "multi-content": [
                {
                  "title": "spring_framework",
                  "simple-content": "Plus de code boilerplate, plusieurs fichiers de configuration"
                },
                {
                  "title": "spring_boot",
                  "simple-content": "Code de configuration minimal, convention plutôt que configuration"
                }
              ]
            },
            {
              "title": "Deployment",
              "multi-content": [
                {
                  "title": "spring_framework",
                  "simple-content": "Déploiement WAR traditionnel ou application autonome"
                },
                {
                  "title": "spring_boot",
                  "simple-content": "Serveur embarqué, JAR autonome avec tout inclus"
                }
              ]
            },
            {
              "title": "Dependencies",
              "multi-content": [
                {
                  "title": "spring_framework",
                  "simple-content": "Gestion manuelle des dépendances et coordination des versions"
                },
                {
                  "title": "spring_boot",
                  "simple-content": "Dépendances starter avec des ensembles de versions compatibles et testées"
                }
              ]
            }
          ]
        },
        {
          "title": "spring_boot_features",
          "multi-content": [
            {
              "title": "Auto-configuration",
              "simple-content": "Configure automatiquement les beans en fonction des dépendances du classpath"
            },
            {
              "title": "Starter Dependencies",
              "simple-content": "Ensembles organisés de dépendances pour les cas d'utilisation courants"
            },
            {
              "title": "Embedded Servers",
              "simple-content": "Serveurs d'applications intégrés pour un déploiement simple"
            },
            {
              "title": "Actuator",
              "simple-content": "Fonctionnalités prêtes pour la production pour surveiller et gérer les applications"
            }
          ]
        },
        {
          "title": "examples",
          "multi-content": [
            {
              "title": "spring_framework_config",
              "simple-content": "// Spring Framework - configuration explicite de ViewResolver\n@Configuration\npublic class WebConfig implements WebMvcConfigurer {\n    @Bean\n    public ViewResolver viewResolver() {\n        InternalResourceViewResolver resolver = new InternalResourceViewResolver();\n        resolver.setPrefix(\"/WEB-INF/views/\");\n        resolver.setSuffix(\".jsp\");\n        return resolver;\n    }\n    // Beaucoup plus de beans...\n}"
            },
            {
              "title": "spring_boot_config",
              "simple-content": "// Spring Boot - l'auto-configuration s'en occupe\n@SpringBootApplication\npublic class Application {\n    public static void main(String[] args) {\n        SpringApplication.run(Application.class, args);\n    }\n    // C'est tout! Configuration via application.properties\n}"
            }
          ]
        }
      ]
    },
    {
      "title": "SpringExceptions",
      "multi-content": [
        {
          "title": "description",
          "simple-content": "Comprendre les exceptions Spring courantes et comment les dépanner efficacement."
        },
        {
          "title": "key_exceptions",
          "multi-content": [
            {
              "title": "NoSuchBeanDefinitionException",
              "multi-content": [
                {
                  "title": "description",
                  "simple-content": "Se produit lorsque Spring ne trouve pas de bean du type ou du nom demandé"
                },
                {
                  "title": "causes",
                  "multi-content": [
                    "Configuration de scan de composants manquante",
                    "Bean non correctement défini",
                    "Bean en dehors des packages scannés",
                    "Mauvais qualificateur ou nom spécifié",
                    "Bean non actif sous le profil actuel"
                  ]
                },
                {
                  "title": "resolution",
                  "multi-content": [
                    "Vérifier la configuration du scan de composants",
                    "S'assurer que le bean est correctement annoté ou défini",
                    "Vérifier la structure des packages",
                    "Vérifier la configuration du profil"
                  ]
                }
              ]
            },
            {
              "title": "UnsatisfiedDependencyException",
              "multi-content": [
                {
                  "title": "description",
                  "simple-content": "Se produit lorsque les dépendances d'un bean ne peuvent pas être résolues"
                },
                {
                  "title": "causes",
                  "multi-content": [
                    "Bean de dépendance manquant",
                    "Dépendances ambiguës sans désambiguïsation appropriée",
                    "Dépendances circulaires avec l'injection par constructeur",
                    "Incompatibilité de type dans la dépendance"
                  ]
                },
                {
                  "title": "resolution",
                  "multi-content": [
                    "S'assurer que toutes les dépendances sont disponibles",
                    "Utiliser @Qualifier ou @Primary pour la désambiguïsation",
                    "Vérifier les dépendances circulaires",
                    "Vérifier la compatibilité des types"
                  ]
                }
              ]
            },
            {
              "title": "BeanCreationException",
              "multi-content": [
                {
                  "title": "description",
                  "simple-content": "Se produit pendant le processus d'instanciation des beans"
                },
                {
                  "title": "causes",
                  "multi-content": [
                    "Exception dans le constructeur du bean",
                    "Exception dans la méthode @PostConstruct",
                    "Erreur d'initialisation du bean",
                    "Dépendances circulaires"
                  ]
                },
                {
                  "title": "resolution",
                  "multi-content": [
                    "Vérifier les exceptions dans l'initialisation du bean",
                    "Déboguer les méthodes d'initialisation",
                    "Rechercher les dépendances circulaires",
                    "Examiner les exceptions imbriquées"
                  ]
                }
              ]
            },
            {
              "title": "BeanCurrentlyInCreationException",
              "multi-content": [
                {
                  "title": "description",
                  "simple-content": "Se produit avec des dépendances circulaires"
                },
                {
                  "title": "causes",
                  "multi-content": [
                    "Dépendances circulaires avec l'injection par constructeur"
                  ]
                },
                {
                  "title": "resolution",
                  "multi-content": [
                    "Redessiner les composants pour éliminer la dépendance circulaire",
                    "Utiliser l'injection par setter au lieu de l'injection par constructeur",
                    "Utiliser l'annotation @Lazy sur l'une des dépendances"
                  ]
                }
              ]
            }
          ]
        },
        {
          "title": "troubleshooting_approaches",
          "multi-content": [
            {
              "title": "Read the Stack Trace",
              "simple-content": "Examiner attentivement le message d'exception et la trace de la pile"
            },
            {
              "title": "Enable Debug Logging",
              "simple-content": "Augmenter le niveau de journalisation pour obtenir plus d'informations"
            },
            {
              "title": "Use ApplicationContext Events",
              "simple-content": "Écouter les événements du contexte pour identifier les problèmes"
            },
            {
              "title": "Inspect Bean Definitions",
              "simple-content": "Inspecter programmatiquement les définitions de beans"
            }
          ]
        }
      ]
    }
  ]
}