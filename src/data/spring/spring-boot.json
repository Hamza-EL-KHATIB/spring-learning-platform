{
  "id": "spring-boot-concepts",
  "title": "Spring Boot Concepts",
  "topics": [
    {
      "title": "Overview",
      "multi-content": [
        {
          "title": "description",
          "simple-content": "Spring Boot is a framework that simplifies Spring application development by providing auto-configuration, embedded servers, and production-ready features. It maintains Spring's flexibility while reducing redundant configuration code."
        },
        {
          "title": "key_features",
          "multi-content": [
            {
              "title": "Auto-Configuration",
              "multi-content": [
                {
                  "title": "purpose",
                  "simple-content": "Automatically configure beans based on classpath"
                },
                {
                  "title": "relevance",
                  "simple-content": "★★★★★"
                }
              ]
            },
            {
              "title": "Starter Dependencies",
              "multi-content": [
                {
                  "title": "purpose",
                  "simple-content": "Simplified dependency management"
                },
                {
                  "title": "relevance",
                  "simple-content": "★★★★★"
                }
              ]
            },
            {
              "title": "Embedded Servers",
              "multi-content": [
                {
                  "title": "purpose",
                  "simple-content": "Run applications without deployment to external server"
                },
                {
                  "title": "relevance",
                  "simple-content": "★★★★☆"
                }
              ]
            },
            {
              "title": "Externalized Configuration",
              "multi-content": [
                {
                  "title": "purpose",
                  "simple-content": "Easily manage different environments"
                },
                {
                  "title": "relevance",
                  "simple-content": "★★★★☆"
                }
              ]
            },
            {
              "title": "Spring Boot Actuator",
              "multi-content": [
                {
                  "title": "purpose",
                  "simple-content": "Monitoring and metrics"
                },
                {
                  "title": "relevance",
                  "simple-content": "★★★☆☆"
                }
              ]
            },
            {
              "title": "Development Tools",
              "multi-content": [
                {
                  "title": "purpose",
                  "simple-content": "Improve the development experience"
                },
                {
                  "title": "relevance",
                  "simple-content": "★★☆☆☆"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "title": "Auto-Configuration",
      "multi-content": [
        {
          "title": "description",
          "simple-content": "Auto-configuration is Spring Boot's approach to automatically configure components based on what's available in the classpath, thus reducing manual configuration."
        },
        {
          "title": "key_mechanisms",
          "multi-content": [
            "Conditional Configuration: Spring Boot evaluates conditions before applying configurations",
            "Component Scanning: Automatically discovers beans from predefined packages",
            "Property Resolution: Uses conventions and sensible default values"
          ]
        },
        {
          "title": "conditional_annotations",
          "multi-content": [
            {
              "title": "code_examples",
              "multi-content": [
                {
                  "title": "conditional_on_class",
                  "simple-content": "// Only configure if DataSource class is in the classpath\n@ConditionalOnClass(DataSource.class)"
                },
                {
                  "title": "conditional_on_missing_bean",
                  "simple-content": "// Only configure if no existing bean of this type exists\n@ConditionalOnMissingBean(DataSource.class)"
                },
                {
                  "title": "conditional_on_property",
                  "simple-content": "// Only configure if a specific property exists with a given value\n@ConditionalOnProperty(prefix=\"app\", name=\"feature\", havingValue=\"true\")"
                },
                {
                  "title": "conditional_on_web_application",
                  "simple-content": "// Only configure for web applications\n@ConditionalOnWebApplication(type = Type.SERVLET)"
                }
              ]
            }
          ]
        },
        {
          "title": "how_it_works",
          "multi-content": [
            "Spring Boot loads all META-INF/spring.factories or META-INF/spring/org.springframework.boot.autoconfigure.AutoConfiguration.imports files",
            "These files list auto-configuration classes",
            "Each auto-configuration class is conditionally applied based on conditions",
            "Configuration is applied in a specific order respecting dependencies"
          ]
        },
        {
          "title": "disabling_auto_configuration",
          "multi-content": [
            {
              "title": "code_examples",
              "multi-content": [
                {
                  "title": "via_annotation",
                  "simple-content": "// Exclude specific auto-configuration classes\n@SpringBootApplication(exclude = {DataSourceAutoConfiguration.class})"
                },
                {
                  "title": "via_properties",
                  "simple-content": "// Using properties file\nspring.autoconfigure.exclude=org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "title": "Starter Dependencies",
      "multi-content": [
        {
          "title": "description",
          "simple-content": "Spring Boot starters are dependency descriptors that bundle related dependencies, making it easier to add common functionality."
        },
        {
          "title": "main_starters",
          "multi-content": [
            {
              "title": "spring-boot-starter-web",
              "multi-content": [
                {
                  "title": "purpose",
                  "simple-content": "Web applications"
                },
                {
                  "title": "key_components",
                  "simple-content": "Spring MVC, Tomcat, Jackson"
                }
              ]
            },
            {
              "title": "spring-boot-starter-data-jpa",
              "multi-content": [
                {
                  "title": "purpose",
                  "simple-content": "JPA persistence"
                },
                {
                  "title": "key_components",
                  "simple-content": "Hibernate, Spring Data JPA"
                }
              ]
            },
            {
              "title": "spring-boot-starter-security",
              "multi-content": [
                {
                  "title": "purpose",
                  "simple-content": "Authentication & Authorization"
                },
                {
                  "title": "key_components",
                  "simple-content": "Spring Security"
                }
              ]
            },
            {
              "title": "spring-boot-starter-test",
              "multi-content": [
                {
                  "title": "purpose",
                  "simple-content": "Testing"
                },
                {
                  "title": "key_components",
                  "simple-content": "JUnit, Mockito, Spring Test"
                }
              ]
            }
          ]
        },
        {
          "title": "creating_custom_starters",
          "multi-content": [
            {
              "title": "description",
              "simple-content": "Custom starters follow a naming convention and structure: 'your-starter' contains dependency management and 'your-starter-autoconfigure' contains auto-configuration code."
            },
            {
              "title": "example",
              "simple-content": "// Example auto-configuration class\n@Configuration\n@ConditionalOnClass(YourService.class)\n@EnableConfigurationProperties(YourProperties.class)\npublic class YourAutoConfiguration {\n    \n    @Bean\n    @ConditionalOnMissingBean\n    public YourService yourService(YourProperties properties) {\n        return new YourServiceImpl(properties.getConfig());\n    }\n}"
            }
          ]
        }
      ]
    },
    {
      "title": "SpringApplicationConfiguration",
      "multi-content": [
        {
          "title": "description",
          "simple-content": "The configuration of a Spring Boot application, centered around the @SpringBootApplication annotation."
        },
        {
          "title": "springboot_application_annotation",
          "multi-content": [
            {
              "title": "description",
              "simple-content": "It's a convenience annotation that combines @Configuration (marks the class as a source of bean definitions), @EnableAutoConfiguration (enables Spring Boot's auto-configuration), and @ComponentScan (scans for components in the current package and below)."
            },
            {
              "title": "example",
              "simple-content": "@SpringBootApplication\npublic class MyApplication {\n    public static void main(String[] args) {\n        SpringApplication.run(MyApplication.class, args);\n    }\n}"
            }
          ]
        }
      ]
    },
    {
      "title": "SpringApplicationStartup",
      "multi-content": [
        {
          "title": "description",
          "simple-content": "The detailed process of what happens when a Spring Boot application starts up, from JVM loading the main class to the application being ready to process requests."
        },
        {
          "title": "startup_phases",
          "multi-content": [
            {
              "title": "Bootstrap & Environment Preparation",
              "multi-content": [
                "Loading Main Class: JVM loads the class with @SpringBootApplication",
                "SpringApplication.run: Creates and configures the Spring application",
                "Loading Environment Properties: Loads from various sources (system properties, environment variables, application.properties)",
                "Creating ApplicationContext: Creates the appropriate ApplicationContext implementation",
                "Preparing ApplicationContext: Sets the environment, registers post-processors"
              ]
            },
            {
              "title": "Loading Bean Definitions",
              "multi-content": [
                "Loading Bean Definitions: From classpath scanning, XML, or Java @Configuration",
                "Processing @Configuration Classes: Processes @Bean methods and registers bean definitions",
                "Registering BeanFactoryPostProcessors: For additional modifications to bean definitions"
              ]
            },
            {
              "title": "BeanFactory Post-Processing",
              "multi-content": [
                "Executing BeanFactoryPostProcessors: Custom processors can modify bean definitions before instantiation",
                "Registering BeanPostProcessors: For post-instantiation bean processing"
              ]
            },
            {
              "title": "Bean Instantiation",
              "multi-content": [
                "Instantiating Non-Lazy Singleton Beans: Creates all singleton beans eagerly",
                "Injecting Dependencies: Resolves dependencies and injects them",
                "Applying BeanPostProcessors Before Init: Executes postProcessBeforeInitialization",
                "Executing @PostConstruct methods: Custom initialization code",
                "Executing InitializingBean.afterPropertiesSet(): Alternative initialization mechanism",
                "Applying BeanPostProcessors After Init: Executes postProcessAfterInitialization (proxies are often created here)"
              ]
            },
            {
              "title": "Final Initialization",
              "multi-content": [
                "Executing ApplicationContext Refresh Callbacks: Final initialization steps",
                "Starting Embedded Server: If applicable (for web applications)",
                "Publishing ApplicationStartedEvent: Application is fully started but not ready",
                "Executing ApplicationRunners & CommandLineRunners: Custom startup code",
                "Publishing ApplicationReadyEvent: Application is ready to serve requests"
              ]
            }
          ]
        }
      ]
    },
    {
      "title": "SpringIoCContainerInternals",
      "multi-content": [
        {
          "title": "description",
          "simple-content": "The internal components and design of the Spring IoC container that enable dependency injection and bean management."
        },
        {
          "title": "main_components",
          "multi-content": [
            {
              "title": "BeanFactory",
              "multi-content": [
                {
                  "title": "description",
                  "simple-content": "The central interface of the Spring container, providing basic DI support"
                },
                {
                  "title": "features",
                  "multi-content": [
                    "Implementation of the Factory pattern for bean management",
                    "Lazy loading of beans (initialized on demand)",
                    "Core container functionality without enterprise features"
                  ]
                }
              ]
            },
            {
              "title": "ApplicationContext",
              "multi-content": [
                {
                  "title": "description",
                  "simple-content": "Enhanced container with enterprise features"
                },
                {
                  "title": "features",
                  "multi-content": [
                    "Extends BeanFactory with additional functionality",
                    "Event publication",
                    "Resource access",
                    "Internationalization support",
                    "Eager initialization of singleton beans"
                  ]
                }
              ]
            },
            {
              "title": "BeanDefinition",
              "multi-content": [
                {
                  "title": "description",
                  "simple-content": "A blueprint for creating beans"
                },
                {
                  "title": "features",
                  "multi-content": [
                    "Contains bean metadata (class, scope, dependencies)",
                    "Used by the container to create and configure beans",
                    "Can be modified by BeanFactoryPostProcessors"
                  ]
                }
              ]
            },
            {
              "title": "BeanPostProcessor",
              "multi-content": [
                {
                  "title": "description",
                  "simple-content": "Interface for customizing bean instances"
                },
                {
                  "title": "features",
                  "multi-content": [
                    "Intercepts the bean creation process",
                    "Modifies beans before and after initialization",
                    "Key component for AOP implementation"
                  ]
                }
              ]
            },
            {
              "title": "BeanFactoryPostProcessor",
              "multi-content": [
                {
                  "title": "description",
                  "simple-content": "Interface for customizing bean definitions"
                },
                {
                  "title": "features",
                  "multi-content": [
                    "Modifies bean definitions before bean instantiation",
                    "Used to change bean metadata",
                    "Example: PropertyPlaceholderConfigurer"
                  ]
                }
              ]
            },
            {
              "title": "Environment",
              "multi-content": [
                {
                  "title": "description",
                  "simple-content": "Abstraction for the application environment"
                },
                {
                  "title": "features",
                  "multi-content": [
                    "Represents profiles and properties",
                    "Centralizes access to configuration",
                    "Source of external configuration data"
                  ]
                }
              ]
            }
          ]
        },
        {
          "title": "design_patterns",
          "multi-content": [
            "Factory Pattern: BeanFactory creates beans",
            "Singleton Pattern: Default scope for beans",
            "Prototype Pattern: New instance on each request",
            "Observer Pattern: Event publishing mechanism",
            "Template Method Pattern: Managing component lifecycle"
          ]
        }
      ]
    },
    {
      "title": "ExternalizedConfiguration",
      "multi-content": [
        {
          "title": "description",
          "simple-content": "Spring Boot provides multiple options for configuring applications outside of code, allowing configuration changes without recompilation."
        },
        {
          "title": "configuration_sources",
          "multi-content": [
            "Command line arguments (highest priority)",
            "OS environment variables",
            "application-{profile}.properties or YAML",
            "application.properties or YAML (inside or outside the application)",
            "@PropertySource annotations",
            "Default properties (lowest priority)"
          ]
        },
        {
          "title": "property_files",
          "multi-content": [
            {
              "title": "properties_example",
              "simple-content": "# application.properties example\nserver.port=8080\nspring.datasource.url=jdbc:mysql://localhost/db\nspring.datasource.username=root\nspring.datasource.password=password\napp.feature.enabled=true"
            },
            {
              "title": "yaml_example",
              "simple-content": "# equivalent application.yml\nserver:\n  port: 8080\nspring:\n  datasource:\n    url: jdbc:mysql://localhost/db\n    username: root\n    password: password\napp:\n  feature:\n    enabled: true"
            }
          ]
        },
        {
          "title": "configuration_properties",
          "multi-content": [
            {
              "title": "description",
              "simple-content": "Type-safe configuration binding with Java objects"
            },
            {
              "title": "example",
              "simple-content": "@ConfigurationProperties(prefix = \"app.feature\")\n@Component\npublic class FeatureProperties {\n    private boolean enabled = false;\n    private String name;\n    private List<String> options = new ArrayList<>();\n    \n    // Getters and setters\n}"
            }
          ]
        },
        {
          "title": "environment_profiles",
          "multi-content": [
            {
              "title": "description",
              "simple-content": "Profiles allow environment-specific configuration"
            },
            {
              "title": "profile_activation",
              "multi-content": [
                {
                  "title": "code_examples",
                  "multi-content": [
                    {
                      "title": "via_annotation",
                      "simple-content": "// Activating profiles\n@Profile(\"dev\")\n@Configuration\npublic class DevConfig {\n    // Dev-specific beans\n}"
                    },
                    {
                      "title": "via_properties",
                      "simple-content": "// In properties file\nspring.profiles.active=dev"
                    },
                    {
                      "title": "via_command_line",
                      "simple-content": "// Via command line\n--spring.profiles.active=dev,local"
                    }
                  ]
                }
              ]
            },
            {
              "title": "profile_specific_files",
              "multi-content": [
                "application-dev.properties",
                "application-prod.properties"
              ]
            }
          ]
        }
      ]
    },
    {
      "title": "WebApplications",
      "multi-content": [
        {
          "title": "description",
          "simple-content": "Spring Boot simplifies the development of web applications with auto-configuration for web environments and easy REST endpoint creation."
        },
        {
          "title": "rest_controllers",
          "multi-content": [
            {
              "title": "description",
              "simple-content": "REST controllers in Spring Boot handle HTTP requests and return responses, often as JSON."
            },
            {
              "title": "example",
              "simple-content": "@RestController\n@RequestMapping(\"/api/users\")\npublic class UserController {\n    \n    private final UserService userService;\n    \n    public UserController(UserService userService) {\n        this.userService = userService;\n    }\n    \n    @GetMapping\n    public List<User> getAllUsers() {\n        return userService.findAll();\n    }\n    \n    @GetMapping(\"/{id}\")\n    public User getUser(@PathVariable Long id) {\n        return userService.findById(id)\n            .orElseThrow(() -> new ResourceNotFoundException(\"User not found\"));\n    }\n    \n    @PostMapping\n    @ResponseStatus(HttpStatus.CREATED)\n    public User createUser(@Valid @RequestBody UserDto userDto) {\n        return userService.create(userDto);\n    }\n    \n    @PutMapping(\"/{id}\")\n    public User updateUser(@PathVariable Long id, @Valid @RequestBody UserDto userDto) {\n        return userService.update(id, userDto);\n    }\n    \n    @DeleteMapping(\"/{id}\")\n    @ResponseStatus(HttpStatus.NO_CONTENT)\n    public void deleteUser(@PathVariable Long id) {\n        userService.delete(id);\n    }\n}"
            }
          ]
        },
        {
          "title": "request_handling",
          "multi-content": [
            {
              "title": "GetMapping",
              "simple-content": "Handle HTTP GET requests"
            },
            {
              "title": "PostMapping",
              "simple-content": "Handle HTTP POST requests"
            },
            {
              "title": "PutMapping",
              "simple-content": "Handle HTTP PUT requests"
            },
            {
              "title": "DeleteMapping",
              "simple-content": "Handle HTTP DELETE requests"
            },
            {
              "title": "PatchMapping",
              "simple-content": "Handle HTTP PATCH requests"
            },
            {
              "title": "RequestMapping",
              "simple-content": "Generic request mapping"
            }
          ]
        },
        {
          "title": "parameter_binding",
          "multi-content": [
            {
              "title": "PathVariable",
              "multi-content": [
                {
                  "title": "purpose",
                  "simple-content": "Extract values from URI path"
                },
                {
                  "title": "example",
                  "simple-content": "@GetMapping(\"/{id}\")"
                }
              ]
            },
            {
              "title": "RequestParam",
              "multi-content": [
                {
                  "title": "purpose",
                  "simple-content": "Extract query parameters"
                },
                {
                  "title": "example",
                  "simple-content": "@RequestParam String sort"
                }
              ]
            },
            {
              "title": "RequestBody",
              "multi-content": [
                {
                  "title": "purpose",
                  "simple-content": "Extract and convert request body"
                },
                {
                  "title": "example",
                  "simple-content": "@RequestBody UserDto user"
                }
              ]
            },
            {
              "title": "RequestHeader",
              "multi-content": [
                {
                  "title": "purpose",
                  "simple-content": "Extract header values"
                },
                {
                  "title": "example",
                  "simple-content": "@RequestHeader String authorization"
                }
              ]
            }
          ]
        },
        {
          "title": "exception_handling",
          "multi-content": [
            {
              "title": "description",
              "simple-content": "Centralized exception handling with @ControllerAdvice"
            },
            {
              "title": "example",
              "simple-content": "@RestControllerAdvice\npublic class GlobalExceptionHandler {\n    \n    @ExceptionHandler(ResourceNotFoundException.class)\n    @ResponseStatus(HttpStatus.NOT_FOUND)\n    public ErrorResponse handleResourceNotFound(ResourceNotFoundException ex) {\n        return new ErrorResponse(ex.getMessage());\n    }\n    \n    @ExceptionHandler(MethodArgumentNotValidException.class)\n    @ResponseStatus(HttpStatus.BAD_REQUEST)\n    public ErrorResponse handleValidationErrors(MethodArgumentNotValidException ex) {\n        List<String> errors = ex.getBindingResult()\n            .getFieldErrors()\n            .stream()\n            .map(error -> error.getField() + \": \" + error.getDefaultMessage())\n            .collect(Collectors.toList());\n            \n        return new ErrorResponse(\"Validation failed\", errors);\n    }\n    \n    @ExceptionHandler(Exception.class)\n    @ResponseStatus(HttpStatus.INTERNAL_SERVER_ERROR)\n    public ErrorResponse handleGenericException(Exception ex) {\n        return new ErrorResponse(\"An unexpected error occurred\");\n    }\n}"
            }
          ]
        }
      ]
    },
    {
      "title": "GraphQLWithSpringBoot",
      "multi-content": [
        {
          "title": "description",
          "simple-content": "Spring Boot supports GraphQL API development with the spring-boot-starter-graphql dependency, enabling declarative schema-based API creation."
        },
        {
          "title": "basic_configuration",
          "multi-content": [
            {
              "title": "code_examples",
              "multi-content": [
                {
                  "title": "schema",
                  "simple-content": "// GraphQL Schema (.graphqls file)\ntype Query {\n  userById(id: ID!): User\n  allUsers: [User]\n}\n\ntype User {\n  id: ID!\n  name: String!\n  email: String!\n}"
                },
                {
                  "title": "controller",
                  "simple-content": "// Controller Implementation\n@Controller\npublic class UserGraphQLController {\n    private final UserService userService;\n    \n    public UserGraphQLController(UserService userService) {\n        this.userService = userService;\n    }\n    \n    @QueryMapping\n    public User userById(@Argument Long id) {\n        return userService.findById(id)\n            .orElseThrow(() -> new ResourceNotFoundException(\"User not found\"));\n    }\n    \n    @QueryMapping\n    public List<User> allUsers() {\n        return userService.findAll();\n    }\n}"
                }
              ]
            }
          ]
        },
        {
          "title": "n_plus_1_problem",
          "multi-content": [
            {
              "title": "description",
              "simple-content": "The N+1 problem occurs when retrieving a list of entities and their relationships: 1 query to fetch all users + N queries to fetch each user's orders"
            },
            {
              "title": "code_examples",
              "multi-content": [
                {
                  "title": "solution",
                  "simple-content": "// Solution using DataLoader\n@Component\npublic class OrdersDataLoader {\n    private final DataLoader<Long, List<Order>> dataLoader;\n    \n    public OrdersDataLoader(OrderRepository orderRepository) {\n        this.dataLoader = DataLoader.newMappedDataLoader(userIds -> {\n            Map<Long, List<Order>> ordersByUserId = orderRepository.findAllByUserIdIn(userIds)\n                .stream()\n                .collect(Collectors.groupingBy(Order::getUserId));\n            \n            return CompletableFuture.supplyAsync(() -> userIds.stream()\n                .collect(Collectors.toMap(\n                    id -> id,\n                    id -> ordersByUserId.getOrDefault(id, Collections.emptyList())\n                )));\n        });\n    }\n    \n    public DataLoader<Long, List<Order>> getDataLoader() {\n        return dataLoader;\n    }\n}"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "title": "DataAccessWithSpringBoot",
      "multi-content": [
        {
          "title": "description",
          "simple-content": "Spring Boot simplifies data access with Spring Data repositories, providing automatic CRUD operations and the ability to create custom queries with minimal boilerplate."
        },
        {
          "title": "spring_data_repositories",
          "multi-content": [
            {
              "title": "description",
              "simple-content": "Spring Boot auto-configures Spring Data repositories based on classpath dependencies."
            },
            {
              "title": "example",
              "simple-content": "// Simple repository interface\npublic interface UserRepository extends JpaRepository<User, Long> {\n    \n    // Derived query methods\n    Optional<User> findByEmail(String email);\n    \n    List<User> findByLastNameOrderByFirstNameAsc(String lastName);\n    \n    // Custom query\n    @Query(\"SELECT u FROM User u WHERE u.status = :status\")\n    List<User> findAllByStatus(@Param(\"status\") UserStatus status);\n    \n    // Native query\n    @Query(value = \"SELECT * FROM users WHERE created_date > :date\", \n           nativeQuery = true)\n    List<User> findRecentUsers(@Param(\"date\") LocalDate date);\n    \n    // Modifying query\n    @Modifying\n    @Transactional\n    @Query(\"UPDATE User u SET u.status = :status WHERE u.id = :id\")\n    int updateUserStatus(@Param(\"id\") Long id, @Param(\"status\") UserStatus status);\n}"
            }
          ]
        },
        {
          "title": "transaction_management",
          "multi-content": [
            {
              "title": "description",
              "simple-content": "Spring Boot provides declarative transaction management with @Transactional."
            },
            {
              "title": "example",
              "simple-content": "@Service\npublic class UserService {\n    \n    private final UserRepository userRepository;\n    \n    public UserService(UserRepository userRepository) {\n        this.userRepository = userRepository;\n    }\n    \n    @Transactional\n    public User updateUserProfile(Long userId, ProfileUpdate update) {\n        User user = userRepository.findById(userId)\n            .orElseThrow(() -> new ResourceNotFoundException(\"User not found\"));\n            \n        user.setFirstName(update.getFirstName());\n        user.setLastName(update.getLastName());\n        user.setEmail(update.getEmail());\n        \n        // No need for explicit save() call with managed entities\n        return user;\n    }\n    \n    @Transactional(readOnly = true)\n    public List<User> findAllActiveUsers() {\n        return userRepository.findAllByStatus(UserStatus.ACTIVE);\n    }\n    \n    @Transactional(propagation = Propagation.REQUIRES_NEW)\n    public void processImportantTask() {\n        // This executes in a new transaction\n    }\n}"
            }
          ]
        },
        {
          "title": "jpa_configuration",
          "multi-content": [
            {
              "title": "description",
              "simple-content": "Spring Boot automatically configures most JPA settings when spring-boot-starter-data-jpa is present."
            },
            {
              "title": "code_examples",
              "multi-content": [
                {
                  "title": "properties",
                  "simple-content": "# Database connection settings\nspring.datasource.url=jdbc:mysql://localhost:3306/mydb\nspring.datasource.username=root\nspring.datasource.password=password\nspring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver\n\n# JPA/Hibernate properties\nspring.jpa.hibernate.ddl-auto=update\nspring.jpa.show-sql=true\nspring.jpa.properties.hibernate.format_sql=true\nspring.jpa.properties.hibernate.dialect=org.hibernate.dialect.MySQL8Dialect"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "title": "AuthenticationWithKeycloak",
      "multi-content": [
        {
          "title": "description",
          "simple-content": "Spring Boot integrates with Keycloak to provide OAuth2 and OpenID Connect authentication for applications, enabling Single Sign-On (SSO) capabilities."
        },
        {
          "title": "configuration",
          "multi-content": [
            {
              "title": "code_examples",
              "multi-content": [
                {
                  "title": "security_config",
                  "simple-content": "// Keycloak Configuration\n@Configuration\n@EnableWebSecurity\npublic class SecurityConfig extends WebSecurityConfigurerAdapter {\n\n    @Override\n    protected void configure(HttpSecurity http) throws Exception {\n        http.authorizeRequests()\n            .antMatchers(\"/public/**\").permitAll()\n            .anyRequest().authenticated()\n            .and()\n            .oauth2Login()\n            .and()\n            .oauth2ResourceServer().jwt();\n    }\n}"
                },
                {
                  "title": "properties",
                  "simple-content": "// application.properties\nspring.security.oauth2.client.registration.keycloak.client-id=my-client\nspring.security.oauth2.client.registration.keycloak.client-secret=my-secret\nspring.security.oauth2.client.registration.keycloak.scope=openid,profile,email\nspring.security.oauth2.client.provider.keycloak.issuer-uri=https://keycloak-server/auth/realms/my-realm\nspring.security.oauth2.resourceserver.jwt.issuer-uri=https://keycloak-server/auth/realms/my-realm"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "title": "FeignClient",
      "multi-content": [
        {
          "title": "description",
          "simple-content": "Feign is a declarative HTTP client used in Spring Cloud to simplify HTTP API calls between microservices."
        },
        {
          "title": "basic_configuration",
          "multi-content": [
            {
              "title": "code_examples",
              "multi-content": [
                {
                  "title": "application_config",
                  "simple-content": "// Enable Feign Clients in your application\n@SpringBootApplication\n@EnableFeignClients\npublic class MyServiceApplication {\n    public static void main(String[] args) {\n        SpringApplication.run(MyServiceApplication.class, args);\n    }\n}"
                },
                {
                  "title": "client_interface",
                  "simple-content": "// Define a Feign client interface\n@FeignClient(name = \"user-service\", url = \"${user-service.url}\")\npublic interface UserClient {\n    \n    @GetMapping(\"/users/{id}\")\n    User getUserById(@PathVariable(\"id\") Long id);\n    \n    @PostMapping(\"/users\")\n    User createUser(@RequestBody UserDto userDto);\n    \n    @GetMapping(\"/users\")\n    List<User> getAllUsers();\n}"
                },
                {
                  "title": "usage",
                  "simple-content": "// Use the client in a service\n@Service\npublic class UserServiceClient {\n    \n    private final UserClient userClient;\n    \n    public UserServiceClient(UserClient userClient) {\n        this.userClient = userClient;\n    }\n    \n    public User getUserDetails(Long userId) {\n        return userClient.getUserById(userId);\n    }\n}"
                }
              ]
            }
          ]
        },
        {
          "title": "advanced_features",
          "multi-content": [
            {
              "title": "code_examples",
              "multi-content": [
                {
                  "title": "circuit_breaker",
                  "simple-content": "@FeignClient(name = \"user-service\", fallback = UserClientFallback.class)\npublic interface UserClient {\n    // methods\n}\n\n@Component\npublic class UserClientFallback implements UserClient {\n    \n    @Override\n    public User getUserById(Long id) {\n        // Return default or cached user when service is unavailable\n        return new User(id, \"Default User\", \"default@example.com\");\n    }\n    \n    // Implement other methods with fallbacks\n}\n\n// In application.properties\nfeign.circuitbreaker.enabled=true"
                },
                {
                  "title": "custom_configuration",
                  "simple-content": "@FeignClient(name = \"user-service\", configuration = UserClientConfiguration.class)\npublic interface UserClient {\n    // methods\n}\n\n@Configuration\npublic class UserClientConfiguration {\n    \n    @Bean\n    public RequestInterceptor requestInterceptor() {\n        return requestTemplate -> {\n            requestTemplate.header(\"Authorization\", \"Bearer \" + getToken());\n            requestTemplate.header(\"Accept\", \"application/json\");\n        };\n    }\n    \n    @Bean\n    public ErrorDecoder errorDecoder() {\n        return new UserServiceErrorDecoder();\n    }\n}"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "title": "StatefulVsStatelessServices",
      "multi-content": [
        {
          "title": "description",
          "simple-content": "A fundamental architectural distinction in microservice design and RESTful API development between services that maintain client state and those that don't."
        },
        {
          "title": "stateless_services",
          "multi-content": [
            {
              "title": "characteristics",
              "multi-content": [
                "Each request contains all information needed to process it",
                "No client session data is stored on the server between requests",
                "Any service instance can handle any request",
                "Easier to scale horizontally",
                "More resilient to failures"
              ]
            },
            {
              "title": "example",
              "simple-content": "// Example of a stateless REST controller\n@RestController\n@RequestMapping(\"/api/products\")\npublic class ProductController {\n    \n    private final ProductService productService;\n    \n    public ProductController(ProductService productService) {\n        this.productService = productService;\n    }\n    \n    @GetMapping(\"/{id}\")\n    public Product getProduct(@PathVariable Long id) {\n        // Each request is independent and contains all necessary info (id)\n        return productService.findById(id);\n    }\n    \n    @PostMapping\n    public Product createProduct(@RequestBody ProductDto productDto) {\n        // Request contains all information needed to create the product\n        return productService.create(productDto);\n    }\n}"
            }
          ]
        },
        {
          "title": "stateful_services",
          "multi-content": [
            {
              "title": "characteristics",
              "multi-content": [
                "The server maintains client session information between requests",
                "Clients need to interact with the same server instance or state must be shared",
                "More complex to scale horizontally",
                "More vulnerable to service failures"
              ]
            },
            {
              "title": "example",
              "simple-content": "// Example of a stateful controller (generally avoided in microservices)\n@RestController\n@RequestMapping(\"/api/cart\")\npublic class ShoppingCartController {\n    \n    // This map stores state per session - making this service stateful\n    private final Map<String, ShoppingCart> sessionCarts = new ConcurrentHashMap<>();\n    \n    @PostMapping(\"/items\")\n    public void addItem(@RequestBody CartItem item, HttpSession session) {\n        String sessionId = session.getId();\n        ShoppingCart cart = sessionCarts.computeIfAbsent(sessionId, k -> new ShoppingCart());\n        cart.addItem(item);\n        // State is stored on the server\n    }\n    \n    @GetMapping\n    public ShoppingCart getCart(HttpSession session) {\n        String sessionId = session.getId();\n        // This depends on previous state\n        return sessionCarts.getOrDefault(sessionId, new ShoppingCart());\n    }\n}"
            }
          ]
        },
        {
          "title": "making_stateful_services_scalable",
          "multi-content": [
            {
              "title": "code_examples",
              "multi-content": [
                {
                  "title": "externalize_state",
                  "simple-content": "@RestController\n@RequestMapping(\"/api/cart\")\npublic class ShoppingCartController {\n    \n    private final CartRepository cartRepository;\n    \n    public ShoppingCartController(CartRepository cartRepository) {\n        this.cartRepository = cartRepository;\n    }\n    \n    @PostMapping(\"/items\")\n    public void addItem(@RequestBody CartItem item, @RequestHeader(\"Authorization\") String token) {\n        // Extract user ID from token\n        String userId = getUserIdFromToken(token);\n        // Get cart from external datastore\n        ShoppingCart cart = cartRepository.findByUserId(userId)\n            .orElseGet(() -> new ShoppingCart(userId));\n        cart.addItem(item);\n        cartRepository.save(cart);\n    }\n}"
                },
                {
                  "title": "use_sticky_sessions",
                  "simple-content": "# Spring Session configuration for Redis\nspring.session.store-type=redis\nspring.redis.host=redis-server\nspring.redis.port=6379"
                },
                {
                  "title": "use_distributed_caching",
                  "simple-content": "@Configuration\n@EnableCaching\npublic class CacheConfig {\n    \n    @Bean\n    public CacheManager cacheManager(RedisConnectionFactory connectionFactory) {\n        RedisCacheManager cacheManager = RedisCacheManager.builder(connectionFactory)\n            .cacheDefaults(RedisCacheConfiguration.defaultCacheConfig()\n                .entryTtl(Duration.ofMinutes(10)))\n            .build();\n        return cacheManager;\n    }\n}\n\n@Service\npublic class ProductService {\n    \n    @Cacheable(value = \"products\", key = \"#id\")\n    public Product findById(Long id) {\n        // This result will be cached in Redis\n        return productRepository.findById(id).orElseThrow();\n    }\n}"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "title": "TestingInSpringBoot",
      "multi-content": [
        {
          "title": "description",
          "simple-content": "Spring Boot offers extensive testing support with auto-configuration for test environments, making it easier to test different application layers."
        },
        {
          "title": "service_unit_tests",
          "multi-content": [
            {
              "title": "description",
              "simple-content": "Testing service classes in isolation using mocks"
            },
            {
              "title": "example",
              "simple-content": "@ExtendWith(MockitoExtension.class)\nclass UserServiceTest {\n    \n    @Mock\n    private UserRepository userRepository;\n    \n    @InjectMocks\n    private UserService userService;\n    \n    @Test\n    void shouldReturnUserWhenFindById() {\n        // Given\n        Long userId = 1L;\n        User expectedUser = new User(userId, \"john@example.com\");\n        when(userRepository.findById(userId)).thenReturn(Optional.of(expectedUser));\n        \n        // When\n        User actualUser = userService.findById(userId).orElse(null);\n        \n        // Then\n        assertNotNull(actualUser);\n        assertEquals(expectedUser.getEmail(), actualUser.getEmail());\n        verify(userRepository).findById(userId);\n    }\n}"
            }
          ]
        },
        {
          "title": "controller_integration_tests",
          "multi-content": [
            {
              "title": "description",
              "simple-content": "Testing controllers with a mocked MVC environment"
            },
            {
              "title": "example",
              "simple-content": "@SpringBootTest\n@AutoConfigureMockMvc\nclass UserControllerTest {\n    \n    @Autowired\n    private MockMvc mockMvc;\n    \n    @MockBean\n    private UserService userService;\n    \n    @Test\n    void shouldReturnUserWhenGetWithValidId() throws Exception {\n        // Given\n        Long userId = 1L;\n        User user = new User(userId, \"john@example.com\");\n        when(userService.findById(userId)).thenReturn(Optional.of(user));\n        \n        // When/Then\n        mockMvc.perform(get(\"/api/users/{id}\", userId)\n            .contentType(MediaType.APPLICATION_JSON))\n            .andExpect(status().isOk())\n            .andExpect(jsonPath(\"$.id\").value(userId))\n            .andExpect(jsonPath(\"$.email\").value(\"john@example.com\"));\n    }\n    \n    @Test\n    void shouldReturnNotFoundWhenUserDoesNotExist() throws Exception {\n        // Given\n        Long userId = 999L;\n        when(userService.findById(userId)).thenReturn(Optional.empty());\n        \n        // When/Then\n        mockMvc.perform(get(\"/api/users/{id}\", userId)\n            .contentType(MediaType.APPLICATION_JSON))\n            .andExpect(status().isNotFound());\n    }\n}"
            }
          ]
        },
        {
          "title": "slice_tests",
          "multi-content": [
            {
              "title": "description",
              "simple-content": "Spring Boot provides test slices for faster, targeted testing"
            },
            {
              "title": "test_slices",
              "multi-content": [
                {
                  "title": "@WebMvcTest",
                  "multi-content": [
                    {
                      "title": "scope",
                      "simple-content": "Controllers"
                    },
                    {
                      "title": "purpose",
                      "simple-content": "Test MVC controllers without starting the full context"
                    }
                  ]
                },
                {
                  "title": "@DataJpaTest",
                  "multi-content": [
                    {
                      "title": "scope",
                      "simple-content": "JPA Repositories"
                    },
                    {
                      "title": "purpose",
                      "simple-content": "Test JPA repositories with an in-memory database"
                    }
                  ]
                },
                {
                  "title": "@JsonTest",
                  "multi-content": [
                    {
                      "title": "scope",
                      "simple-content": "JSON Serialization"
                    },
                    {
                      "title": "purpose",
                      "simple-content": "Test JSON serialization/deserialization"
                    }
                  ]
                },
                {
                  "title": "@RestClientTest",
                  "multi-content": [
                    {
                      "title": "scope",
                      "simple-content": "REST Clients"
                    },
                    {
                      "title": "purpose",
                      "simple-content": "Test REST client code"
                    }
                  ]
                }
              ]
            },
            {
              "title": "examples",
              "multi-content": [
                {
                  "title": "code_examples",
                  "multi-content": [
                    {
                      "title": "web_mvc_test",
                      "simple-content": "@WebMvcTest(UserController.class)\nclass UserControllerWebMvcTest {\n    \n    @Autowired\n    private MockMvc mockMvc;\n    \n    @MockBean\n    private UserService userService;\n    \n    // Tests similar to above example\n}"
                    },
                    {
                      "title": "data_jpa_test",
                      "simple-content": "@DataJpaTest\nclass UserRepositoryTest {\n    \n    @Autowired\n    private UserRepository userRepository;\n    \n    @Test\n    void shouldFindUserByEmail() {\n        // Given\n        String email = \"test@example.com\";\n        User user = new User();\n        user.setEmail(email);\n        userRepository.save(user);\n        \n        // When\n        Optional<User> result = userRepository.findByEmail(email);\n        \n        // Then\n        assertTrue(result.isPresent());\n        assertEquals(email, result.get().getEmail());\n    }\n}"
                    }
                  ]
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "title": "SpringBootActuator",
      "multi-content": [
        {
          "title": "description",
          "simple-content": "Spring Boot Actuator provides production-ready features for monitoring and managing applications."
        },
        {
          "title": "key_endpoints",
          "multi-content": [
            {
              "title": "/actuator/health",
              "multi-content": [
                {
                  "title": "purpose",
                  "simple-content": "Health checks"
                },
                {
                  "title": "usage",
                  "simple-content": "Monitor application health"
                }
              ]
            },
            {
              "title": "/actuator/info",
              "multi-content": [
                {
                  "title": "purpose",
                  "simple-content": "Application information"
                },
                {
                  "title": "usage",
                  "simple-content": "Custom information about the application"
                }
              ]
            },
            {
              "title": "/actuator/metrics",
              "multi-content": [
                {
                  "title": "purpose",
                  "simple-content": "Metrics"
                },
                {
                  "title": "usage",
                  "simple-content": "Various metrics about the application"
                }
              ]
            },
            {
              "title": "/actuator/env",
              "multi-content": [
                {
                  "title": "purpose",
                  "simple-content": "Environment"
                },
                {
                  "title": "usage",
                  "simple-content": "Current environment properties"
                }
              ]
            },
            {
              "title": "/actuator/loggers",
              "multi-content": [
                {
                  "title": "purpose",
                  "simple-content": "Logging"
                },
                {
                  "title": "usage",
                  "simple-content": "View and modify logging levels at runtime"
                }
              ]
            }
          ]
        },
        {
          "title": "code_examples",
          "multi-content": [
            {
              "title": "configuration",
              "simple-content": "# Enable all endpoints over HTTP\nmanagement.endpoints.web.exposure.include=*\n\n# Expose only specific endpoints\nmanagement.endpoints.web.exposure.include=health,info,metrics\n\n# Health details visibility\nmanagement.endpoint.health.show-details=always\n\n# Custom information\ninfo.app.name=${spring.application.name}\ninfo.app.version=1.0.0\ninfo.app.description=My Spring Boot Application"
            },
            {
              "title": "custom_health_indicators",
              "simple-content": "@Component\npublic class DatabaseHealthIndicator implements HealthIndicator {\n    \n    private final DataSource dataSource;\n    \n    public DatabaseHealthIndicator(DataSource dataSource) {\n        this.dataSource = dataSource;\n    }\n    \n    @Override\n    public Health health() {\n        try (Connection conn = dataSource.getConnection()) {\n            PreparedStatement ps = conn.prepareStatement(\"SELECT 1\");\n            ps.executeQuery();\n            return Health.up()\n                .withDetail(\"database\", \"Available\")\n                .build();\n        } catch (SQLException e) {\n            return Health.down()\n                .withDetail(\"database\", \"Unavailable\")\n                .withException(e)\n                .build();\n        }\n    }\n}"
            }
          ]
        }
      ]
    },
    {
      "title": "SpringBatch",
      "multi-content": [
        {
          "title": "description",
          "simple-content": "Spring Batch is a lightweight, comprehensive batch framework designed to enable the development of robust batch applications for enterprise systems."
        },
        {
          "title": "code_examples",
          "multi-content": [
            {
              "title": "basic_configuration",
              "simple-content": "@Configuration\n@EnableBatchProcessing\npublic class BatchConfig {\n    \n    @Autowired\n    private JobBuilderFactory jobBuilderFactory;\n    \n    @Autowired\n    private StepBuilderFactory stepBuilderFactory;\n    \n    @Bean\n    public Step processUsersStep(ItemReader<User> reader, ItemProcessor<User, User> processor, \n                               ItemWriter<User> writer) {\n        return stepBuilderFactory.get(\"processUsersStep\")\n            .<User, User>chunk(10)\n            .reader(reader)\n            .processor(processor)\n            .writer(writer)\n            .build();\n    }\n    \n    @Bean\n    public Job importUserJob(Step processUsersStep) {\n        return jobBuilderFactory.get(\"importUserJob\")\n            .start(processUsersStep)\n            .build();\n    }\n}"
            }
          ]
        }
      ]
    },
    {
      "title": "EventDrivenArchitecture",
      "multi-content": [
        {
          "title": "description",
          "simple-content": "Spring provides support for event-driven architecture, allowing components to communicate through events rather than direct method calls."
        },
        {
          "title": "code_examples",
          "multi-content": [
            {
              "title": "event_example",
              "simple-content": "// Event\n@Getter\npublic class UserCreatedEvent {\n    private final Long userId;\n    private final String email;\n    \n    public UserCreatedEvent(Long userId, String email) {\n        this.userId = userId;\n        this.email = email;\n    }\n}"
            },
            {
              "title": "publisher_example",
              "simple-content": "// Publisher\n@Service\npublic class UserService {\n    \n    private final ApplicationEventPublisher eventPublisher;\n    private final UserRepository userRepository;\n    \n    public UserService(ApplicationEventPublisher eventPublisher, UserRepository userRepository) {\n        this.eventPublisher = eventPublisher;\n        this.userRepository = userRepository;\n    }\n    \n    @Transactional\n    public User createUser(UserDto userDto) {\n        User user = new User();\n        user.setEmail(userDto.getEmail());\n        user.setName(userDto.getName());\n        \n        user = userRepository.save(user);\n        \n        // Publish the event\n        eventPublisher.publishEvent(new UserCreatedEvent(user.getId(), user.getEmail()));\n        \n        return user;\n    }\n}"
            },
            {
              "title": "listener_example",
              "simple-content": "// Listener\n@Component\npublic class UserEventListener {\n    \n    private final EmailService emailService;\n    \n    public UserEventListener(EmailService emailService) {\n        this.emailService = emailService;\n    }\n    \n    @EventListener\n    public void handleUserCreated(UserCreatedEvent event) {\n        emailService.sendWelcomeEmail(event.getEmail());\n    }\n    \n    @TransactionalEventListener(phase = TransactionPhase.AFTER_COMMIT)\n    public void handleUserCreatedAfterCommit(UserCreatedEvent event) {\n        // Executed only after successful transaction commit\n        // Good for non-critical operations that shouldn't affect the transaction\n    }\n}"
            }
          ]
        }
      ]
    },
    {
      "title": "SpringWebFlux",
      "multi-content": [
        {
          "title": "description",
          "simple-content": "Spring WebFlux is a reactive-stack web framework that is fully non-blocking, supports Reactive Streams, and runs on servers like Netty, Undertow, and Servlet containers."
        },
        {
          "title": "code_examples",
          "multi-content": [
            {
              "title": "reactive_repository",
              "simple-content": "// Reactive repository\npublic interface ReactiveUserRepository extends ReactiveCrudRepository<User, Long> {\n    Flux<User> findByLastName(String lastName);\n    Mono<User> findByEmail(String email);\n}"
            },
            {
              "title": "reactive_controller",
              "simple-content": "// Reactive controller with server-sent events\n@RestController\npublic class ReactiveUserController {\n    \n    private final ReactiveUserRepository userRepository;\n    \n    public ReactiveUserController(ReactiveUserRepository userRepository) {\n        this.userRepository = userRepository;\n    }\n    \n    @GetMapping(value = \"/users/updates\", produces = MediaType.TEXT_EVENT_STREAM_VALUE)\n    public Flux<User> streamUsers() {\n        return userRepository.findAll().delayElements(Duration.ofSeconds(1));\n    }\n    \n    @GetMapping(\"/users/{id}\")\n    public Mono<ResponseEntity<User>> getUser(@PathVariable Long id) {\n        return userRepository.findById(id)\n            .map(user -> ResponseEntity.ok(user))\n            .defaultIfEmpty(ResponseEntity.notFound().build());\n    }\n}"
            }
          ]
        }
      ]
    },
    {
      "title": "DeploymentAndProduction",
      "multi-content": [
        {
          "title": "description",
          "simple-content": "Spring Boot applications can be deployed in various ways and include production-ready features for monitoring, management, and operations."
        },
        {
          "title": "embedded_servers",
          "multi-content": [
            {
              "title": "description",
              "simple-content": "Spring Boot includes embedded servers (Tomcat by default) that allow you to run your application as a standalone JAR."
            },
            {
              "title": "code_examples",
              "multi-content": [
                {
                  "title": "customization",
                  "simple-content": "// To customize the embedded server\n@Bean\npublic WebServerFactoryCustomizer<TomcatServletWebServerFactory> tomcatCustomizer() {\n    return (factory) -> {\n        factory.addConnectorCustomizers(connector -> {\n            Http11NioProtocol protocol = (Http11NioProtocol) connector.getProtocolHandler();\n            protocol.setMaxThreads(200);\n            protocol.setConnectionTimeout(20000);\n        });\n    };\n}"
                }
              ]
            }
          ]
        },
        {
          "title": "packaging_for_production",
          "multi-content": [
            {
              "title": "code_examples",
              "multi-content": [
                {
                  "title": "build_jar",
                  "simple-content": "# Build a JAR\n./mvnw clean package"
                },
                {
                  "title": "run_jar",
                  "simple-content": "# Run the JAR\njava -jar target/myapp-0.0.1-SNAPSHOT.jar"
                },
                {
                  "title": "override_properties",
                  "simple-content": "# Override properties at runtime\njava -jar target/myapp-0.0.1-SNAPSHOT.jar --server.port=8081"
                }
              ]
            }
          ]
        },
        {
          "title": "cloud_native_features",
          "multi-content": [
            "Externalized configuration: Environment variables, cloud config servers",
            "Health checks: For container orchestration systems",
            "Metrics: For monitoring systems",
            "Resilience: With Spring Cloud components"
          ]
        }
      ]
    },
    {
      "title": "SpringBootVsFramework",
      "multi-content": [
        {
          "title": "description",
          "simple-content": "Understanding the differences between Spring Boot and the core Spring Framework helps clarify their relationship and use cases."
        },
        {
          "title": "key_differences",
          "multi-content": [
            {
              "title": "Configuration",
              "multi-content": [
                {
                  "title": "spring_framework",
                  "simple-content": "Explicit, manual configuration required"
                },
                {
                  "title": "spring_boot",
                  "simple-content": "Auto-configuration with sensible defaults"
                }
              ]
            },
            {
              "title": "Setup",
              "multi-content": [
                {
                  "title": "spring_framework",
                  "simple-content": "More boilerplate code, multiple configuration files"
                },
                {
                  "title": "spring_boot",
                  "simple-content": "Minimal setup code, convention over configuration"
                }
              ]
            },
            {
              "title": "Deployment",
              "multi-content": [
                {
                  "title": "spring_framework",
                  "simple-content": "Traditional WAR deployment or standalone application"
                },
                {
                  "title": "spring_boot",
                  "simple-content": "Embedded server, standalone JAR with everything included"
                }
              ]
            },
            {
              "title": "Dependencies",
              "multi-content": [
                {
                  "title": "spring_framework",
                  "simple-content": "Manual dependency management and version coordination"
                },
                {
                  "title": "spring_boot",
                  "simple-content": "Starter dependencies with compatible, tested version sets"
                }
              ]
            }
          ]
        },
        {
          "title": "code_examples",
          "multi-content": [
            {
              "title": "spring_framework_config",
              "simple-content": "// Spring Framework - explicit ViewResolver configuration\n@Configuration\npublic class WebConfig implements WebMvcConfigurer {\n    @Bean\n    public ViewResolver viewResolver() {\n        InternalResourceViewResolver resolver = new InternalResourceViewResolver();\n        resolver.setPrefix(\"/WEB-INF/views/\");\n        resolver.setSuffix(\".jsp\");\n        return resolver;\n    }\n    // Many more beans...\n}"
            },
            {
              "title": "spring_boot_config",
              "simple-content": "// Spring Boot - auto-configuration handles it\n@SpringBootApplication\npublic class Application {\n    public static void main(String[] args) {\n        SpringApplication.run(Application.class, args);\n    }\n    // That's it! Configuration via application.properties\n}"
            }
          ]
        }
      ]
    },
    {
      "title": "CommonInterviewQuestions",
      "multi-content": [
        {
          "title": "description",
          "simple-content": "Common questions about Spring Boot that are frequently asked in technical interviews."
        },
        {
          "title": "what_is_spring_boot",
          "multi-content": [
            {
              "title": "question",
              "simple-content": "What is Spring Boot and how does it differ from traditional Spring framework?"
            },
            {
              "title": "answer",
              "multi-content": [
                "Spring Boot is a convention-over-configuration extension of the Spring framework that simplifies Spring application setup. Key differences:",
                "Auto-configuration: Spring Boot automatically configures beans based on classpath dependencies, while traditional Spring requires explicit configuration.",
                "Standalone: Spring Boot applications can run as standalone JARs with embedded servers, while traditional Spring applications typically require external servers.",
                "Starter Dependencies: Spring Boot provides starter POMs that bundle compatible dependencies, whereas traditional Spring requires manual dependency management.",
                "Production-ready: Spring Boot includes built-in metrics, health checks, and externalized configuration."
              ]
            }
          ]
        },
        {
          "title": "how_auto_configuration_works",
          "multi-content": [
            {
              "title": "question",
              "simple-content": "How does Spring Boot auto-configuration work?"
            },
            {
              "title": "answer",
              "multi-content": [
                "Spring Boot auto-configuration works by:",
                "1. Loading configuration classes listed in META-INF/spring.factories under the EnableAutoConfiguration key",
                "2. Evaluating conditions on these classes using annotations like @ConditionalOnClass, @ConditionalOnMissingBean, etc.",
                "3. Only applying configurations that meet their conditions",
                "4. Respecting user-defined beans over auto-configured beans",
                "5. Using a specific order to ensure dependencies are respected"
              ]
            }
          ]
        },
        {
          "title": "ways_to_externalize_configuration",
          "multi-content": [
            {
              "title": "question",
              "simple-content": "What are the different ways to externalize configuration in Spring Boot?"
            },
            {
              "title": "answer",
              "multi-content": [
                "Spring Boot offers multiple ways to externalize configuration:",
                "Property files (application.properties or application.yml)",
                "Environment-specific property files (application-{env}.properties)",
                "Command-line arguments",
                "Environment variables",
                "@ConfigurationProperties for binding properties to structured objects",
                "Spring Cloud Config Server for centralized configuration"
              ]
            }
          ]
        },
        {
          "title": "component_service_repository_difference",
          "multi-content": [
            {
              "title": "question",
              "simple-content": "What is the difference between @Component, @Service, and @Repository annotations?"
            },
            {
              "title": "answer",
              "multi-content": [
                "Functionally, they are all specialized versions of @Component that mark classes for component scanning:",
                "@Component: Generic stereotype for Spring-managed components",
                "@Service: Indicates the class belongs to the service layer (business logic)",
                "@Repository: Indicates the class is a data access object, with additional benefits like exception translation",
                "@Controller/@RestController: Indicates the class defines web endpoints",
                "Spring treats them identically in terms of bean registration, but the specializations improve semantics and may enable additional behaviors."
              ]
            }
          ]
        },
        {
          "title": "exception_handling",
          "multi-content": [
            {
              "title": "question",
              "simple-content": "How do you handle exceptions in a Spring Boot REST application?"
            },
            {
              "title": "answer",
              "multi-content": [
                "Exception handling in Spring Boot REST applications typically involves:",
                "1. Creating custom exception classes for different error scenarios",
                "2. Implementing a global exception handler with @RestControllerAdvice",
                "3. Using @ExceptionHandler methods to handle specific exception types",
                "4. Returning appropriate HTTP status codes and structured error responses",
                "5. Optionally using Spring's ResponseStatusException for simpler cases"
              ]
            }
          ]
        }
      ]
    }
  ]
}