{
  "id": "transactions-base-de-donnees",
  "title": "Transactions de Base de Données",
  "topics": [
    {
      "title": "Concepts Fondamentaux",
      "multi-content": [
        {
          "title": "Description",
          "simple-content": "Les transactions sont un concept fondamental de la gestion des bases de données qui garantissent la cohérence et l'intégrité des données. Elles représentent une séquence d'opérations exécutées comme une seule unité logique de travail - soit toutes les opérations se terminent avec succès, soit aucune ne s'effectue."
        }
      ]
    },
    {
      "title": "Propriétés ACID",
      "multi-content": [
        {
          "title": "Définition",
          "simple-content": "Les propriétés ACID sont les principes fondamentaux du traitement des transactions qui garantissent la validité des données malgré les erreurs, les pannes d'électricité et autres problèmes."
        },
        {
          "title": "Types",
          "multi-content": [
            {
              "title": "Atomicité",
              "multi-content": [
                {
                  "title": "Description",
                  "simple-content": "Une transaction est une unité de travail **atomique** ; soit toutes ses modifications de données sont effectuées, soit aucune ne l'est."
                },
                {
                  "title": "Points Clés",
                  "multi-content": [
                    "Exécution tout ou rien",
                    "Empêche les mises à jour partielles",
                    "Le système doit pouvoir annuler les transactions échouées",
                    "Prévient la corruption des données lors des défaillances"
                  ]
                },
                {
                  "title": "code_examples",
                  "multi-content": [
                    {
                      "title": "Transfert d'Argent",
                      "simple-content": "@Transactional\npublic void transferMoney(Account fromAccount, Account toAccount, BigDecimal amount) {\n    fromAccount.debit(amount);\n    toAccount.credit(amount);\n    // Si une exception se produit, les deux opérations sont annulées\n}"
                    }
                  ]
                }
              ]
            },
            {
              "title": "Cohérence",
              "multi-content": [
                {
                  "title": "Description",
                  "simple-content": "Une transaction doit transformer la base de données d'un état **cohérent** à un autre état cohérent, en maintenant toutes les règles et contraintes définies."
                },
                {
                  "title": "Points Clés",
                  "multi-content": [
                    "Les règles de la base de données sont toujours appliquées",
                    "L'intégrité référentielle est préservée",
                    "Les règles métier restent satisfaites",
                    "Toutes les contraintes (NOT NULL, UNIQUE, CHECK) sont maintenues"
                  ]
                },
                {
                  "title": "Exemple",
                  "simple-content": "Le solde ne peut pas devenir négatif s'il existe une contrainte de solde minimum"
                }
              ]
            },
            {
              "title": "Isolation",
              "multi-content": [
                {
                  "title": "Description",
                  "simple-content": "Les transactions sont **isolées** les unes des autres jusqu'à ce qu'elles soient terminées, malgré leur exécution concurrente."
                },
                {
                  "title": "Points Clés",
                  "multi-content": [
                    "Les transactions concurrentes semblent s'exécuter séquentiellement",
                    "Différents niveaux d'isolation offrent diverses garanties",
                    "Une isolation plus élevée signifie généralement une concurrence plus faible",
                    "Contrôle la visibilité des données non validées"
                  ]
                },
                {
                  "title": "Problèmes Courants",
                  "multi-content": [
                    {
                      "title": "Lecture Sale",
                      "simple-content": "Lecture de modifications non validées d'une autre transaction"
                    },
                    {
                      "title": "Lecture Non Répétable",
                      "simple-content": "Obtention de valeurs différentes pour la même ligne dans la même transaction"
                    },
                    {
                      "title": "Lecture Fantôme",
                      "simple-content": "Obtention de lignes différentes lors de l'exécution de la même requête plusieurs fois dans une transaction"
                    }
                  ]
                }
              ]
            },
            {
              "title": "Durabilité",
              "multi-content": [
                {
                  "title": "Description",
                  "simple-content": "Une fois qu'une transaction a été **validée**, les modifications apportées aux données persistent, même en cas de défaillance du système."
                },
                {
                  "title": "Points Clés",
                  "multi-content": [
                    "Les modifications validées survivent aux pannes du système",
                    "Généralement implémentée à l'aide de journaux de transactions",
                    "Implique souvent l'écriture sur un stockage non volatile",
                    "Essentielle pour la récupération des données"
                  ]
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "title": "Niveaux d'Isolation des Transactions",
      "multi-content": [
        {
          "title": "Description",
          "simple-content": "Les niveaux d'isolation des transactions définissent le degré auquel les opérations d'une transaction sont visibles pour d'autres transactions concurrentes."
        },
        {
          "title": "Types",
          "multi-content": [
            {
              "title": "READ_UNCOMMITTED",
              "multi-content": [
                {
                  "title": "Description",
                  "simple-content": "Niveau d'isolation le plus bas, autorise les lectures sales"
                },
                {
                  "title": "Empêche",
                  "multi-content": []
                },
                {
                  "title": "Autorise",
                  "multi-content": [
                    "Lecture Sale",
                    "Lecture Non Répétable",
                    "Lecture Fantôme"
                  ]
                },
                {
                  "title": "Utilisation",
                  "simple-content": "Rarement utilisé; performances les plus élevées, sécurité la plus faible"
                }
              ]
            },
            {
              "title": "READ_COMMITTED",
              "multi-content": [
                {
                  "title": "Description",
                  "simple-content": "Empêche les lectures sales mais autorise les lectures non répétables et les lectures fantômes"
                },
                {
                  "title": "Empêche",
                  "multi-content": [
                    "Lecture Sale"
                  ]
                },
                {
                  "title": "Autorise",
                  "multi-content": [
                    "Lecture Non Répétable",
                    "Lecture Fantôme"
                  ]
                },
                {
                  "title": "Utilisation",
                  "simple-content": "Bon équilibre; par défaut dans PostgreSQL, Oracle"
                }
              ]
            },
            {
              "title": "REPEATABLE_READ",
              "multi-content": [
                {
                  "title": "Description",
                  "simple-content": "Empêche les lectures sales et les lectures non répétables mais autorise les lectures fantômes"
                },
                {
                  "title": "Empêche",
                  "multi-content": [
                    "Lecture Sale",
                    "Lecture Non Répétable"
                  ]
                },
                {
                  "title": "Autorise",
                  "multi-content": [
                    "Lecture Fantôme"
                  ]
                },
                {
                  "title": "Utilisation",
                  "simple-content": "Meilleure cohérence; par défaut dans MySQL"
                }
              ]
            },
            {
              "title": "SERIALIZABLE",
              "multi-content": [
                {
                  "title": "Description",
                  "simple-content": "Niveau d'isolation le plus élevé, empêche tous les problèmes de concurrence"
                },
                {
                  "title": "Empêche",
                  "multi-content": [
                    "Lecture Sale",
                    "Lecture Non Répétable",
                    "Lecture Fantôme"
                  ]
                },
                {
                  "title": "Autorise",
                  "multi-content": []
                },
                {
                  "title": "Utilisation",
                  "simple-content": "Sécurité la plus élevée; concurrence la plus faible"
                }
              ]
            }
          ]
        },
        {
          "title": "code_examples",
          "multi-content": [
            {
              "title": "Implémentation Spring",
              "simple-content": "@Transactional(isolation = Isolation.READ_COMMITTED)\npublic void processSensitiveData() {\n    // Transaction avec niveau d'isolation READ_COMMITTED\n}"
            },
            {
              "title": "Implémentation JDBC",
              "simple-content": "Connection connection = dataSource.getConnection();\nconnection.setTransactionIsolation(Connection.TRANSACTION_READ_COMMITTED);\nconnection.setAutoCommit(false);\ntry {\n    // Effectuer des opérations de base de données\n    connection.commit();\n} catch(SQLException e) {\n    connection.rollback();\n    throw e;\n} finally {\n    connection.close();\n}"
            }
          ]
        }
      ]
    },
    {
      "title": "Gestion des Transactions avec Spring",
      "multi-content": [
        {
          "title": "Description",
          "simple-content": "Spring fournit un modèle de programmation cohérent pour la gestion des transactions à travers différentes API de transactions comme JTA, JDBC, Hibernate et JPA."
        },
        {
          "title": "Fonctionnalités",
          "multi-content": [
            {
              "title": "Gestion Déclarative des Transactions",
              "multi-content": [
                {
                  "title": "Description",
                  "simple-content": "L'approche la plus courante utilisant les annotations"
                },
                {
                  "title": "code_examples",
                  "multi-content": [
                    {
                      "title": "Service avec @Transactional",
                      "simple-content": "@Service\npublic class UserService {\n    @Transactional\n    public void registerUser(User user) {\n        // Transaction démarrée automatiquement\n        userRepository.save(user);\n        emailService.sendWelcomeEmail(user);\n        // Transaction validée automatiquement s'il n'y a pas d'exceptions\n    }\n}"
                    }
                  ]
                }
              ]
            },
            {
              "title": "@Transactional",
              "multi-content": [
                {
                  "title": "Description",
                  "simple-content": "Annotation principale pour la configuration des transactions"
                },
                {
                  "title": "Attributs",
                  "multi-content": [
                    {
                      "title": "propagation",
                      "multi-content": [
                        {
                          "title": "Description",
                          "simple-content": "Comment les transactions se rapportent aux transactions existantes"
                        },
                        {
                          "title": "Défaut",
                          "simple-content": "REQUIRED"
                        },
                        {
                          "title": "Exemple",
                          "simple-content": "@Transactional(propagation = Propagation.REQUIRES_NEW)"
                        },
                        {
                          "title": "Valeurs",
                          "multi-content": [
                            {
                              "title": "REQUIRED",
                              "simple-content": "Utilise la transaction courante, en crée une nouvelle si aucune n'existe"
                            },
                            {
                              "title": "REQUIRES_NEW",
                              "simple-content": "Crée toujours une nouvelle transaction"
                            },
                            {
                              "title": "SUPPORTS",
                              "simple-content": "Utilise la transaction courante si disponible, sinon non-transactionnel"
                            },
                            {
                              "title": "NOT_SUPPORTED",
                              "simple-content": "Exécute de manière non-transactionnelle, suspend la transaction courante"
                            },
                            {
                              "title": "MANDATORY",
                              "simple-content": "Utilise la transaction existante, lance une exception si aucune n'existe"
                            },
                            {
                              "title": "NEVER",
                              "simple-content": "Exécute de manière non-transactionnelle, lance une exception si une transaction existe"
                            },
                            {
                              "title": "NESTED",
                              "simple-content": "Exécute dans une transaction imbriquée si une transaction courante existe"
                            }
                          ]
                        }
                      ]
                    },
                    {
                      "title": "isolation",
                      "multi-content": [
                        {
                          "title": "Description",
                          "simple-content": "Le niveau d'isolation"
                        },
                        {
                          "title": "Défaut",
                          "simple-content": "DEFAULT"
                        },
                        {
                          "title": "Exemple",
                          "simple-content": "@Transactional(isolation = Isolation.READ_COMMITTED)"
                        }
                      ]
                    },
                    {
                      "title": "timeout",
                      "multi-content": [
                        {
                          "title": "Description",
                          "simple-content": "Délai d'expiration en secondes"
                        },
                        {
                          "title": "Défaut",
                          "simple-content": "-1 (pas de délai d'expiration)"
                        },
                        {
                          "title": "Exemple",
                          "simple-content": "@Transactional(timeout = 30)"
                        }
                      ]
                    },
                    {
                      "title": "readOnly",
                      "multi-content": [
                        {
                          "title": "Description",
                          "simple-content": "Indication que la transaction est en lecture seule"
                        },
                        {
                          "title": "Défaut",
                          "simple-content": "false"
                        },
                        {
                          "title": "Exemple",
                          "simple-content": "@Transactional(readOnly = true)"
                        }
                      ]
                    },
                    {
                      "title": "rollbackFor",
                      "multi-content": [
                        {
                          "title": "Description",
                          "simple-content": "Types d'exceptions qui déclenchent un rollback"
                        },
                        {
                          "title": "Défaut",
                          "simple-content": "RuntimeException, Error"
                        },
                        {
                          "title": "Exemple",
                          "simple-content": "@Transactional(rollbackFor = Exception.class)"
                        }
                      ]
                    },
                    {
                      "title": "noRollbackFor",
                      "multi-content": [
                        {
                          "title": "Description",
                          "simple-content": "Types d'exceptions qui ne déclenchent pas de rollback"
                        },
                        {
                          "title": "Défaut",
                          "simple-content": "aucun"
                        },
                        {
                          "title": "Exemple",
                          "simple-content": "@Transactional(noRollbackFor = NotFoundException.class)"
                        }
                      ]
                    }
                  ]
                },
                {
                  "title": "code_examples",
                  "multi-content": [
                    {
                      "title": "Exemple Complet",
                      "simple-content": "@Transactional(propagation = Propagation.REQUIRED,\n              isolation = Isolation.READ_COMMITTED,\n              readOnly = false,\n              timeout = 30,\n              rollbackFor = Exception.class)"
                    }
                  ]
                }
              ]
            },
            {
              "title": "Gestion Programmatique des Transactions",
              "multi-content": [
                {
                  "title": "Description",
                  "simple-content": "Pour un contrôle plus précis des limites de transaction"
                },
                {
                  "title": "code_examples",
                  "multi-content": [
                    {
                      "title": "TransactionTemplate",
                      "simple-content": "@Service\npublic class OrderService {\n    private final TransactionTemplate transactionTemplate;\n    \n    public OrderService(PlatformTransactionManager transactionManager) {\n        this.transactionTemplate = new TransactionTemplate(transactionManager);\n    }\n    \n    public Order processOrder(Order order) {\n        return transactionTemplate.execute(status -> {\n            try {\n                // Opérations transactionnelles\n                Order savedOrder = orderRepository.save(order);\n                inventoryService.updateStock(order);\n                return savedOrder;\n            } catch (StockException ex) {\n                status.setRollbackOnly();\n                throw ex;\n            }\n        });\n    }\n}"
                    }
                  ]
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "title": "Propagation des Transactions",
      "multi-content": [
        {
          "title": "Description",
          "simple-content": "La propagation des transactions définit comment les transactions se rapportent les unes aux autres, en particulier lorsqu'une méthode transactionnelle appelle une autre méthode transactionnelle."
        },
        {
          "title": "Types",
          "multi-content": [
            {
              "title": "REQUIRED",
              "multi-content": [
                {
                  "title": "Description",
                  "simple-content": "Utilise la transaction courante, en crée une nouvelle si aucune n'existe"
                },
                {
                  "title": "Utilisation",
                  "simple-content": "Comportement par défaut, la plupart des cas d'utilisation"
                }
              ]
            },
            {
              "title": "REQUIRES_NEW",
              "multi-content": [
                {
                  "title": "Description",
                  "simple-content": "Crée toujours une nouvelle transaction"
                },
                {
                  "title": "Utilisation",
                  "simple-content": "Opérations indépendantes, isolation des erreurs"
                }
              ]
            },
            {
              "title": "SUPPORTS",
              "multi-content": [
                {
                  "title": "Description",
                  "simple-content": "Utilise la transaction courante si disponible, sinon non-transactionnel"
                },
                {
                  "title": "Utilisation",
                  "simple-content": "Opérations de lecture qui ne nécessitent pas de transactions"
                }
              ]
            },
            {
              "title": "NOT_SUPPORTED",
              "multi-content": [
                {
                  "title": "Description",
                  "simple-content": "Exécute de manière non-transactionnelle, suspend la transaction courante"
                },
                {
                  "title": "Utilisation",
                  "simple-content": "Opérations qui doivent toujours s'exécuter en dehors d'une transaction"
                }
              ]
            },
            {
              "title": "MANDATORY",
              "multi-content": [
                {
                  "title": "Description",
                  "simple-content": "Utilise la transaction existante, lance une exception si aucune n'existe"
                },
                {
                  "title": "Utilisation",
                  "simple-content": "Opérations qui doivent faire partie d'une transaction plus large"
                }
              ]
            },
            {
              "title": "NEVER",
              "multi-content": [
                {
                  "title": "Description",
                  "simple-content": "Exécute de manière non-transactionnelle, lance une exception si une transaction existe"
                },
                {
                  "title": "Utilisation",
                  "simple-content": "Opérations qui ne doivent pas s'exécuter dans une transaction"
                }
              ]
            },
            {
              "title": "NESTED",
              "multi-content": [
                {
                  "title": "Description",
                  "simple-content": "Exécute dans une transaction imbriquée si une transaction courante existe"
                },
                {
                  "title": "Utilisation",
                  "simple-content": "Capacités de rollback partiel (avec certaines limitations)"
                }
              ]
            }
          ]
        },
        {
          "title": "code_examples",
          "multi-content": [
            {
              "title": "Service Composite",
              "simple-content": "@Service\npublic class CompositeService {\n    private final UserService userService;\n    private final AuditService auditService;\n    \n    @Transactional // REQUIRED par défaut\n    public void mainOperation() {\n        // Utilise la transaction courante\n        userService.updateUser(user);\n        \n        try {\n            // Crée une nouvelle transaction indépendante\n            auditService.logOperation();\n        } catch (Exception e) {\n            // Si cela échoue, cela n'affectera pas la transaction principale\n            logger.error(\"Audit failed\", e);\n        }\n    }\n}\n\n@Service\npublic class AuditService {\n    @Transactional(propagation = Propagation.REQUIRES_NEW)\n    public void logOperation() {\n        // S'exécute toujours dans une nouvelle transaction\n    }\n}"
            }
          ]
        }
      ]
    },
    {
      "title": "Patterns de Transaction",
      "multi-content": [
        {
          "title": "Description",
          "simple-content": "Patterns de conception courants pour gérer efficacement les transactions"
        },
        {
          "title": "Types",
          "multi-content": [
            {
              "title": "Unit of Work",
              "multi-content": [
                {
                  "title": "Description",
                  "simple-content": "Suivre les modifications et les écrire dans une seule transaction"
                },
                {
                  "title": "Implémentation",
                  "simple-content": "Contexte de persistance JPA/Hibernate"
                },
                {
                  "title": "Détails",
                  "simple-content": "Les objets sont suivis pour les modifications (dirty checking), réduit les allers-retours vers la base de données, garantit l'identité (même instance d'entité pour la même ligne de base de données), effacé aux limites de transaction"
                }
              ]
            },
            {
              "title": "Verrouillage Optimiste",
              "multi-content": [
                {
                  "title": "Description",
                  "simple-content": "Autoriser l'accès concurrent mais vérifier qu'il n'y a pas de modifications avant la validation"
                },
                {
                  "title": "Implémentation",
                  "simple-content": "Annotation @Version dans JPA"
                },
                {
                  "title": "Détails",
                  "simple-content": "Suppose que les conflits sont rares et vérifie au moment de la validation qu'aucun conflit ne s'est produit"
                },
                {
                  "title": "code_examples",
                  "multi-content": [
                    {
                      "title": "Entité JPA avec @Version",
                      "simple-content": "@Entity\npublic class Account {\n    @Id\n    private Long id;\n    \n    private BigDecimal balance;\n    \n    @Version\n    private Integer version;\n    \n    // Méthodes\n}\n\n// Utilisation\n@Transactional\npublic void withdraw(Long accountId, BigDecimal amount) {\n    Account account = accountRepository.findById(accountId)\n        .orElseThrow(() -> new AccountNotFoundException(accountId));\n    account.withdraw(amount);\n    accountRepository.save(account);\n    // Si une autre transaction a mis à jour le compte, OptimisticLockException sera lancée\n}"
                    }
                  ]
                }
              ]
            },
            {
              "title": "Verrouillage Pessimiste",
              "multi-content": [
                {
                  "title": "Description",
                  "simple-content": "Verrouiller les ressources lors de la lecture pour empêcher les modifications concurrentes"
                },
                {
                  "title": "Implémentation",
                  "simple-content": "Requêtes SELECT FOR UPDATE"
                },
                {
                  "title": "Détails",
                  "simple-content": "Suppose que des conflits se produiront et verrouille les ressources avant de les utiliser"
                },
                {
                  "title": "code_examples",
                  "multi-content": [
                    {
                      "title": "Repository JPA avec Verrouillage",
                      "simple-content": "@Lock(LockModeType.PESSIMISTIC_WRITE)\n@Query(\"SELECT a FROM Account a WHERE a.id = :id\")\nAccount findAndLockForUpdate(@Param(\"id\") Long id);\n\n// Utilisation\n@Transactional\npublic void withdraw(Long accountId, BigDecimal amount) {\n    Account account = accountRepository.findAndLockForUpdate(accountId);\n    account.withdraw(amount);\n    accountRepository.save(account);\n}"
                    }
                  ]
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "title": "Transactions JPA/Hibernate",
      "multi-content": [
        {
          "title": "Description",
          "simple-content": "Comment les transactions sont gérées dans les frameworks JPA et Hibernate"
        },
        {
          "title": "Composants",
          "multi-content": [
            {
              "title": "API de Transaction EntityManager",
              "multi-content": [
                {
                  "title": "Description",
                  "simple-content": "API de transaction principale de JPA"
                },
                {
                  "title": "code_examples",
                  "multi-content": [
                    {
                      "title": "Gestion Manuelle des Transactions",
                      "simple-content": "EntityManager em = emf.createEntityManager();\nEntityTransaction tx = em.getTransaction();\ntry {\n    tx.begin();\n    \n    // Effectuer les opérations\n    User user = new User();\n    user.setName(\"John\");\n    em.persist(user);\n    \n    tx.commit();\n} catch (Exception e) {\n    if (tx.isActive()) {\n        tx.rollback();\n    }\n    throw e;\n} finally {\n    em.close();\n}"
                    }
                  ]
                }
              ]
            },
            {
              "title": "Cache de Premier Niveau",
              "multi-content": [
                {
                  "title": "Description",
                  "simple-content": "Le contexte de persistance de l'EntityManager agit comme un cache de premier niveau au sein d'une transaction"
                },
                {
                  "title": "Avantages",
                  "multi-content": [
                    "Les objets sont suivis pour les modifications (dirty checking)",
                    "Réduit les allers-retours vers la base de données",
                    "Garantit l'identité (même instance d'entité pour la même ligne de base de données)",
                    "Effacé aux limites de transaction"
                  ]
                }
              ]
            },
            {
              "title": "États des Entités",
              "multi-content": [
                {
                  "title": "Description",
                  "simple-content": "Les entités JPA transitent entre différents états pendant les transactions"
                },
                {
                  "title": "États",
                  "multi-content": [
                    {
                      "title": "Transitoire",
                      "simple-content": "Objet non associé au contexte de persistance"
                    },
                    {
                      "title": "Persistant",
                      "simple-content": "Objet associé au contexte de persistance et suivi"
                    },
                    {
                      "title": "Détaché",
                      "simple-content": "Objet qui était persistant mais n'est plus associé"
                    },
                    {
                      "title": "Supprimé",
                      "simple-content": "Objet marqué pour suppression de la base de données"
                    }
                  ]
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "title": "Transactions Distribuées",
      "multi-content": [
        {
          "title": "Description",
          "simple-content": "Gestion des transactions qui s'étendent sur plusieurs ressources (bases de données, courtiers de messages, services web)."
        },
        {
          "title": "Approches",
          "multi-content": [
            {
              "title": "Validation en Deux Phases (2PC)",
              "multi-content": [
                {
                  "title": "Description",
                  "simple-content": "Protocole pour coordonner les transactions distribuées"
                },
                {
                  "title": "Phases",
                  "multi-content": [
                    "Phase de Préparation: Le coordinateur demande à tous les participants s'ils peuvent valider",
                    "Phase de Validation: Si tous sont d'accord, le coordinateur dit à tout le monde de valider"
                  ]
                },
                {
                  "title": "Considérations",
                  "multi-content": [
                    "Fournit de fortes garanties de cohérence",
                    "Peut impacter la disponibilité du système si le coordinateur échoue",
                    "Verrouille potentiellement les ressources pendant des périodes prolongées"
                  ]
                }
              ]
            },
            {
              "title": "Modèles de Cohérence Éventuelle",
              "multi-content": [
                {
                  "title": "Description",
                  "simple-content": "Approches alternatives plus évolutives mais offrant des garanties plus faibles"
                },
                {
                  "title": "Patterns",
                  "multi-content": [
                    {
                      "title": "Pattern Saga",
                      "multi-content": [
                        {
                          "title": "Description",
                          "simple-content": "Une séquence de transactions locales, où chaque transaction met à jour un seul service. Si une transaction échoue, des transactions compensatoires annulent les modifications précédentes."
                        },
                        {
                          "title": "code_examples",
                          "multi-content": [
                            {
                              "title": "Saga de Réservation de Voyage",
                              "simple-content": "@Transactional\npublic void bookTrip() {\n    try {\n        // Transaction locale 1\n        Long flightBookingId = flightService.bookFlight(flightDetails);\n        \n        try {\n            // Transaction locale 2\n            Long hotelBookingId = hotelService.bookHotel(hotelDetails);\n            \n            try {\n                // Transaction locale 3\n                carService.rentCar(carDetails);\n            } catch (Exception e) {\n                // Transaction compensatoire pour l'hôtel\n                hotelService.cancelBooking(hotelBookingId);\n                // Transaction compensatoire pour le vol\n                flightService.cancelBooking(flightBookingId);\n                throw e;\n            }\n        } catch (Exception e) {\n            // Transaction compensatoire pour le vol\n            flightService.cancelBooking(flightBookingId);\n            throw e;\n        }\n    } catch (Exception e) {\n        // Pas de transactions compensatoires nécessaires\n        throw e;\n    }\n}"
                            }
                          ]
                        }
                      ]
                    },
                    {
                      "title": "Transactions Compensatoires",
                      "multi-content": [
                        {
                          "title": "Description",
                          "simple-content": "Transactions qui annulent les effets des transactions précédentes"
                        },
                        {
                          "title": "Utilisation",
                          "simple-content": "Essentielles pour l'implémentation du pattern saga, récupération d'erreurs"
                        }
                      ]
                    },
                    {
                      "title": "Pattern Outbox",
                      "multi-content": [
                        {
                          "title": "Description",
                          "simple-content": "Écrire dans la base de données locale et une table outbox dans la même transaction, puis traiter de manière asynchrone les entrées de l'outbox"
                        },
                        {
                          "title": "Avantages",
                          "multi-content": [
                            "Assure une messagerie fiable avec des transactions locales",
                            "Empêche la perte de messages pendant les défaillances du système"
                          ]
                        }
                      ]
                    },
                    {
                      "title": "Architecture Orientée Événements",
                      "multi-content": [
                        {
                          "title": "Description",
                          "simple-content": "Utilisation d'événements pour coordonner les changements d'état entre les services"
                        },
                        {
                          "title": "Considérations",
                          "multi-content": [
                            "Découple les services",
                            "Souvent utilisée avec des modèles de cohérence éventuelle",
                            "Nécessite une conception et une gestion soigneuses des événements"
                          ]
                        }
                      ]
                    }
                  ]
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "title": "Bonnes Pratiques de Transaction",
      "multi-content": [
        {
          "title": "Description",
          "simple-content": "Approches recommandées pour une gestion efficace des transactions"
        },
        {
          "title": "Catégories",
          "multi-content": [
            {
              "title": "Conception des Transactions",
              "multi-content": [
                "Garder les transactions courtes",
                "Ne pas effectuer d'opérations non-DB dans les transactions",
                "Choisir un niveau d'isolation approprié",
                "Gérer correctement les exceptions",
                "Être conscient des limites des transactions",
                "Implémenter une gestion appropriée des exceptions"
              ]
            },
            {
              "title": "Performance",
              "multi-content": [
                "Utiliser des transactions en lecture seule quand c'est possible",
                "Regrouper les opérations pour les mises à jour en masse",
                "Surveiller les délais d'expiration des transactions",
                "Envisager d'utiliser le verrouillage optimiste",
                "Implémenter une stratégie de mise en cache appropriée",
                "Utiliser le traitement par lots pour les opérations en masse"
              ]
            },
            {
              "title": "Gestion des Exceptions",
              "multi-content": [
                "Définir des règles claires de rollback",
                "Gérer de manière appropriée les exceptions de transaction",
                "Utiliser TransactionTemplate pour les transactions programmatiques",
                "Envisager d'utiliser @TransactionEventListener",
                "Nettoyer les ressources dans des blocs finally"
              ]
            }
          ]
        }
      ]
    },
    {
      "title": "Pièges Courants des Transactions",
      "multi-content": [
        {
          "title": "Description",
          "simple-content": "Erreurs et problèmes courants avec les transactions de base de données"
        },
        {
          "title": "Problèmes",
          "multi-content": [
            {
              "title": "Transactions longues",
              "multi-content": [
                {
                  "title": "Impact",
                  "simple-content": "Mobilisent des ressources de base de données, augmentent la contention des verrous, réduisent la concurrence"
                },
                {
                  "title": "Solution",
                  "simple-content": "Diviser en transactions plus petites"
                }
              ]
            },
            {
              "title": "Niveau d'isolation inapproprié",
              "multi-content": [
                {
                  "title": "Impact",
                  "simple-content": "Trop bas: incohérence des données, Trop élevé: problèmes de performance"
                },
                {
                  "title": "Solution",
                  "simple-content": "Choisir le niveau d'isolation en fonction des exigences spécifiques"
                }
              ]
            },
            {
              "title": "@Transactional sur méthodes privées",
              "multi-content": [
                {
                  "title": "Impact",
                  "simple-content": "L'annotation est ignorée sauf si la méthode est publique"
                },
                {
                  "title": "Solution",
                  "simple-content": "Extraire vers une méthode publique ou utiliser le mode AspectJ"
                }
              ]
            },
            {
              "title": "Rollback de transaction pour exceptions vérifiées",
              "multi-content": [
                {
                  "title": "Impact",
                  "simple-content": "Par défaut, Spring ne fait un rollback que pour les exceptions non vérifiées"
                },
                {
                  "title": "Solution",
                  "simple-content": "Spécifier rollbackFor = Exception.class"
                }
              ]
            },
            {
              "title": "Propagation du contexte de transaction dans les opérations asynchrones",
              "multi-content": [
                {
                  "title": "Impact",
                  "simple-content": "Le contexte de transaction est perdu dans les nouveaux threads"
                },
                {
                  "title": "Solution",
                  "simple-content": "Terminer le travail transactionnel avant les appels asynchrones ou utiliser des paramètres de propagation spécifiques"
                }
              ]
            },
            {
              "title": "Mauvaise utilisation des transactions imbriquées",
              "multi-content": [
                {
                  "title": "Impact",
                  "simple-content": "Comportement de rollback inattendu"
                },
                {
                  "title": "Solution",
                  "simple-content": "Comprendre les comportements de propagation"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "title": "Questions d'Entretien",
      "multi-content": [
        {
          "title": "Propriétés ACID",
          "multi-content": [
            {
              "title": "Question",
              "simple-content": "Quelles sont les propriétés ACID dans les transactions de base de données?"
            },
            {
              "title": "Réponse",
              "simple-content": "ACID signifie Atomicité, Cohérence, Isolation et Durabilité. Ce sont les quatre propriétés clés qui garantissent un traitement fiable des transactions en base de données.\n\n- L'**Atomicité** garantit que toutes les opérations d'une transaction s'exécutent entièrement ou n'ont aucun effet.\n- La **Cohérence** garantit qu'une transaction amène la base de données d'un état valide à un autre.\n- L'**Isolation** garantit que les transactions concurrentes n'interfèrent pas entre elles.\n- La **Durabilité** garantit qu'une fois qu'une transaction est validée, elle le reste, même en cas de défaillance du système."
            }
          ]
        },
        {
          "title": "Gestion des Transactions Spring",
          "multi-content": [
            {
              "title": "Question",
              "simple-content": "Comment Spring gère-t-il la gestion des transactions?"
            },
            {
              "title": "Réponse",
              "simple-content": "Spring fournit à la fois une gestion déclarative et programmatique des transactions. La gestion déclarative des transactions se fait généralement à l'aide de l'annotation `@Transactional`, qui peut être appliquée au niveau de la classe ou de la méthode. En coulisses, Spring utilise des proxies AOP pour envelopper les méthodes transactionnelles avec du code de gestion des transactions qui démarre, valide ou annule les transactions selon les besoins. La gestion des transactions Spring fonctionne avec différentes API de transaction comme JTA, JDBC, Hibernate et JPA, offrant un modèle de programmation cohérent."
            }
          ]
        },
        {
          "title": "Niveaux d'Isolation",
          "multi-content": [
            {
              "title": "Question",
              "simple-content": "Quelle est la différence entre les différents niveaux d'isolation des transactions?"
            },
            {
              "title": "Réponse",
              "simple-content": "Les niveaux d'isolation des transactions contrôlent comment les modifications apportées par une transaction sont visibles pour d'autres transactions concurrentes:\n\n- **READ_UNCOMMITTED**: Autorise les lectures sales (modifications non validées d'autres transactions), les lectures non répétables et les lectures fantômes. Offre les meilleures performances mais la sécurité la plus faible.\n- **READ_COMMITTED**: Empêche les lectures sales mais autorise les lectures non répétables et les lectures fantômes. Un bon équilibre entre performance et sécurité.\n- **REPEATABLE_READ**: Empêche les lectures sales et les lectures non répétables mais autorise les lectures fantômes. Fournit de meilleures garanties de cohérence.\n- **SERIALIZABLE**: Empêche tous les problèmes de concurrence (lectures sales, lectures non répétables, lectures fantômes) mais a la concurrence et les performances les plus faibles."
            }
          ]
        },
        {
          "title": "Propagation des Transactions",
          "multi-content": [
            {
              "title": "Question",
              "simple-content": "Expliquez la propagation des transactions dans Spring et quand utiliseriez-vous différents types de propagation?"
            },
            {
              "title": "Réponse",
              "simple-content": "La propagation des transactions définit comment les transactions se rapportent les unes aux autres lorsque des méthodes transactionnelles appellent d'autres méthodes transactionnelles:\n\n- **REQUIRED** (par défaut): Utilise la transaction courante, en crée une nouvelle si aucune n'existe. Approprié pour la plupart des cas d'utilisation.\n- **REQUIRES_NEW**: Crée toujours une nouvelle transaction. À utiliser lorsque vous avez besoin que des opérations s'exécutent dans une transaction indépendante, même si une transaction existe déjà.\n- **SUPPORTS**: Utilise la transaction courante si elle existe, sinon exécute de manière non-transactionnelle. Convient aux opérations de lecture qui n'ont pas nécessairement besoin d'une transaction.\n- **MANDATORY**: Utilise la transaction existante, lance une exception si aucune n'existe. À utiliser lorsqu'une opération doit toujours faire partie d'une transaction plus large.\n- **NESTED**: Exécute dans une transaction imbriquée si la transaction courante existe. Utile lorsque vous voulez pouvoir annuler des parties spécifiques d'une transaction."
            }
          ]
        },
        {
          "title": "Verrouillage Optimiste vs Pessimiste",
          "multi-content": [
            {
              "title": "Question",
              "simple-content": "Qu'est-ce que le verrouillage optimiste et quand l'utiliseriez-vous plutôt que le verrouillage pessimiste?"
            },
            {
              "title": "Réponse",
              "simple-content": "Le verrouillage optimiste suppose que les conflits sont rares et ne vérifie les conflits qu'au moment de la validation à l'aide d'un champ de version ou d'un horodatage. Il est approprié lorsque:\n\n1. Les conflits sont rares\n2. Une concurrence élevée est nécessaire\n3. Les transactions sont généralement courtes\n4. Le coût de réessayer occasionnellement une transaction est acceptable\n\nEn revanche, le verrouillage pessimiste acquiert des verrous à l'avance et empêche d'autres transactions d'accéder aux données. Utilisez le verrouillage pessimiste lorsque:\n\n1. Les conflits sont fréquents\n2. Les données sont critiques\n3. Le coût d'une transaction échouée est élevé\n4. L'accès concurrent doit être strictement contrôlé"
            }
          ]
        },
        {
          "title": "Transactions Distribuées",
          "multi-content": [
            {
              "title": "Question",
              "simple-content": "Comment géreriez-vous une transaction distribuée sur plusieurs bases de données ou services?"
            },
            {
              "title": "Réponse",
              "simple-content": "Pour les transactions distribuées, il existe plusieurs approches:\n\n1. **Validation en Deux Phases (2PC)**: Un protocole qui garantit que tous les participants valident ou tous annulent une transaction. Il est fiable mais peut impacter les performances et la disponibilité.\n    \n2. **Pattern Saga**: Diviser une transaction distribuée en une séquence de transactions locales, avec des transactions compensatoires pour annuler les modifications si une étape échoue. C'est plus évolutif mais a une cohérence éventuelle.\n    \n3. **Pattern Outbox**: Écrire dans la base de données locale et une table outbox dans la même transaction, puis traiter de manière asynchrone les entrées de l'outbox pour déclencher des changements dans d'autres systèmes.\n    \n4. **Capture de Données de Changement (CDC)**: Surveiller les journaux de transactions de base de données pour détecter les changements et les propager à d'autres systèmes.\n    \nPour des scénarios plus simples dans Spring, JTA (Java Transaction API) avec un gestionnaire de transactions approprié peut gérer les transactions sur plusieurs ressources."
            }
          ]
        }
      ]
    }
  ]
}