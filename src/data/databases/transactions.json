{
  "id": "database-transactions",
  "title": "Database Transactions",
  "topics": [
    {
      "title": "Core Concepts",
      "multi-content": [
        {
          "title": "Description",
          "simple-content": "Transactions are a fundamental concept in database management that ensure data consistency and integrity. They represent a sequence of operations that are executed as a single logical unit of work - either all operations complete successfully or none do."
        }
      ]
    },
    {
      "title": "ACID Properties",
      "multi-content": [
        {
          "title": "Definition",
          "simple-content": "The ACID properties are the foundational principles of transaction processing that guarantee data validity despite errors, power failures, and other issues."
        },
        {
          "title": "Types",
          "multi-content": [
            {
              "title": "Atomicity",
              "multi-content": [
                {
                  "title": "Description",
                  "simple-content": "A transaction is an **atomic** unit of work; either all of its data modifications are performed, or none of them are performed."
                },
                {
                  "title": "Key Points",
                  "multi-content": [
                    "All-or-nothing execution",
                    "Ensures partial updates never occur",
                    "System must be able to roll back failed transactions",
                    "Prevents data corruption during failures"
                  ]
                },
                {
                  "title": "code_examples",
                  "multi-content": [
                    {
                      "title": "Money Transfer",
                      "simple-content": "@Transactional\npublic void transferMoney(Account fromAccount, Account toAccount, BigDecimal amount) {\n    fromAccount.debit(amount);\n    toAccount.credit(amount);\n    // If any exception occurs, both operations are rolled back\n}"
                    }
                  ]
                }
              ]
            },
            {
              "title": "Consistency",
              "multi-content": [
                {
                  "title": "Description",
                  "simple-content": "A transaction must transform the database from one **consistent** state to another consistent state, maintaining all defined rules and constraints."
                },
                {
                  "title": "Key Points",
                  "multi-content": [
                    "Database rules are always enforced",
                    "Referential integrity is preserved",
                    "Business rules remain satisfied",
                    "All constraints (NOT NULL, UNIQUE, CHECK) are maintained"
                  ]
                },
                {
                  "title": "Example",
                  "simple-content": "Balance cannot go negative if there's a minimum balance constraint"
                }
              ]
            },
            {
              "title": "Isolation",
              "multi-content": [
                {
                  "title": "Description",
                  "simple-content": "Transactions are **isolated** from each other until they are completed, despite being executed concurrently."
                },
                {
                  "title": "Key Points",
                  "multi-content": [
                    "Concurrent transactions appear to execute sequentially",
                    "Different isolation levels provide varying guarantees",
                    "Higher isolation typically means lower concurrency",
                    "Controls visibility of uncommitted data"
                  ]
                },
                {
                  "title": "Common Problems",
                  "multi-content": [
                    {
                      "title": "Dirty Read",
                      "simple-content": "Reading uncommitted changes from another transaction"
                    },
                    {
                      "title": "Non-Repeatable Read",
                      "simple-content": "Getting different values for the same row in the same transaction"
                    },
                    {
                      "title": "Phantom Read",
                      "simple-content": "Getting different rows when running the same query multiple times in a transaction"
                    }
                  ]
                }
              ]
            },
            {
              "title": "Durability",
              "multi-content": [
                {
                  "title": "Description",
                  "simple-content": "Once a transaction has been **committed**, the changes it has made to the data persist, even in the event of system failures."
                },
                {
                  "title": "Key Points",
                  "multi-content": [
                    "Committed changes survive system crashes",
                    "Typically implemented using transaction logs",
                    "Often involves writing to non-volatile storage",
                    "Critical for data recovery"
                  ]
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "title": "Transaction Isolation Levels",
      "multi-content": [
        {
          "title": "Description",
          "simple-content": "Transaction isolation levels define the degree to which the operations in one transaction are visible to other concurrent transactions."
        },
        {
          "title": "Types",
          "multi-content": [
            {
              "title": "READ_UNCOMMITTED",
              "multi-content": [
                {
                  "title": "Description",
                  "simple-content": "Lowest isolation level, allows dirty reads"
                },
                {
                  "title": "Prevents",
                  "multi-content": []
                },
                {
                  "title": "Allows",
                  "multi-content": [
                    "Dirty Read",
                    "Non-Repeatable Read",
                    "Phantom Read"
                  ]
                },
                {
                  "title": "Usage",
                  "simple-content": "Rarely used; highest performance, lowest safety"
                }
              ]
            },
            {
              "title": "READ_COMMITTED",
              "multi-content": [
                {
                  "title": "Description",
                  "simple-content": "Prevents dirty reads but allows non-repeatable reads and phantom reads"
                },
                {
                  "title": "Prevents",
                  "multi-content": [
                    "Dirty Read"
                  ]
                },
                {
                  "title": "Allows",
                  "multi-content": [
                    "Non-Repeatable Read",
                    "Phantom Read"
                  ]
                },
                {
                  "title": "Usage",
                  "simple-content": "Good balance; default in PostgreSQL, Oracle"
                }
              ]
            },
            {
              "title": "REPEATABLE_READ",
              "multi-content": [
                {
                  "title": "Description",
                  "simple-content": "Prevents dirty reads and non-repeatable reads but allows phantom reads"
                },
                {
                  "title": "Prevents",
                  "multi-content": [
                    "Dirty Read",
                    "Non-Repeatable Read"
                  ]
                },
                {
                  "title": "Allows",
                  "multi-content": [
                    "Phantom Read"
                  ]
                },
                {
                  "title": "Usage",
                  "simple-content": "Better consistency; default in MySQL"
                }
              ]
            },
            {
              "title": "SERIALIZABLE",
              "multi-content": [
                {
                  "title": "Description",
                  "simple-content": "Highest isolation level, prevents all concurrency problems"
                },
                {
                  "title": "Prevents",
                  "multi-content": [
                    "Dirty Read",
                    "Non-Repeatable Read",
                    "Phantom Read"
                  ]
                },
                {
                  "title": "Allows",
                  "multi-content": []
                },
                {
                  "title": "Usage",
                  "simple-content": "Highest safety; lowest concurrency"
                }
              ]
            }
          ]
        },
        {
          "title": "code_examples",
          "multi-content": [
            {
              "title": "Spring Implementation",
              "simple-content": "@Transactional(isolation = Isolation.READ_COMMITTED)\npublic void processSensitiveData() {\n    // Transaction with READ_COMMITTED isolation level\n}"
            },
            {
              "title": "JDBC Implementation",
              "simple-content": "Connection connection = dataSource.getConnection();\nconnection.setTransactionIsolation(Connection.TRANSACTION_READ_COMMITTED);\nconnection.setAutoCommit(false);\ntry {\n    // Perform database operations\n    connection.commit();\n} catch(SQLException e) {\n    connection.rollback();\n    throw e;\n} finally {\n    connection.close();\n}"
            }
          ]
        }
      ]
    },
    {
      "title": "Spring Transaction Management",
      "multi-content": [
        {
          "title": "Description",
          "simple-content": "Spring provides a consistent programming model for transaction management across different transaction APIs like JTA, JDBC, Hibernate, and JPA."
        },
        {
          "title": "Features",
          "multi-content": [
            {
              "title": "Declarative Transaction Management",
              "multi-content": [
                {
                  "title": "Description",
                  "simple-content": "The most common approach using annotations"
                },
                {
                  "title": "code_examples",
                  "multi-content": [
                    {
                      "title": "Service with @Transactional",
                      "simple-content": "@Service\npublic class UserService {\n    @Transactional\n    public void registerUser(User user) {\n        // Transaction automatically started\n        userRepository.save(user);\n        emailService.sendWelcomeEmail(user);\n        // Transaction automatically committed if no exceptions\n    }\n}"
                    }
                  ]
                }
              ]
            },
            {
              "title": "@Transactional",
              "multi-content": [
                {
                  "title": "Description",
                  "simple-content": "Primary annotation for transaction configuration"
                },
                {
                  "title": "Attributes",
                  "multi-content": [
                    {
                      "title": "propagation",
                      "multi-content": [
                        {
                          "title": "Description",
                          "simple-content": "How transactions relate to existing ones"
                        },
                        {
                          "title": "Default",
                          "simple-content": "REQUIRED"
                        },
                        {
                          "title": "Example",
                          "simple-content": "@Transactional(propagation = Propagation.REQUIRES_NEW)"
                        },
                        {
                          "title": "Values",
                          "multi-content": [
                            {
                              "title": "REQUIRED",
                              "simple-content": "Use current transaction, create new if none exists"
                            },
                            {
                              "title": "REQUIRES_NEW",
                              "simple-content": "Always create a new transaction"
                            },
                            {
                              "title": "SUPPORTS",
                              "simple-content": "Use current transaction if available, otherwise non-transactional"
                            },
                            {
                              "title": "NOT_SUPPORTED",
                              "simple-content": "Execute non-transactionally, suspend current transaction"
                            },
                            {
                              "title": "MANDATORY",
                              "simple-content": "Use existing transaction, throw exception if none exists"
                            },
                            {
                              "title": "NEVER",
                              "simple-content": "Execute non-transactionally, throw exception if transaction exists"
                            },
                            {
                              "title": "NESTED",
                              "simple-content": "Execute within a nested transaction if a current transaction exists"
                            }
                          ]
                        }
                      ]
                    },
                    {
                      "title": "isolation",
                      "multi-content": [
                        {
                          "title": "Description",
                          "simple-content": "The isolation level"
                        },
                        {
                          "title": "Default",
                          "simple-content": "DEFAULT"
                        },
                        {
                          "title": "Example",
                          "simple-content": "@Transactional(isolation = Isolation.READ_COMMITTED)"
                        }
                      ]
                    },
                    {
                      "title": "timeout",
                      "multi-content": [
                        {
                          "title": "Description",
                          "simple-content": "Timeout in seconds"
                        },
                        {
                          "title": "Default",
                          "simple-content": "-1 (no timeout)"
                        },
                        {
                          "title": "Example",
                          "simple-content": "@Transactional(timeout = 30)"
                        }
                      ]
                    },
                    {
                      "title": "readOnly",
                      "multi-content": [
                        {
                          "title": "Description",
                          "simple-content": "Hint that transaction is read-only"
                        },
                        {
                          "title": "Default",
                          "simple-content": "false"
                        },
                        {
                          "title": "Example",
                          "simple-content": "@Transactional(readOnly = true)"
                        }
                      ]
                    },
                    {
                      "title": "rollbackFor",
                      "multi-content": [
                        {
                          "title": "Description",
                          "simple-content": "Exception types that trigger rollback"
                        },
                        {
                          "title": "Default",
                          "simple-content": "RuntimeException, Error"
                        },
                        {
                          "title": "Example",
                          "simple-content": "@Transactional(rollbackFor = Exception.class)"
                        }
                      ]
                    },
                    {
                      "title": "noRollbackFor",
                      "multi-content": [
                        {
                          "title": "Description",
                          "simple-content": "Exception types that don't trigger rollback"
                        },
                        {
                          "title": "Default",
                          "simple-content": "none"
                        },
                        {
                          "title": "Example",
                          "simple-content": "@Transactional(noRollbackFor = NotFoundException.class)"
                        }
                      ]
                    }
                  ]
                },
                {
                  "title": "code_examples",
                  "multi-content": [
                    {
                      "title": "Complete Example",
                      "simple-content": "@Transactional(propagation = Propagation.REQUIRED,\n              isolation = Isolation.READ_COMMITTED,\n              readOnly = false,\n              timeout = 30,\n              rollbackFor = Exception.class)"
                    }
                  ]
                }
              ]
            },
            {
              "title": "Programmatic Transaction Management",
              "multi-content": [
                {
                  "title": "Description",
                  "simple-content": "For more control over transaction boundaries"
                },
                {
                  "title": "code_examples",
                  "multi-content": [
                    {
                      "title": "TransactionTemplate",
                      "simple-content": "@Service\npublic class OrderService {\n    private final TransactionTemplate transactionTemplate;\n    \n    public OrderService(PlatformTransactionManager transactionManager) {\n        this.transactionTemplate = new TransactionTemplate(transactionManager);\n    }\n    \n    public Order processOrder(Order order) {\n        return transactionTemplate.execute(status -> {\n            try {\n                // Transactional operations\n                Order savedOrder = orderRepository.save(order);\n                inventoryService.updateStock(order);\n                return savedOrder;\n            } catch (StockException ex) {\n                status.setRollbackOnly();\n                throw ex;\n            }\n        });\n    }\n}"
                    }
                  ]
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "title": "Transaction Propagation",
      "multi-content": [
        {
          "title": "Description",
          "simple-content": "Transaction propagation defines how transactions relate to each other, especially when a transactional method calls another transactional method."
        },
        {
          "title": "Types",
          "multi-content": [
            {
              "title": "REQUIRED",
              "multi-content": [
                {
                  "title": "Description",
                  "simple-content": "Use current transaction, create new if none exists"
                },
                {
                  "title": "Usage",
                  "simple-content": "Default behavior, most use cases"
                }
              ]
            },
            {
              "title": "REQUIRES_NEW",
              "multi-content": [
                {
                  "title": "Description",
                  "simple-content": "Always create a new transaction"
                },
                {
                  "title": "Usage",
                  "simple-content": "Independent operations, error isolation"
                }
              ]
            },
            {
              "title": "SUPPORTS",
              "multi-content": [
                {
                  "title": "Description",
                  "simple-content": "Use current transaction if available, otherwise non-transactional"
                },
                {
                  "title": "Usage",
                  "simple-content": "Read operations that don't require transactions"
                }
              ]
            },
            {
              "title": "NOT_SUPPORTED",
              "multi-content": [
                {
                  "title": "Description",
                  "simple-content": "Execute non-transactionally, suspend current transaction"
                },
                {
                  "title": "Usage",
                  "simple-content": "Operations that should always run outside a transaction"
                }
              ]
            },
            {
              "title": "MANDATORY",
              "multi-content": [
                {
                  "title": "Description",
                  "simple-content": "Use existing transaction, throw exception if none exists"
                },
                {
                  "title": "Usage",
                  "simple-content": "Operations that must be part of a larger transaction"
                }
              ]
            },
            {
              "title": "NEVER",
              "multi-content": [
                {
                  "title": "Description",
                  "simple-content": "Execute non-transactionally, throw exception if transaction exists"
                },
                {
                  "title": "Usage",
                  "simple-content": "Operations that must not run within a transaction"
                }
              ]
            },
            {
              "title": "NESTED",
              "multi-content": [
                {
                  "title": "Description",
                  "simple-content": "Execute within a nested transaction if a current transaction exists"
                },
                {
                  "title": "Usage",
                  "simple-content": "Partial rollback capabilities (with some limitations)"
                }
              ]
            }
          ]
        },
        {
          "title": "code_examples",
          "multi-content": [
            {
              "title": "Composite Service",
              "simple-content": "@Service\npublic class CompositeService {\n    private final UserService userService;\n    private final AuditService auditService;\n    \n    @Transactional // REQUIRED by default\n    public void mainOperation() {\n        // Uses current transaction\n        userService.updateUser(user);\n        \n        try {\n            // Creates a new independent transaction\n            auditService.logOperation();\n        } catch (Exception e) {\n            // If this fails, it won't affect the main transaction\n            logger.error(\"Audit failed\", e);\n        }\n    }\n}\n\n@Service\npublic class AuditService {\n    @Transactional(propagation = Propagation.REQUIRES_NEW)\n    public void logOperation() {\n        // Always runs in a new transaction\n    }\n}"
            }
          ]
        }
      ]
    },
    {
      "title": "Transaction Patterns",
      "multi-content": [
        {
          "title": "Description",
          "simple-content": "Common design patterns for managing transactions effectively"
        },
        {
          "title": "Types",
          "multi-content": [
            {
              "title": "Unit of Work",
              "multi-content": [
                {
                  "title": "Description",
                  "simple-content": "Track changes and write them in a single transaction"
                },
                {
                  "title": "Implementation",
                  "simple-content": "JPA/Hibernate persistence context"
                },
                {
                  "title": "Details",
                  "simple-content": "Objects are tracked for changes (dirty checking), reduces database round trips, guarantees identity (same entity instance for same database row), cleared at transaction boundaries"
                }
              ]
            },
            {
              "title": "Optimistic Locking",
              "multi-content": [
                {
                  "title": "Description",
                  "simple-content": "Allow concurrent access but verify no changes before commit"
                },
                {
                  "title": "Implementation",
                  "simple-content": "@Version annotation in JPA"
                },
                {
                  "title": "Details",
                  "simple-content": "Assumes conflicts are rare and verifies at commit time that no conflicts have occurred"
                },
                {
                  "title": "code_examples",
                  "multi-content": [
                    {
                      "title": "JPA Entity with @Version",
                      "simple-content": "@Entity\npublic class Account {\n    @Id\n    private Long id;\n    \n    private BigDecimal balance;\n    \n    @Version\n    private Integer version;\n    \n    // Methods\n}\n\n// Usage\n@Transactional\npublic void withdraw(Long accountId, BigDecimal amount) {\n    Account account = accountRepository.findById(accountId)\n        .orElseThrow(() -> new AccountNotFoundException(accountId));\n    account.withdraw(amount);\n    accountRepository.save(account);\n    // If another transaction updated the account, OptimisticLockException will be thrown\n}"
                    }
                  ]
                }
              ]
            },
            {
              "title": "Pessimistic Locking",
              "multi-content": [
                {
                  "title": "Description",
                  "simple-content": "Lock resources when reading to prevent concurrent modifications"
                },
                {
                  "title": "Implementation",
                  "simple-content": "SELECT FOR UPDATE queries"
                },
                {
                  "title": "Details",
                  "simple-content": "Assumes conflicts will occur and locks resources before using them"
                },
                {
                  "title": "code_examples",
                  "multi-content": [
                    {
                      "title": "JPA Repository with Locking",
                      "simple-content": "@Lock(LockModeType.PESSIMISTIC_WRITE)\n@Query(\"SELECT a FROM Account a WHERE a.id = :id\")\nAccount findAndLockForUpdate(@Param(\"id\") Long id);\n\n// Usage\n@Transactional\npublic void withdraw(Long accountId, BigDecimal amount) {\n    Account account = accountRepository.findAndLockForUpdate(accountId);\n    account.withdraw(amount);\n    accountRepository.save(account);\n}"
                    }
                  ]
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "title": "JPA/Hibernate Transactions",
      "multi-content": [
        {
          "title": "Description",
          "simple-content": "How transactions are handled in JPA and Hibernate frameworks"
        },
        {
          "title": "Components",
          "multi-content": [
            {
              "title": "Entity Manager Transaction API",
              "multi-content": [
                {
                  "title": "Description",
                  "simple-content": "Core JPA transaction API"
                },
                {
                  "title": "code_examples",
                  "multi-content": [
                    {
                      "title": "Manual Transaction Management",
                      "simple-content": "EntityManager em = emf.createEntityManager();\nEntityTransaction tx = em.getTransaction();\ntry {\n    tx.begin();\n    \n    // Perform operations\n    User user = new User();\n    user.setName(\"John\");\n    em.persist(user);\n    \n    tx.commit();\n} catch (Exception e) {\n    if (tx.isActive()) {\n        tx.rollback();\n    }\n    throw e;\n} finally {\n    em.close();\n}"
                    }
                  ]
                }
              ]
            },
            {
              "title": "First-Level Cache",
              "multi-content": [
                {
                  "title": "Description",
                  "simple-content": "The EntityManager's persistence context acts as a first-level cache within a transaction"
                },
                {
                  "title": "Benefits",
                  "multi-content": [
                    "Objects are tracked for changes (dirty checking)",
                    "Reduces database round trips",
                    "Guarantees identity (same entity instance for same database row)",
                    "Cleared at transaction boundaries"
                  ]
                }
              ]
            },
            {
              "title": "Entity States",
              "multi-content": [
                {
                  "title": "Description",
                  "simple-content": "JPA entities transition between different states during transactions"
                },
                {
                  "title": "States",
                  "multi-content": [
                    {
                      "title": "Transient",
                      "simple-content": "Object not associated with persistence context"
                    },
                    {
                      "title": "Persistent",
                      "simple-content": "Object associated with persistence context and tracked"
                    },
                    {
                      "title": "Detached",
                      "simple-content": "Object was persistent but no longer associated"
                    },
                    {
                      "title": "Removed",
                      "simple-content": "Object marked for removal from database"
                    }
                  ]
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "title": "Distributed Transactions",
      "multi-content": [
        {
          "title": "Description",
          "simple-content": "Managing transactions that span multiple resources (databases, message brokers, web services)."
        },
        {
          "title": "Approaches",
          "multi-content": [
            {
              "title": "Two-Phase Commit (2PC)",
              "multi-content": [
                {
                  "title": "Description",
                  "simple-content": "Protocol for coordinating distributed transactions"
                },
                {
                  "title": "Phases",
                  "multi-content": [
                    "Prepare Phase: Coordinator asks all participants if they can commit",
                    "Commit Phase: If all agree, coordinator tells everyone to commit"
                  ]
                },
                {
                  "title": "Considerations",
                  "multi-content": [
                    "Provides strong consistency guarantees",
                    "Can impact system availability if coordinator fails",
                    "Potentially locks resources for extended periods"
                  ]
                }
              ]
            },
            {
              "title": "Eventual Consistency Models",
              "multi-content": [
                {
                  "title": "Description",
                  "simple-content": "Alternative approaches that are more scalable but offer weaker guarantees"
                },
                {
                  "title": "Patterns",
                  "multi-content": [
                    {
                      "title": "Saga Pattern",
                      "multi-content": [
                        {
                          "title": "Description",
                          "simple-content": "A sequence of local transactions, where each transaction updates a single service. If a transaction fails, compensating transactions undo previous changes."
                        },
                        {
                          "title": "code_examples",
                          "multi-content": [
                            {
                              "title": "Trip Booking Saga",
                              "simple-content": "@Transactional\npublic void bookTrip() {\n    try {\n        // Local transaction 1\n        Long flightBookingId = flightService.bookFlight(flightDetails);\n        \n        try {\n            // Local transaction 2\n            Long hotelBookingId = hotelService.bookHotel(hotelDetails);\n            \n            try {\n                // Local transaction 3\n                carService.rentCar(carDetails);\n            } catch (Exception e) {\n                // Compensating transaction for hotel\n                hotelService.cancelBooking(hotelBookingId);\n                // Compensating transaction for flight\n                flightService.cancelBooking(flightBookingId);\n                throw e;\n            }\n        } catch (Exception e) {\n            // Compensating transaction for flight\n            flightService.cancelBooking(flightBookingId);\n            throw e;\n        }\n    } catch (Exception e) {\n        // No compensating transactions needed\n        throw e;\n    }\n}"
                            }
                          ]
                        }
                      ]
                    },
                    {
                      "title": "Compensation Transactions",
                      "multi-content": [
                        {
                          "title": "Description",
                          "simple-content": "Transactions that undo the effects of previous transactions"
                        },
                        {
                          "title": "Usage",
                          "simple-content": "Critical for implementing saga pattern, error recovery"
                        }
                      ]
                    },
                    {
                      "title": "Outbox Pattern",
                      "multi-content": [
                        {
                          "title": "Description",
                          "simple-content": "Write to local database and an outbox table in the same transaction, then asynchronously process the outbox entries"
                        },
                        {
                          "title": "Benefits",
                          "multi-content": [
                            "Ensures reliable messaging with local transactions",
                            "Prevents message loss during system failures"
                          ]
                        }
                      ]
                    },
                    {
                      "title": "Event-Driven Architecture",
                      "multi-content": [
                        {
                          "title": "Description",
                          "simple-content": "Using events to coordinate state changes across services"
                        },
                        {
                          "title": "Considerations",
                          "multi-content": [
                            "Decouples services",
                            "Often used with eventual consistency models",
                            "Requires careful event design and handling"
                          ]
                        }
                      ]
                    }
                  ]
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "title": "Transaction Best Practices",
      "multi-content": [
        {
          "title": "Description",
          "simple-content": "Recommended approaches for effective transaction management"
        },
        {
          "title": "Categories",
          "multi-content": [
            {
              "title": "Transaction Design",
              "multi-content": [
                "Keep transactions short",
                "Don't perform non-DB operations in transactions",
                "Choose appropriate isolation level",
                "Handle exceptions properly",
                "Be aware of transaction boundaries",
                "Implement proper exception handling"
              ]
            },
            {
              "title": "Performance",
              "multi-content": [
                "Use read-only transactions when possible",
                "Batch operations for bulk updates",
                "Monitor transaction timeouts",
                "Consider using optimistic locking",
                "Implement proper caching strategy",
                "Use batch processing for bulk operations"
              ]
            },
            {
              "title": "Exception Handling",
              "multi-content": [
                "Define clear rollback rules",
                "Handle transaction exceptions appropriately",
                "Use TransactionTemplate for programmatic transactions",
                "Consider using @TransactionEventListener",
                "Clean up resources in finally blocks"
              ]
            }
          ]
        }
      ]
    },
    {
      "title": "Common Transaction Pitfalls",
      "multi-content": [
        {
          "title": "Description",
          "simple-content": "Common mistakes and problems with database transactions"
        },
        {
          "title": "Issues",
          "multi-content": [
            {
              "title": "Long-running transactions",
              "multi-content": [
                {
                  "title": "Impact",
                  "simple-content": "Tie up database resources, increase lock contention, reduce concurrency"
                },
                {
                  "title": "Solution",
                  "simple-content": "Break into smaller transactions"
                }
              ]
            },
            {
              "title": "Inappropriate isolation level",
              "multi-content": [
                {
                  "title": "Impact",
                  "simple-content": "Too low: data inconsistency, Too high: performance issues"
                },
                {
                  "title": "Solution",
                  "simple-content": "Choose isolation level based on specific requirements"
                }
              ]
            },
            {
              "title": "@Transactional on private methods",
              "multi-content": [
                {
                  "title": "Impact",
                  "simple-content": "Annotation is ignored unless method is public"
                },
                {
                  "title": "Solution",
                  "simple-content": "Extract to a public method or use AspectJ mode"
                }
              ]
            },
            {
              "title": "Transaction rollback for checked exceptions",
              "multi-content": [
                {
                  "title": "Impact",
                  "simple-content": "By default, Spring only rolls back for unchecked exceptions"
                },
                {
                  "title": "Solution",
                  "simple-content": "Specify rollbackFor = Exception.class"
                }
              ]
            },
            {
              "title": "Transaction context propagation in async operations",
              "multi-content": [
                {
                  "title": "Impact",
                  "simple-content": "Transaction context is lost in new threads"
                },
                {
                  "title": "Solution",
                  "simple-content": "Complete transactional work before async calls or use specific propagation settings"
                }
              ]
            },
            {
              "title": "Nested transactions misuse",
              "multi-content": [
                {
                  "title": "Impact",
                  "simple-content": "Unexpected rollback behavior"
                },
                {
                  "title": "Solution",
                  "simple-content": "Understand propagation behaviors"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "title": "Interview Questions",
      "multi-content": [
        {
          "title": "ACID Properties",
          "multi-content": [
            {
              "title": "Question",
              "simple-content": "What are ACID properties in database transactions?"
            },
            {
              "title": "Answer",
              "simple-content": "ACID stands for Atomicity, Consistency, Isolation, and Durability. These are the four key properties that guarantee reliable processing of database transactions.\n\n- **Atomicity** ensures that all operations in a transaction either complete entirely or have no effect.\n- **Consistency** ensures that a transaction brings the database from one valid state to another.\n- **Isolation** ensures that concurrent transactions don't interfere with each other.\n- **Durability** ensures that once a transaction is committed, it remains so, even in the event of system failure."
            }
          ]
        },
        {
          "title": "Spring Transaction Management",
          "multi-content": [
            {
              "title": "Question",
              "simple-content": "How does Spring handle transaction management?"
            },
            {
              "title": "Answer",
              "simple-content": "Spring provides both declarative and programmatic transaction management. Declarative transaction management is typically done using the `@Transactional` annotation, which can be applied at the class or method level. Behind the scenes, Spring uses AOP proxies to wrap transactional methods with transaction handling code that starts, commits, or rolls back transactions as needed. Spring's transaction management works across different transaction APIs like JTA, JDBC, Hibernate, and JPA, providing a consistent programming model."
            }
          ]
        },
        {
          "title": "Isolation Levels",
          "multi-content": [
            {
              "title": "Question",
              "simple-content": "What is the difference between different transaction isolation levels?"
            },
            {
              "title": "Answer",
              "simple-content": "Transaction isolation levels control how changes made by one transaction are visible to other concurrent transactions:\n\n- **READ_UNCOMMITTED**: Allows dirty reads (uncommitted changes from other transactions), non-repeatable reads, and phantom reads. Offers highest performance but lowest safety.\n- **READ_COMMITTED**: Prevents dirty reads but allows non-repeatable reads and phantom reads. A good balance between performance and safety.\n- **REPEATABLE_READ**: Prevents dirty reads and non-repeatable reads but allows phantom reads. Provides better consistency guarantees.\n- **SERIALIZABLE**: Prevents all concurrency issues (dirty reads, non-repeatable reads, phantom reads) but has the lowest concurrency and performance."
            }
          ]
        },
        {
          "title": "Transaction Propagation",
          "multi-content": [
            {
              "title": "Question",
              "simple-content": "Explain transaction propagation in Spring and when you would use different propagation types?"
            },
            {
              "title": "Answer",
              "simple-content": "Transaction propagation defines how transactions relate to each other when transactional methods call other transactional methods:\n\n- **REQUIRED** (default): Use current transaction, create new if none exists. This is appropriate for most use cases.\n- **REQUIRES_NEW**: Always create a new transaction. Use when you need operations to execute in an independent transaction, even if a transaction already exists.\n- **SUPPORTS**: Use current transaction if one exists, otherwise execute non-transactionally. Suitable for read operations that don't necessarily need a transaction.\n- **MANDATORY**: Use existing transaction, throw exception if none exists. Use when an operation must always be part of a larger transaction.\n- **NESTED**: Execute within a nested transaction if current transaction exists. Useful when you want to be able to roll back specific parts of a transaction."
            }
          ]
        },
        {
          "title": "Optimistic vs Pessimistic Locking",
          "multi-content": [
            {
              "title": "Question",
              "simple-content": "What is optimistic locking and when would you use it over pessimistic locking?"
            },
            {
              "title": "Answer",
              "simple-content": "Optimistic locking assumes conflicts are rare and only checks for conflicts at commit time using a version field or timestamp. It's appropriate when:\n\n1. Conflicts are rare\n2. High concurrency is needed\n3. Transactions are typically short\n4. The cost of occasionally retrying a transaction is acceptable\n\nIn contrast, pessimistic locking acquires locks upfront and prevents other transactions from accessing the data. Use pessimistic locking when:\n\n1. Conflicts are frequent\n2. The data is critical\n3. The cost of a failed transaction is high\n4. Concurrent access needs to be strictly controlled"
            }
          ]
        },
        {
          "title": "Distributed Transactions",
          "multi-content": [
            {
              "title": "Question",
              "simple-content": "How would you handle a distributed transaction across multiple databases or services?"
            },
            {
              "title": "Answer",
              "simple-content": "For distributed transactions, there are several approaches:\n\n1. **Two-Phase Commit (2PC)**: A protocol that ensures either all participants commit or all abort a transaction. It's reliable but can impact performance and availability.\n    \n2. **Saga Pattern**: Breaking a distributed transaction into a sequence of local transactions, with compensating transactions to undo changes if a step fails. This is more scalable but has eventual consistency.\n    \n3. **Outbox Pattern**: Write to local database and an outbox table in the same transaction, then asynchronously process the outbox entries to trigger changes in other systems.\n    \n4. **Change Data Capture (CDC)**: Monitor database transaction logs to detect changes and propagate them to other systems.\n    \nFor simpler scenarios in Spring, JTA (Java Transaction API) with an appropriate transaction manager can handle transactions across multiple resources."
            }
          ]
        }
      ]
    }
  ]
}