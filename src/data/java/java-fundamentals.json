{
  "title": "Java Fundamentals",
  "sections": [
    {
      "title": "Core Concepts",
      "subsections": [
        {
          "title": "What is Java?",
          "content": "Java is a high-level, object-oriented programming language designed for platform independence through its \"write once, run anywhere\" capability. It compiles to bytecode that runs on the Java Virtual Machine (JVM).",
          "keyFeatures": [
            {
              "feature": "Platform Independence",
              "description": "Java programs can run on any device with a compatible JVM"
            },
            {
              "feature": "Object-Oriented",
              "description": "Supports encapsulation, inheritance, polymorphism, and abstraction"
            },
            {
              "feature": "Robust and Secure",
              "description": "Provides automatic memory management, exception handling, and strong type checking"
            },
            {
              "feature": "Multi-threading",
              "description": "Facilitates concurrent execution of tasks"
            },
            {
              "feature": "Rich Standard Library",
              "description": "Comprehensive APIs for diverse functionalities"
            }
          ]
        },
        {
          "title": "Java Platform Components",
          "content": "",
          "components": [
            {
              "name": "JDK (Java Development Kit)",
              "description": "Complete development package that includes tools for Java application development (javac, jdb, etc.)",
              "tools": [
                "javac - Java compiler that converts source code to bytecode",
                "java - Java application launcher that starts the JVM and executes bytecode",
                "javadoc - Documentation generator that creates API documentation from Java source code comments",
                "jdb - Java Debugger"
              ]
            },
            {
              "name": "JRE (Java Runtime Environment)",
              "description": "Provides the runtime environment, including Java class libraries and JVM",
              "includes": [
                "Class libraries",
                "Runtime environment"
              ]
            },
            {
              "name": "JVM (Java Virtual Machine)",
              "description": "Executes bytecode, translating it into native machine code",
              "features": [
                "Platform-independent execution",
                "Garbage Collection",
                "Memory management",
                "Just-In-Time (JIT) compilation"
              ]
            }
          ],
          "diagram": "┌─────────────────────────────────────────┐\n│ JDK (Java Development Kit)              │\n│  ┌──────────────────────────────────┐   │\n│  │ JRE (Java Runtime Environment)   │   │\n│  │  ┌───────────────────────────┐   │   │\n│  │  │ JVM (Java Virtual Machine)│   │   │\n│  │  └───────────────────────────┘   │   │\n│  │                                  │   │\n│  │  Java Class Libraries            │   │\n│  └──────────────────────────────────┘   │\n│                                         │\n│  Development Tools                      │\n│  (javac, java, javadoc, etc.)           │\n└─────────────────────────────────────────┘"
        },
        {
          "title": "JVM Architecture",
          "content": "The JVM has three main components that work together to load, verify, and execute Java bytecode:",
          "components": [
            {
              "name": "Class Loader",
              "function": "Loads, links, and initializes classes in the JVM.",
              "stages": [
                {
                  "name": "Loading",
                  "description": "Reads the class file and creates binary data"
                },
                {
                  "name": "Linking",
                  "description": "Performs verification, preparation, and resolution of symbolic references"
                },
                {
                  "name": "Initialization",
                  "description": "Executes static initializers and initializes static fields"
                }
              ]
            },
            {
              "name": "Runtime Data Area",
              "function": "Memory areas managed during runtime",
              "areas": [
                {
                  "name": "Method Area",
                  "description": "Stores class structures, methods, and constant runtime pool"
                },
                {
                  "name": "Heap",
                  "description": "Stores all objects and their instance variables"
                },
                {
                  "name": "Stack",
                  "description": "Thread-specific area storing local variables and partial results"
                },
                {
                  "name": "PC Register",
                  "description": "Contains the address of the JVM instruction currently being executed"
                },
                {
                  "name": "Native Method Stack",
                  "description": "Used for native method execution"
                }
              ]
            },
            {
              "name": "Execution Engine",
              "function": "Executes bytecode using an interpreter and/or a JIT compiler.",
              "components": [
                {
                  "name": "Interpreter",
                  "description": "Interprets bytecode instructions one by one"
                },
                {
                  "name": "JIT Compiler",
                  "description": "Compiles frequently executed bytecode to native machine code for performance"
                },
                {
                  "name": "Garbage Collector",
                  "description": "Automatically reclaims memory from unused objects"
                }
              ]
            }
          ]
        },
        {
          "title": "Compilation and Execution Process",
          "content": "",
          "steps": [
            {
              "step": 1,
              "description": "Write Java source code (.java file)"
            },
            {
              "step": 2,
              "description": "Compile with javac compiler to produce bytecode (.class file)"
            },
            {
              "step": 3,
              "description": "Execute bytecode on JVM"
            },
            {
              "step": 4,
              "description": "JVM translates bytecode to machine-specific code using JIT (Just-In-Time) compiler"
            }
          ]
        },
        {
          "title": "Main Method",
          "content": "The entry point for Java applications:",
          "code": "public static void main(String[] args) {\n    // Application starts here\n}",
          "keywords": [
            {
              "keyword": "public",
              "description": "Accessible from outside the class"
            },
            {
              "keyword": "static",
              "description": "Belongs to the class, not to instances"
            },
            {
              "keyword": "void",
              "description": "Returns no value"
            },
            {
              "keyword": "main",
              "description": "The specific method name recognized as the entry point"
            },
            {
              "keyword": "String[] args",
              "description": "Command-line arguments passed to the program"
            }
          ]
        }
      ]
    },
    {
      "title": "Data Types and Variables",
      "subsections": [
        {
          "title": "Primitive Data Types",
          "content": "Java has eight primitive data types that represent basic values:",
          "types": [
            {
              "dataType": "byte",
              "size": "8 bits",
              "range": "-128 to 127",
              "defaultValue": "0",
              "usage": "Space optimization for arrays"
            },
            {
              "dataType": "short",
              "size": "16 bits",
              "range": "-32,768 to 32,767",
              "defaultValue": "0",
              "usage": "Memory savings in large arrays"
            },
            {
              "dataType": "int",
              "size": "32 bits",
              "range": "-2^31 to 2^31-1",
              "defaultValue": "0",
              "usage": "Default for integer values"
            },
            {
              "dataType": "long",
              "size": "64 bits",
              "range": "-2^63 to 2^63-1",
              "defaultValue": "0L",
              "usage": "For larger integer values"
            },
            {
              "dataType": "float",
              "size": "32 bits",
              "range": "~±3.40282347E+38F",
              "defaultValue": "0.0f",
              "usage": "Single-precision floating point"
            },
            {
              "dataType": "double",
              "size": "64 bits",
              "range": "~±1.79769313486231570E+308",
              "defaultValue": "0.0d",
              "usage": "Default for decimal values"
            },
            {
              "dataType": "char",
              "size": "16 bits",
              "range": "0 to 65,535 (Unicode)",
              "defaultValue": "'\\u0000'",
              "usage": "Single Unicode character"
            },
            {
              "dataType": "boolean",
              "size": "1 bit",
              "range": "true or false",
              "defaultValue": "false",
              "usage": "Logical conditions"
            }
          ]
        },
        {
          "title": "Reference Data Types",
          "content": "Reference data types store references (memory addresses) to objects rather than storing the actual values:",
          "types": [
            {
              "type": "Classes",
              "description": "User-defined blueprint for objects"
            },
            {
              "type": "Interfaces",
              "description": "Abstract contract for classes"
            },
            {
              "type": "Arrays",
              "description": "Collection of elements of the same type"
            },
            {
              "type": "Strings",
              "description": "Special class representing text (immutable sequence of characters)"
            },
            {
              "type": "Enums",
              "description": "Special type of class for constants"
            }
          ]
        },
        {
          "title": "Variable Types",
          "content": "",
          "types": [
            {
              "type": "Local Variables",
              "description": "Declared inside methods, constructors, or blocks"
            },
            {
              "type": "Instance Variables",
              "description": "Declared in a class but outside any method"
            },
            {
              "type": "Static Variables (Class Variables)",
              "description": "Declared with the `static` keyword"
            }
          ]
        },
        {
          "title": "Type Conversion",
          "content": "",
          "conversions": [
            {
              "type": "Widening Conversion (Implicit)",
              "description": "Converting smaller type to larger type",
              "example": "int intValue = 10;\ndouble doubleValue = intValue; // Automatic conversion"
            },
            {
              "type": "Narrowing Conversion (Explicit)",
              "description": "Converting larger type to smaller type",
              "example": "double doubleValue = 10.5;\nint intValue = (int) doubleValue; // Explicit cast required"
            }
          ]
        },
        {
          "title": "Constants",
          "content": "Constants in Java are declared using the `final` keyword:",
          "examples": [
            "final double PI = 3.14159;",
            "static final int MAX_USERS = 10000;  // Class constant"
          ]
        }
      ]
    },
    {
      "title": "Object-Oriented Programming Concepts",
      "subsections": [
        {
          "title": "Classes and Objects",
          "content": "",
          "concepts": [
            {
              "concept": "Class",
              "description": "Blueprint for creating objects"
            },
            {
              "concept": "Object",
              "description": "Instance of a class with state (fields) and behavior (methods)"
            }
          ],
          "example": "public class Car {\n    // Fields (state)\n    private String model;\n    private int year;\n    \n    // Constructor\n    public Car(String model, int year) {\n        this.model = model;\n        this.year = year;\n    }\n    \n    // Methods (behavior)\n    public void drive() {\n        System.out.println(\"Driving the \" + model);\n    }\n}\n\n// Creating an object\nCar myCar = new Car(\"Tesla\", 2023);\nmyCar.drive();"
        },
        {
          "title": "The Four Pillars of OOP",
          "content": "",
          "pillars": [
            {
              "name": "Encapsulation",
              "description": "Encapsulation is the bundling of data (fields) and methods that operate on that data within a single unit (class), restricting direct access to the data.",
              "implementation": [
                "Use private access modifiers for fields",
                "Provide public getter and setter methods for controlled access"
              ],
              "benefits": [
                "Data hiding and protection",
                "Maintainability and flexibility",
                "Control over data validation"
              ],
              "definition": "Encapsulating data and behavior into a single unit or class and restricting access to some components.",
              "example": "public class Employee {\n    private int exp; // Field is private (encapsulated)\n    \n    // Getter method\n    public int getExp() {\n        return exp;\n    }\n    \n    // Setter method with validation\n    public void setExp(int exp) {\n        if (exp < 0) {\n            throw new IllegalArgumentException(\"Experience cannot be negative\");\n        }\n        this.exp = exp;\n    }\n}"
            },
            {
              "name": "Inheritance",
              "description": "Inheritance allows a class to inherit properties and behaviors from another class, promoting code reuse and establishing a parent-child relationship.",
              "implementation": [
                "Use `extends` keyword for class inheritance",
                "Use `implements` keyword for interface implementation"
              ],
              "types": [
                {
                  "type": "Single Inheritance",
                  "description": "A class inherits from one class"
                },
                {
                  "type": "Multilevel Inheritance",
                  "description": "A class inherits from a child class"
                },
                {
                  "type": "Hierarchical Inheritance",
                  "description": "Multiple classes inherit from one class"
                }
              ],
              "definition": "A mechanism where one class can inherit fields and methods from another class.",
              "example": "// Parent class\npublic class Employee {\n    protected String name;\n    protected double salary;\n    \n    public void work() {\n        System.out.println(\"Employee working\");\n    }\n}\n\n// Child class inheriting from Employee\npublic class Manager extends Employee {\n    private int teamSize;\n    \n    public void manage() {\n        System.out.println(\"Managing team of \" + teamSize);\n    }\n    \n    // Override parent method\n    @Override\n    public void work() {\n        System.out.println(\"Manager working on leadership tasks\");\n    }\n}"
            },
            {
              "name": "Polymorphism",
              "description": "Polymorphism allows objects to take different forms depending on the context, primarily through method overloading and overriding.",
              "types": [
                {
                  "type": "Compile-Time Polymorphism (Static Binding)",
                  "description": "Method overloading: Same method name with different parameters"
                },
                {
                  "type": "Runtime Polymorphism (Dynamic Binding)",
                  "description": "Method overriding: Subclass provides specific implementation of method in parent class"
                }
              ],
              "definition": "The ability of an object to take on multiple forms. In Java, we distinguish static polymorphism (method overloading, resolved at compile-time) and dynamic polymorphism (method overriding, resolved at runtime).",
              "example": "// Method Overloading (Compile-time polymorphism)\npublic class Calculator {\n    public int add(int a, int b) {\n        return a + b;\n    }\n    \n    public double add(double a, double b) {\n        return a + b;\n    }\n    \n    public int add(int a, int b, int c) {\n        return a + b + c;\n    }\n}\n\n// Method Overriding (Runtime polymorphism)\nclass Animal {\n    public void makeSound() {\n        System.out.println(\"Animal makes a sound\");\n    }\n}\n\nclass Dog extends Animal {\n    @Override\n    public void makeSound() {\n        System.out.println(\"Dog barks\");\n    }\n}\n\nclass Cat extends Animal {\n    @Override\n    public void makeSound() {\n        System.out.println(\"Cat meows\");\n    }\n}",
              "comparison": [
                {
                  "aspect": "When it occurs",
                  "methodOverloading": "Compile-time (static binding)",
                  "methodOverriding": "Runtime (dynamic binding)"
                },
                {
                  "aspect": "Parameters",
                  "methodOverloading": "Must differ in type, number, or order",
                  "methodOverriding": "Must be the same"
                },
                {
                  "aspect": "Return type",
                  "methodOverloading": "Can be different",
                  "methodOverriding": "Must be the same or covariant"
                },
                {
                  "aspect": "Access modifier",
                  "methodOverloading": "Can be different",
                  "methodOverriding": "Cannot be more restrictive"
                },
                {
                  "aspect": "Exceptions",
                  "methodOverloading": "Can throw different exceptions",
                  "methodOverriding": "Cannot throw broader exceptions"
                }
              ]
            },
            {
              "name": "Abstraction",
              "description": "Abstraction focuses on hiding implementation details and showing only the necessary features of an object.",
              "implementation": [
                {
                  "type": "Abstract Classes",
                  "description": "Can contain both abstract and concrete methods"
                },
                {
                  "type": "Interfaces",
                  "description": "Define contracts that implementing classes must fulfill"
                }
              ],
              "definition": "Hiding the complex implementation details and showing only the essential features.",
              "example": "// Abstract class\npublic abstract class Shape {\n    // Concrete method\n    public void display() {\n        System.out.println(\"Displaying shape\");\n    }\n    \n    // Abstract method - no implementation\n    public abstract double calculateArea();\n}\n\n// Interface\npublic interface Drawable {\n    void draw(); // Abstract method\n    \n    // Default method (Java 8+)\n    default void info() {\n        System.out.println(\"This is a drawable object\");\n    }\n}\n\n// Concrete class implementing abstraction\npublic class Circle extends Shape implements Drawable {\n    private double radius;\n    \n    public Circle(double radius) {\n        this.radius = radius;\n    }\n    \n    @Override\n    public double calculateArea() {\n        return Math.PI * radius * radius;\n    }\n    \n    @Override\n    public void draw() {\n        System.out.println(\"Drawing a circle\");\n    }\n}"
            }
          ]
        },
        {
          "title": "Access Modifiers",
          "content": "Access modifiers control the visibility and accessibility of classes, methods, and fields:",
          "modifiers": [
            {
              "modifier": "public",
              "class": true,
              "package": true,
              "subclass": true,
              "world": true
            },
            {
              "modifier": "protected",
              "class": true,
              "package": true,
              "subclass": true,
              "world": false
            },
            {
              "modifier": "default (no modifier)",
              "class": true,
              "package": true,
              "subclass": false,
              "world": false
            },
            {
              "modifier": "private",
              "class": true,
              "package": false,
              "subclass": false,
              "world": false
            }
          ]
        },
        {
          "title": "Non-Access Modifiers",
          "content": "",
          "modifiers": [
            {
              "modifier": "static",
              "description": "Belongs to the class rather than to instances"
            },
            {
              "modifier": "final",
              "useCases": [
                "For classes: Cannot be extended",
                "For methods: Cannot be overridden",
                "For variables: Cannot be reassigned after initialization"
              ]
            },
            {
              "modifier": "abstract",
              "useCases": [
                "For classes: Cannot be instantiated, may contain abstract methods",
                "For methods: Declared without implementation"
              ]
            },
            {
              "modifier": "synchronized",
              "description": "Controls thread access to critical code sections"
            },
            {
              "modifier": "volatile",
              "description": "Ensures a variable is always read from main memory, not from thread cache"
            },
            {
              "modifier": "transient",
              "description": "Fields marked as transient are not serialized"
            },
            {
              "modifier": "native",
              "description": "Indicates a method implemented in platform-dependent code"
            }
          ]
        }
      ]
    },
    {
      "title": "Memory Management",
      "subsections": [
        {
          "title": "Stack vs Heap Memory",
          "content": "",
          "memory": [
            {
              "type": "Stack Memory",
              "characteristics": [
                "Stores local variables, method calls, and references",
                "Thread-specific (each thread has its own stack)",
                "Automatic memory management (LIFO - Last In, First Out)",
                "Faster access than heap",
                "Limited size",
                "Used for static memory allocation",
                "Primitive data types stored here"
              ],
              "example": "public void calculateSum(int a) {\n    int b = 5;\n    String name = \"John\"; // The reference is stored in stack, actual string in heap\n    double result = a + b;\n}"
            },
            {
              "type": "Heap Memory",
              "characteristics": [
                "Stores objects and arrays",
                "Shared among all threads",
                "Managed by Garbage Collector",
                "Slower access than stack",
                "Larger size",
                "Used for dynamic memory allocation",
                "Objects and instance variables stored here"
              ],
              "example": "public class Memory {\n    private int[] numbers = new int[10]; // Array object stored in heap\n    public void createObjects() {\n        Person john = new Person(\"John\"); // Person object stored in heap\n    }\n}"
            }
          ],
          "diagram": "┌───────────────────┐     ┌───────────────────────────┐\n│  Stack Memory     │     │      Heap Memory          │\n├───────────────────┤     ├───────────────────────────┤\n│ Thread 1 Stack    │     │                           │\n│ - Local variables │     │     Objects               │\n│ - Method frames   │     │     Arrays                │\n│ - References ─────┼────►│     Class instances       │\n│                   │     │                           │\n├───────────────────┤     │                           │\n│ Thread 2 Stack    │     │                           │\n│ ...               │     │                           │\n└───────────────────┘     └───────────────────────────┘"
        },
        {
          "title": "Variable Storage",
          "content": "",
          "variables": [
            {
              "type": "Local variables",
              "storage": "Stack",
              "lifecycle": "Method execution",
              "scope": "Method, block"
            },
            {
              "type": "Instance variables",
              "storage": "Heap (within object)",
              "lifecycle": "Object lifetime",
              "scope": "Entire class"
            },
            {
              "type": "Static variables",
              "storage": "Method Area (logical part of heap)",
              "lifecycle": "Class lifetime",
              "scope": "Entire application"
            }
          ]
        },
        {
          "title": "Garbage Collection",
          "content": "Java's Garbage Collector automatically reclaims memory occupied by objects that are no longer in use:",
          "details": [
            "Objects with no references are eligible for garbage collection",
            "GC process includes marking, sweeping, and compacting memory",
            "Different GC algorithms for different scenarios (Serial, Parallel, CMS, G1)",
            "Can be influenced but not directly controlled by the programmer"
          ],
          "process": [
            {
              "step": "Marking",
              "description": "Identifies live objects"
            },
            {
              "step": "Sweeping",
              "description": "Removes unused objects"
            },
            {
              "step": "Compaction",
              "description": "Reorganizes memory to reduce fragmentation"
            }
          ],
          "collectors": [
            {
              "name": "Serial Garbage Collector",
              "description": "A single-threaded collector, suitable for single-core systems and applications with small data requirements.",
              "flag": "-XX:+UseSerialGC"
            },
            {
              "name": "Parallel Garbage Collector",
              "description": "Uses multiple threads for GC operations, making it suitable for high-throughput applications.",
              "flag": "-XX:+UseParallelGC"
            },
            {
              "name": "CMS (Concurrent Mark-Sweep) Garbage Collector",
              "description": "Designed for applications that prioritize low latency; minimizes pause times by performing GC concurrently with application threads.",
              "flag": "-XX:+UseConcMarkSweepGC"
            },
            {
              "name": "G1 (Garbage-First) Garbage Collector",
              "description": "Divides the heap into regions and focuses on collecting regions with the most garbage, making it suitable for larger heaps and minimizing pauses.",
              "flag": "-XX:+UseG1GC"
            },
            {
              "name": "Z Garbage Collector",
              "description": "A low-latency collector designed for large heap sizes, keeping pause times very low.",
              "flag": "-XX:+UseZGC"
            }
          ],
          "tuning": [
            "Use command-line options like `-XX:+UseG1GC` or `-XX:+UseParallelGC` to select the garbage collector.",
            "Adjust heap size with `-Xms` (initial heap size) and `-Xmx` (maximum heap size) options to provide adequate memory.",
            "Monitor GC behavior using tools like VisualVM or Java Flight Recorder for performance insights."
          ]
        }
      ]
    },
    {
      "title": "Constructors",
      "subsections": [
        {
          "title": "Types of Constructors",
          "content": "Constructors are special methods used to initialize objects. They have the same name as the class and are called when an object is created.",
          "types": [
            {
              "type": "Default Constructor",
              "description": "No parameters",
              "notes": "Provided by Java if no other constructor is defined"
            },
            {
              "type": "Parameterized Constructor",
              "description": "Takes parameters to initialize object state"
            },
            {
              "type": "Copy Constructor",
              "description": "Creates a new object as a copy of an existing object"
            }
          ],
          "example": "public class Student {\n    private String name;\n    private int age;\n    \n    // Default constructor\n    public Student() {\n        name = \"Unknown\";\n        age = 0;\n    }\n    \n    // Parameterized constructor\n    public Student(String name, int age) {\n        this.name = name;\n        this.age = age;\n    }\n    \n    // Copy constructor\n    public Student(Student other) {\n        this.name = other.name;\n        this.age = other.age;\n    }\n}"
        },
        {
          "title": "Constructor Chaining",
          "content": "Constructor chaining is the process of calling one constructor from another in the same class:",
          "example": "public class Vehicle {\n    private String brand;\n    private String model;\n    \n    // Constructor with both parameters\n    public Vehicle(String brand, String model) {\n        this.brand = brand;\n        this.model = model;\n    }\n    \n    // Constructor with one parameter, chains to the two-parameter constructor\n    public Vehicle(String brand) {\n        this(brand, \"Unknown\"); // Calls the constructor above\n    }\n    \n    // Default constructor, chains to the one-parameter constructor\n    public Vehicle() {\n        this(\"Unknown\"); // Calls the constructor above\n    }\n}"
        }
      ]
    },
    {
      "title": "Keywords and Modifiers",
      "subsections": [
        {
          "title": "this Keyword",
          "content": "The `this` keyword refers to the current instance of the class:",
          "uses": [
            "Disambiguate between instance variables and parameters",
            "Pass the current object to another method",
            "Call another constructor in the same class"
          ],
          "example": "public class Person {\n    private String name;\n    \n    public void setName(String name) {\n        this.name = name; // Disambiguate between field and parameter\n    }\n    \n    public void introduce(Person otherPerson) {\n        otherPerson.greet(this); // Pass current object\n    }\n}"
        },
        {
          "title": "super Keyword",
          "content": "The `super` keyword refers to the parent class:",
          "uses": [
            "Access parent class members (fields, methods)",
            "Call parent class constructor"
          ],
          "example": "class Animal {\n    protected String type;\n    \n    public Animal(String type) {\n        this.type = type;\n    }\n    \n    public void makeSound() {\n        System.out.println(\"Some sound\");\n    }\n}\n\nclass Dog extends Animal {\n    private String breed;\n    \n    public Dog(String breed) {\n        super(\"Dog\"); // Call parent constructor\n        this.breed = breed;\n    }\n    \n    @Override\n    public void makeSound() {\n        super.makeSound(); // Call parent method\n        System.out.println(\"Bark\");\n    }\n}"
        },
        {
          "title": "final Keyword",
          "content": "The `final` keyword can be applied to different entities:",
          "applications": [
            {
              "type": "final variable",
              "description": "Cannot be reassigned after initialization"
            },
            {
              "type": "final method",
              "description": "Cannot be overridden in subclasses"
            },
            {
              "type": "final class",
              "description": "Cannot be extended (subclassed)"
            }
          ],
          "example": "// Final variable\nfinal int MAX_SPEED = 120; // Constant (cannot be changed)\n\n// Final method\npublic final void secureMethod() {\n    // Cannot be overridden\n}\n\n// Final class\npublic final class SecurityManager {\n    // Cannot be extended\n}"
        },
        {
          "title": "static Keyword",
          "content": "The `static` keyword is used for variables, methods, blocks, and nested classes that belong to the class rather than instances:",
          "applications": [
            {
              "type": "static variable",
              "description": "Shared among all instances of the class"
            },
            {
              "type": "static method",
              "description": "Can be called without creating an instance"
            },
            {
              "type": "static block",
              "description": "Executed when the class is loaded by the JVM"
            },
            {
              "type": "static nested class",
              "description": "Associated with the outer class, not instances"
            }
          ],
          "example": "public class MathUtil {\n    // Static variable\n    public static final double PI = 3.14159;\n    \n    // Static block (executed when class is loaded)\n    static {\n        System.out.println(\"MathUtil class loaded\");\n    }\n    \n    // Static method\n    public static int square(int num) {\n        return num * num;\n    }\n    \n    // Static nested class\n    public static class Calculator {\n        public static int add(int a, int b) {\n            return a + b;\n        }\n    }\n}\n\n// Usage without instantiation\ndouble area = MathUtil.PI * radius * radius;\nint squared = MathUtil.square(5);\nint sum = MathUtil.Calculator.add(3, 4);"
        }
      ]
    },
    {
      "title": "Classes and Interfaces",
      "subsections": [
        {
          "title": "Class Types",
          "content": "",
          "types": [
            {
              "type": "Regular (Top-Level) Class",
              "description": "Standard class defined at file level"
            },
            {
              "type": "Inner Class (Non-static Nested Class)",
              "description": "Class defined within another class",
              "notes": "Has access to outer class members"
            },
            {
              "type": "Static Nested Class",
              "description": "Static class defined within another class",
              "notes": "No access to outer class instance variables"
            },
            {
              "type": "Abstract Class",
              "description": "Cannot be instantiated",
              "notes": "May contain abstract and concrete methods"
            },
            {
              "type": "Final Class",
              "description": "Cannot be subclassed"
            },
            {
              "type": "Anonymous Class",
              "description": "Class without a name, defined and instantiated in a single expression"
            }
          ],
          "example": "// Regular class\npublic class OuterClass {\n    private int outerField = 10;\n    \n    // Inner class (non-static nested class)\n    public class InnerClass {\n        public void printOuterField() {\n            System.out.println(outerField); // Can access outer class fields\n        }\n    }\n    \n    // Static nested class\n    public static class StaticNestedClass {\n        public void printMessage() {\n            // Cannot access outerField directly\n            System.out.println(\"Inside static nested class\");\n        }\n    }\n    \n    public void createAnonymousClass() {\n        // Anonymous class\n        Runnable r = new Runnable() {\n            @Override\n            public void run() {\n                System.out.println(\"Anonymous class running\");\n            }\n        };\n    }\n}\n\n// Abstract class\npublic abstract class Shape {\n    public abstract double area();\n    \n    public void display() {\n        System.out.println(\"This is a shape\");\n    }\n}\n\n// Final class\npublic final class Utility {\n    // Cannot be subclassed\n}"
        },
        {
          "title": "Interfaces",
          "content": "Interfaces define contracts that implementing classes must fulfill:",
          "notes": [
            "Prior to Java 8, contained only abstract methods",
            "As of Java 8, can contain default and static methods",
            "As of Java 9, can contain private methods"
          ],
          "example": "public interface Playable {\n    // Abstract method (implicitly public and abstract)\n    void play();\n    \n    // Default method (Java 8+)\n    default void pause() {\n        System.out.println(\"Pausing playback\");\n    }\n    \n    // Static method (Java 8+)\n    static boolean isSupported(String format) {\n        return true;\n    }\n    \n    // Private method (Java 9+)\n    private void internalHelper() {\n        System.out.println(\"Helper method\");\n    }\n}"
        },
        {
          "title": "Enum Types",
          "content": "Enums are special classes that represent a group of constants:",
          "example": "public enum Day {\n    MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY;\n    \n    // Enums can have fields, methods, and constructors\n    private boolean isWeekday;\n    \n    static {\n        // Initialize weekday status\n        MONDAY.isWeekday = true;\n        TUESDAY.isWeekday = true;\n        // ...\n    }\n    \n    public boolean isWeekday() {\n        return isWeekday;\n    }\n}\n\n// Usage\nDay today = Day.MONDAY;\nif (today.isWeekday()) {\n    System.out.println(\"It's a workday\");\n}"
        },
        {
          "title": "Enums with Fields and Methods",
          "content": "",
          "example": "public enum Planet {\n    MERCURY(3.303e+23, 2.4397e6),\n    VENUS(4.869e+24, 6.0518e6),\n    EARTH(5.976e+24, 6.37814e6);\n    \n    private final double mass;   // in kilograms\n    private final double radius; // in meters\n    \n    Planet(double mass, double radius) {\n        this.mass = mass;\n        this.radius = radius;\n    }\n    \n    public double getMass() {\n        return mass;\n    }\n    \n    public double getSurfaceGravity() {\n        return G * mass / (radius * radius);\n    }\n    \n    private static final double G = 6.67300E-11;\n}"
        },
        {
          "title": "Enum Methods",
          "content": "Built-in methods available for all enums:",
          "methods": [
            {
              "method": "values()",
              "description": "Returns an array of all enum constants"
            },
            {
              "method": "valueOf(String name)",
              "description": "Returns the enum constant with the specified name"
            },
            {
              "method": "name()",
              "description": "Returns the name of the enum constant"
            },
            {
              "method": "ordinal()",
              "description": "Returns the position of the enum constant (zero-based)"
            }
          ],
          "example": "// Iterating through enum values\nfor (Day day : Day.values()) {\n    System.out.println(day);\n}"
        }
      ]
    },
    {
      "title": "String Handling",
      "subsections": [
        {
          "title": "String Immutability",
          "content": "Strings in Java are immutable - once created, their values cannot be changed:",
          "example": "String s = \"Hello\";\ns.concat(\" World\");  // This creates a new String\nSystem.out.println(s);  // Still outputs \"Hello\"\n\n// To change the reference:\ns = s.concat(\" World\");  // Now s points to the new String \"Hello World\""
        },
        {
          "title": "String Pool",
          "content": "Java maintains a special memory area called the String Pool to optimize memory usage by reusing string literals.",
          "example": "String s1 = \"Hello\";  // Goes into string pool\nString s2 = \"Hello\";  // Reuses the same object from string pool\nString s3 = new String(\"Hello\");  // Creates a new object outside the pool\n\nSystem.out.println(s1 == s2);  // true (same object reference)\nSystem.out.println(s1 == s3);  // false (different objects)\nSystem.out.println(s1.equals(s3));  // true (same content)"
        },
        {
          "title": "String vs StringBuilder vs StringBuffer",
          "content": "",
          "comparison": [
            {
              "class": "String",
              "threadSafe": true,
              "mutable": false,
              "performance": "Slower for concatenation",
              "useCase": "Simple text with few modifications"
            },
            {
              "class": "StringBuilder",
              "threadSafe": false,
              "mutable": true,
              "performance": "Faster",
              "useCase": "Single-threaded string manipulation"
            },
            {
              "class": "StringBuffer",
              "threadSafe": true,
              "mutable": true,
              "performance": "Medium",
              "useCase": "Multi-threaded string manipulation"
            }
          ],
          "example": "// String concatenation (inefficient for loops)\nString result = \"\";\nfor (int i = 0; i < 10; i++) {\n    result += i;  // Creates a new String object each time\n}\n\n// StringBuilder (efficient)\nStringBuilder sb = new StringBuilder();\nfor (int i = 0; i < 10; i++) {\n    sb.append(i);  // Modifies the same object\n}\nString result = sb.toString();"
        }
      ]
    },
    {
      "title": "Packages and Access Control",
      "subsections": [
        {
          "title": "Package Declaration",
          "content": "Packages are used to organize classes and avoid naming conflicts:",
          "example": "package com.company.project.module;\n\npublic class MyClass {\n    // Class definition\n}"
        },
        {
          "title": "Import Statement",
          "content": "Import statements allow using classes from other packages:",
          "examples": [
            {
              "description": "Specific import",
              "code": "import java.util.ArrayList;"
            },
            {
              "description": "Import all classes from a package",
              "code": "import java.util.*;"
            },
            {
              "description": "Static import for static members",
              "code": "import static java.lang.Math.PI;"
            }
          ]
        },
        {
          "title": "Package Visibility",
          "content": "",
          "rules": [
            "Classes in the same package can access each other's package-private (default) members",
            "Different packages can only access public members",
            "Protected members are accessible within the same package and by subclasses"
          ]
        },
        {
          "title": "Default Package",
          "content": "Classes without a package declaration are in the default package. Using the default package is not recommended for production code because:",
          "reasons": [
            "Can't be imported by classes in named packages",
            "Increases risk of name collisions",
            "Makes it harder to organize code"
          ]
        }
      ]
    },
    {
      "title": "Best Practices",
      "content": "",
      "practices": [
        {
          "category": "Naming Conventions",
          "conventions": [
            "Classes/Interfaces: PascalCase (e.g., `StudentRecord`)",
            "Methods/Variables: camelCase (e.g., `calculateTotal`)",
            "Constants: UPPER_SNAKE_CASE (e.g., `MAX_VALUE`)",
            "Packages: lowercase with dots (e.g., `com.company.project`)"
          ]
        },
        {
          "category": "Code Organization",
          "practices": [
            "One top-level class per file",
            "Group related functionality in packages",
            "Keep classes focused on single responsibility"
          ]
        },
        {
          "category": "Encapsulation",
          "practices": [
            "Keep fields private",
            "Provide public getters and setters when needed",
            "Validate inputs in setters"
          ]
        },
        {
          "category": "Design Principles",
          "principles": [
            "Favor composition over inheritance",
            "Program to interfaces, not implementations",
            "Keep classes loosely coupled"
          ]
        },
        {
          "category": "Immutability",
          "practices": [
            "Make classes immutable when appropriate",
            "Use final fields and classes",
            "Return defensive copies of mutable fields"
          ]
        },
        {
          "category": "Error Handling",
          "practices": [
            "Use exceptions appropriately",
            "Never swallow exceptions without proper handling",
            "Clean up resources in finally blocks or try-with-resources"
          ]
        },
        {
          "category": "Memory Management",
          "practices": [
            "Avoid creating unnecessary objects",
            "Close resources properly",
            "Be aware of memory leaks (e.g., through static collections)"
          ]
        },
        {
          "category": "Coding Principles",
          "principles": [
            {
              "name": "DRY (Don't Repeat Yourself)",
              "description": "Avoid duplication by abstracting common code"
            },
            {
              "name": "KISS (Keep It Simple, Stupid)",
              "description": "Favor simplicity in design"
            },
            {
              "name": "YAGNI (You Ain't Gonna Need It)",
              "description": "Only implement features when needed"
            }
          ]
        }
      ]
    },
    {
      "title": "Interview Focus Areas",
      "content": "When preparing for Java interviews, pay special attention to:",
      "areas": [
        {
          "area": "OOP Principles",
          "description": "Understanding encapsulation, inheritance, polymorphism, and abstraction"
        },
        {
          "area": "Memory Management",
          "description": "Stack vs. heap, object lifecycle, garbage collection"
        },
        {
          "area": "Access Modifiers",
          "description": "Role of public, private, protected, and default access"
        },
        {
          "area": "Static vs. Non-static",
          "description": "Differences and appropriate usage"
        },
        {
          "area": "Class Types",
          "description": "Abstract classes vs. interfaces, inner classes"
        },
        {
          "area": "Keywords",
          "description": "final, static, this, super"
        },
        {
          "area": "Constructors",
          "description": "Types, chaining, and initialization blocks"
        },
        {
          "area": "Method Overriding & Overloading",
          "description": "Rules and differences"
        },
        {
          "area": "Common Patterns",
          "description": "Singleton, Factory, Builder"
        },
        {
          "area": "String Handling",
          "description": "Immutability, String pool, String vs StringBuilder vs StringBuffer"
        }
      ]
    },
    {
      "title": "Interview FAQs",
      "description": "This section covers frequently asked questions in Java interviews, focusing on core Java fundamentals. These questions and answers will help you prepare for technical interviews by providing concise explanations of key concepts.",
      "categories": [
        {
          "category": "Java Basics",
          "questions": [
            {
              "question": "What happens if a break statement is not used with case statements in a switch block?",
              "answer": "Without a break statement, execution \"falls through\" to subsequent case statements. Once a matching case is found, all statements in following cases will execute until a break is encountered or the switch block ends. This behavior can be intentionally utilized for cases that share the same code execution."
            },
            {
              "question": "What is the difference between JDK, JRE, and JVM?",
              "answer": "- JDK (Java Development Kit): Complete development package containing the JRE plus development tools like compiler (javac), debugger, and documentation tools.\n- JRE (Java Runtime Environment): Provides the runtime environment for executing Java applications, including the JVM and core libraries.\n- JVM (Java Virtual Machine): The engine that executes Java bytecode, providing platform independence through its \"write once, run anywhere\" capability."
            },
            {
              "question": "What is the difference between '==' and equals() method for comparing objects?",
              "answer": "The '==' operator compares object references (whether two references point to the same memory location), while the equals() method compares the content/values of objects. For Strings and other objects, use equals() to compare content, not '=='."
            },
            {
              "question": "Can a Java program run without JDK, JRE, or JVM installed?",
              "answer": "No, a Java program cannot run without at least the JRE installed, which includes the JVM. The JDK is only required for development, not for running compiled programs."
            }
          ]
        },
        {
          "category": "Data Types and Variables",
          "questions": [
            {
              "question": "What is the difference between primitive and reference data types?",
              "answer": "- Primitive data types (byte, short, int, long, float, double, char, boolean) store actual values in memory (typically on the stack) and are not objects.\n- Reference data types store references/addresses of objects located in the heap memory, not the actual values."
            },
            {
              "question": "What are the default values of various data types in Java?",
              "answer": "- Numeric types (byte, short, int, long): 0\n- Float/Double: 0.0\n- Char: '\\u0000' (null character)\n- Boolean: false\n- Reference types: null"
            },
            {
              "question": "What is the difference between local variables and instance variables regarding default initialization?",
              "answer": "Instance variables receive default values based on their data type. Local variables must be explicitly initialized before use; they don't receive default values, and attempting to use an uninitialized local variable results in a compilation error."
            },
            {
              "question": "What is the role of the final keyword when applied to variables?",
              "answer": "When applied to a variable, final makes it a constant that cannot be reassigned after initialization. For primitive types, the value cannot change. For reference types, the reference cannot change, but the internal state of the object can still be modified."
            }
          ]
        },
        {
          "category": "Object-Oriented Programming",
          "questions": [
            {
              "question": "How does encapsulation help in creating maintainable code?",
              "answer": "Encapsulation helps by:\n1. Hiding implementation details and exposing only necessary functionality\n2. Protecting data integrity through controlled access via getters and setters\n3. Allowing implementation changes without affecting client code\n4. Enabling validation logic when modifying object state"
            },
            {
              "question": "What is the difference between method overloading and method overriding?",
              "answer": "- Method Overloading: Multiple methods in the same class with the same name but different parameters (compile-time polymorphism)\n- Method Overriding: Subclass provides a specific implementation of a method already defined in the parent class (runtime polymorphism)"
            },
            {
              "question": "Can a class be both abstract and final?",
              "answer": "No. These modifiers contradict each other - abstract classes are meant to be extended, while final classes cannot be extended. Using both together would create a class that can neither be instantiated (due to being abstract) nor extended (due to being final), making it unusable."
            },
            {
              "question": "What's the difference between the extends and implements keywords?",
              "answer": "'extends' is used for class-to-class inheritance (a class inheriting from a superclass), while 'implements' is used for class-to-interface inheritance (a class implementing an interface)."
            },
            {
              "question": "Can an interface extend another interface? Can a class implement multiple interfaces?",
              "answer": "Yes to both. An interface can extend one or more other interfaces, and a class can implement multiple interfaces, allowing Java to achieve a form of multiple inheritance for behavior."
            }
          ]
        },
        {
          "category": "Memory Management",
          "questions": [
            {
              "question": "What is the difference between stack and heap memory in Java?",
              "answer": "- Stack: Stores local variables, method calls, and references. It's automatically managed with LIFO (Last-In-First-Out) approach and is thread-specific.\n- Heap: Stores objects and arrays. It's shared among all threads, managed by the garbage collector, and has a larger but slower memory space."
            },
            {
              "question": "How does garbage collection work in Java?",
              "answer": "Garbage collection in Java automatically reclaims memory from objects that are no longer reachable. The process involves:\n1. Marking: Identifying which objects are still in use\n2. Sweeping: Reclaiming memory from unused objects\n3. Compacting: Optionally reorganizing memory to reduce fragmentation\n\nThe JVM uses different GC algorithms depending on application needs and JVM configuration."
            },
            {
              "question": "Can you force garbage collection in Java?",
              "answer": "You can suggest garbage collection by calling `System.gc()` or `Runtime.getRuntime().gc()`, but there's no guarantee the JVM will actually perform it. The JVM ultimately decides when to run garbage collection based on its own algorithms and memory management policies."
            },
            {
              "question": "What is a memory leak in Java, and how can it occur?",
              "answer": "A memory leak in Java occurs when objects that are no longer needed are still referenced, preventing garbage collection. Common causes include:\n1. Unclosed resources (streams, connections)\n2. Improper implementation of static collections\n3. Objects added to long-lived collections but never removed\n4. Unintentional object references in caches without proper eviction policies\n5. Inner class instances holding implicit references to outer class instances"
            }
          ]
        },
        {
          "category": "Language Features",
          "questions": [
            {
              "question": "What is the difference between String, StringBuilder, and StringBuffer?",
              "answer": "- String: Immutable (cannot be changed after creation), thread-safe\n- StringBuilder: Mutable, not thread-safe, better performance in single-threaded scenarios\n- StringBuffer: Mutable, thread-safe (synchronized methods), slightly slower than StringBuilder"
            },
            {
              "question": "How does the string pool work in Java?",
              "answer": "The string pool is a special memory area in the heap where Java stores string literals. When creating a string using literals (`String s = \"hello\"`), Java checks if the string already exists in the pool. If it does, it returns a reference to the existing string; if not, it creates a new string and adds it to the pool. This mechanism optimizes memory usage by reusing string objects."
            },
            {
              "question": "What is the purpose of the this keyword in Java?",
              "answer": "The 'this' keyword refers to the current instance of the class and is used to:\n1. Distinguish between instance variables and parameters with the same name\n2. Pass the current object as an argument to another method\n3. Call another constructor of the same class (constructor chaining)"
            },
            {
              "question": "What is the super keyword used for?",
              "answer": "The 'super' keyword is used to:\n1. Access methods or fields of the parent class that are hidden by the child class\n2. Call the constructor of the parent class from the child class constructor"
            },
            {
              "question": "What happens if static is applied to a local variable?",
              "answer": "It results in a compilation error. The static keyword cannot be applied to local variables, only to class members (variables and methods) and blocks."
            }
          ]
        },
        {
          "category": "Constructors and Initialization",
          "questions": [
            {
              "question": "What happens if you don't define any constructor in a class?",
              "answer": "Java automatically provides a default no-argument constructor that initializes instance variables to their default values. This implicit constructor is lost once you define any other constructor."
            },
            {
              "question": "Can constructors be overloaded? Can they be overridden?",
              "answer": "Constructors can be overloaded (multiple constructors with different parameters in the same class), but they cannot be overridden in subclasses because they are not inherited."
            },
            {
              "question": "What is constructor chaining and how is it implemented?",
              "answer": "Constructor chaining is the process of calling one constructor from another within the same class. It's implemented using `this()` with appropriate parameters. This helps avoid code duplication when multiple constructors share common initialization logic."
            },
            {
              "question": "What is the difference between instance and static initialization blocks?",
              "answer": "- Instance initialization blocks run every time an object is created, before the constructor.\n- Static initialization blocks run only once when the class is loaded, regardless of how many objects are created."
            }
          ]
        },
        {
          "category": "Packages and Access Control",
          "questions": [
            {
              "question": "What happens if you don't explicitly define a package for a Java class?",
              "answer": "The class is placed in the default package. This is generally not recommended for production code because:\n1. Classes in the default package cannot be imported by classes in named packages\n2. It increases the risk of naming conflicts\n3. It makes the codebase harder to organize and maintain"
            },
            {
              "question": "What is the difference between public, protected, default, and private access modifiers?",
              "answer": "- public: Accessible from anywhere\n- protected: Accessible within the same package and by subclasses\n- default (no modifier): Accessible only within the same package\n- private: Accessible only within the same class"
            },
            {
              "question": "Can an interface contain variables? What are their implicit modifiers?",
              "answer": "Yes, interfaces can contain variables. By default, all variables in an interface are implicitly `public static final` (constants), even if these modifiers are not explicitly written."
            }
          ]
        },
        {
          "category": "Collections and Generics",
          "questions": [
            {
              "question": "What are the major differences between ArrayList and LinkedList?",
              "answer": "- ArrayList: Implemented as a resizable array, providing fast random access but slower insertions/deletions in the middle\n- LinkedList: Implemented as a doubly-linked list, offering fast insertions/deletions but slower random access"
            },
            {
              "question": "How does HashMap work internally?",
              "answer": "HashMap works by:\n1. Using a hash function to compute an index from the key's hashCode()\n2. Storing entries (key-value pairs) in an array of buckets/bins\n3. Handling collisions (when different keys hash to the same index) using either linked lists or balanced trees (as of Java 8)\n4. Maintaining a load factor to determine when to resize the underlying array"
            },
            {
              "question": "What happens if you use a mutable object as a key in a HashMap?",
              "answer": "Using a mutable object as a HashMap key is dangerous because:\n1. If the key's hashCode changes after insertion (due to mutation), the map won't be able to locate the entry\n2. This can lead to apparent data loss, duplicate keys, or inconsistent behavior\n3. It may also cause memory leaks as the entry might become unretrievable"
            },
            {
              "question": "What is the difference between fail-fast and fail-safe iterators?",
              "answer": "- Fail-fast iterators (like those in ArrayList, HashMap) throw ConcurrentModificationException if the collection is modified while iterating\n- Fail-safe iterators (like those in ConcurrentHashMap, CopyOnWriteArrayList) operate on a clone of the collection and don't throw exceptions during concurrent modification"
            }
          ]
        },
        {
          "category": "Exception Handling",
          "questions": [
            {
              "question": "What is the difference between checked and unchecked exceptions?",
              "answer": "- Checked exceptions: Extend Exception (not RuntimeException), must be declared in method signature or handled in try-catch blocks, represent recoverable conditions\n- Unchecked exceptions: Extend RuntimeException, don't need to be declared or caught, typically represent programming errors"
            },
            {
              "question": "What happens if an exception is thrown in a finally block?",
              "answer": "If an exception is thrown in a finally block, it overrides any exception thrown in the corresponding try or catch blocks. The original exception is lost unless explicitly handled within the finally block."
            },
            {
              "question": "Can you have a try block without a catch block?",
              "answer": "Yes, a try block can exist without a catch block if it has a finally block. This structure (try-finally without catch) is useful when you want to ensure cleanup code runs regardless of whether an exception occurs, but you don't want to handle the exception locally."
            },
            {
              "question": "What is the purpose of the try-with-resources statement?",
              "answer": "The try-with-resources statement automatically closes resources that implement AutoCloseable or Closeable interfaces, ensuring proper resource management even when exceptions occur. This eliminates the need for explicit finally blocks for resource cleanup."
            }
          ]
        },
        {
          "category": "Multithreading Basics",
          "questions": [
            {
              "question": "What is the difference between extending Thread and implementing Runnable?",
              "answer": "- Extending Thread: Creates a specialized thread class but limits inheritance since Java doesn't support multiple inheritance\n- Implementing Runnable: Separates the task from the thread mechanism, allowing the same task to be executed by multiple threads and permitting the implementing class to extend another class"
            },
            {
              "question": "What is the difference between start() and run() methods?",
              "answer": "- Calling `start()` creates a new thread and then invokes the `run()` method in that new thread\n- Directly calling `run()` executes the method in the current thread, without creating a new thread"
            },
            {
              "question": "What is thread safety and how can you achieve it?",
              "answer": "Thread safety means that a piece of code functions correctly during simultaneous execution by multiple threads. Techniques to achieve thread safety include:\n1. Synchronization (using synchronized methods/blocks)\n2. Using thread-safe collections (ConcurrentHashMap, etc.)\n3. Using immutable objects\n4. Using atomic classes (AtomicInteger, etc.)\n5. Using thread-local variables\n6. Using explicit locks (ReentrantLock, etc.)"
            }
          ]
        },
        {
          "category": "Common Coding Patterns",
          "questions": [
            {
              "question": "How would you implement a Singleton pattern in Java?",
              "answer": "A thread-safe Singleton with lazy initialization using double-checked locking:\n\n```java\npublic class Singleton {\n    private static volatile Singleton instance;\n    \n    private Singleton() {}\n    \n    public static Singleton getInstance() {\n        if (instance == null) {\n            synchronized (Singleton.class) {\n                if (instance == null) {\n                    instance = new Singleton();\n                }\n            }\n        }\n        return instance;\n    }\n}\n```"
            },
            {
              "question": "How can you create an immutable class in Java?",
              "answer": "To create an immutable class:\n1. Declare the class as final to prevent inheritance\n2. Make all fields private and final\n3. Don't provide setter methods\n4. If the class contains mutable objects, don't allow direct access to them (return defensive copies)\n5. If needed, implement a constructor that makes defensive copies of mutable input parameters"
            },
            {
              "question": "How would you compare two objects in Java?",
              "answer": "For proper object comparison:\n1. Override the `equals()` method to define what makes two objects equal\n2. Also override `hashCode()` to maintain the contract that equal objects must have equal hash codes\n3. Consider implementing `Comparable` interface if natural ordering is needed\n4. For advanced comparison, consider using `Comparator` implementations"
            },
            {
              "question": "What is the difference between shallow and deep copying?",
              "answer": "- Shallow copy: Creates a new object with copies of the top-level fields, but referenced objects are shared with the original\n- Deep copy: Creates a new object and recursively copies all objects referenced by the original, resulting in a completely independent copy"
            }
          ]
        },
        {
          "category": "Memory Management & JVM Architecture",
          "questions": [
            {
              "question": "What is the difference between a process and a thread in Java?",
              "answer": "In Java, a process is an independent program execution with its own memory space and resources, while a thread is a lightweight execution unit within a process. Threads within the same process share the memory space and resources.\n\nKey differences:\n- Processes have separate memory; threads share memory\n- Inter-process communication is more complex than inter-thread communication\n- Thread creation is faster than process creation\n- If one thread crashes, it may crash the entire process"
            },
            {
              "question": "How does the JVM manage memory across different generations?",
              "answer": "The JVM uses a generational garbage collection approach:\n- Young Generation (Eden + Survivor spaces): Where new objects are allocated. Most objects die young, making this area efficiently managed through minor GC cycles.\n- Old Generation: Long-lived objects that survive multiple GC cycles get promoted here. Cleaned through major GC events.\n- Metaspace (replaced PermGen in Java 8+): Stores class metadata, method data, and other JVM internals.\n\nThis generational design optimizes performance by focusing frequent garbage collection on areas with high object turnover while minimizing disruption to long-lived objects."
            }
          ]
        },
        {
          "category": "Threading Deep Dive",
          "questions": [
            {
              "question": "What is thread safety and how can you achieve it?",
              "answer": "Thread safety means that a piece of code functions correctly during simultaneous execution by multiple threads. Techniques to achieve thread safety include:\n1. Synchronization (using synchronized methods/blocks)\n2. Using thread-safe collections (ConcurrentHashMap, etc.)\n3. Using immutable objects\n4. Using atomic classes (AtomicInteger, etc.)\n5. Using thread-local variables\n6. Using explicit locks (ReentrantLock, etc.)"
            },
            {
              "question": "What is ThreadLocal and when would you use it?",
              "answer": "ThreadLocal provides thread-confined variables—each thread accessing a ThreadLocal variable has its own, independently initialized copy.\n\nKey uses:\n- Storing user identity/transactions in web applications\n- Thread-specific random number generators\n- Per-thread caching to avoid synchronization\n- Storing context that follows a logical thread of execution\n\nImportant: Always clean up ThreadLocal variables when done (especially in thread pools) by calling `remove()` to prevent memory leaks."
            },
            {
              "question": "What's the difference between volatile and synchronized?",
              "answer": "Both help with thread safety but in different ways:\n- volatile ensures visibility (changes are always read from/written to main memory) but doesn't provide atomicity for compound operations\n- synchronized provides both visibility and atomicity through exclusive locks\n\nUse volatile for simple flags or state values where you need visibility but not mutual exclusion. Use synchronized when multiple operations need to be atomic."
            }
          ]
        },
        {
          "category": "Collections Framework Advanced Topics",
          "questions": [
            {
              "question": "What is the difference between ArrayList and LinkedList?",
              "answer": "- ArrayList uses a dynamic array - O(1) random access, O(n) insertions/deletions in middle\n- LinkedList uses doubly-linked list - O(1) insertions/deletions at known positions, O(n) random access\n- ArrayList is more memory-efficient while LinkedList has overhead for node pointers\n- ArrayList is preferred for frequent access operations, LinkedList for frequent insertions/deletions"
            },
            {
              "question": "How do concurrent collections differ from synchronized collections?",
              "answer": "- Synchronized collections (like those created with Collections.synchronizedList()):\n  - Use full collection locking, allowing only one thread to access at a time\n  - Create contention bottlenecks under high loads\n  - Throw ConcurrentModificationException during iteration if modified\n- Concurrent collections (like ConcurrentHashMap, CopyOnWriteArrayList):\n  - Use fine-grained locking or lock-free algorithms\n  - Allow multiple threads to access different parts simultaneously\n  - Support concurrent access during iteration (fail-safe)\n  - Generally offer higher throughput under contention"
            },
            {
              "question": "What happens if you modify a collection while iterating over it?",
              "answer": "For most standard collections (ArrayList, HashMap, etc.), you'll get a ConcurrentModificationException because they use fail-fast iterators that detect structural changes.\n\nSolutions include:\n1. Using CopyOnWriteArrayList or similar concurrent collections\n2. Creating a copy of the collection before iteration\n3. Using the Iterator's remove() method instead of the collection's\n4. Using Stream API methods like filter() instead of manual removal"
            }
          ]
        },
        {
          "category": "Functional Programming & Java 8+",
          "questions": [
            {
              "question": "How does the Stream API's lazy evaluation work?",
              "answer": "Stream operations consist of:\n1. Intermediate operations (map, filter, etc.) which transform the stream but don't process elements\n2. Terminal operations (collect, reduce, etc.) which trigger actual processing\n\nBenefits of lazy evaluation:\n- Operations are fused and optimized as a single pass\n- Elements are processed one by one through the entire pipeline\n- Short-circuiting operations can stop processing early\n- Enhanced performance by avoiding unnecessary computations\n\nFor example, in `stream.filter().map().limit(5)`, if only 5 elements are needed, the stream won't process all elements."
            },
            {
              "question": "What is the difference between Function, Consumer, Supplier, and Predicate?",
              "answer": "These are key functional interfaces:\n- Function<T,R>: Takes a T and returns an R (`R apply(T t)`) - used for transformations\n- Consumer<T>: Takes a T and returns nothing (`void accept(T t)`) - used for side effects\n- Supplier<T>: Takes nothing and returns a T (`T get()`) - used for lazy generation\n- Predicate<T>: Takes a T and returns boolean (`boolean test(T t)`) - used for filtering"
            }
          ]
        },
        {
          "category": "Advanced Type System & Generics",
          "questions": [
            {
              "question": "How do wildcards work in generic types and when should you use them?",
              "answer": "Wildcards in generics come in three forms:\n1. Unbounded wildcard (`List<?>): Use when the actual type doesn't matter, only general object methods will be called\n2. Upper bounded wildcard (`List<? extends Number>`): Use when you need to read elements from a structure but not modify it\n3. Lower bounded wildcard (`List<? super Integer>`): Use when you need to add elements to a structure\n\nRemember the PECS principle (Producer-Extends, Consumer-Super):\n- Use \"extends\" when you want to get values out (producer)\n- Use \"super\" when you want to put values in (consumer)"
            },
            {
              "question": "What is type erasure and how does it affect generics?",
              "answer": "Type erasure means that generic type information is removed during compilation. At runtime:\n- `List<String>` and `List<Integer>` both become just `List`\n- Type parameters are replaced by their bounds or Object if unbounded\n- Necessary casts are inserted by the compiler\n\nImplications:\n- Cannot check if an object is `List<String>` at runtime\n- Cannot create arrays of generic types\n- Cannot use primitive types as type parameters\n- Cannot overload methods that have the same erasure"
            }
          ]
        },
        {
          "category": "Reflection & Advanced Java",
          "questions": [
            {
              "question": "What is reflection and when would you use it?",
              "answer": "Reflection allows inspection and manipulation of classes, interfaces, methods, and fields at runtime.\n\nCommon uses:\n- Framework development (Spring, Hibernate, Jackson)\n- Testing tools and mocking frameworks\n- Runtime annotation processing\n- Dynamic proxy creation\n- Accessing private fields/methods in tests\n\nWhile powerful, reflection comes with drawbacks:\n- Performance overhead\n- Loss of compile-time type checking\n- Security restrictions when running with SecurityManager\n- Potential to break encapsulation"
            },
            {
              "question": "How do dynamic proxies work in Java?",
              "answer": "Dynamic proxies create runtime implementations of interfaces using the `Proxy.newProxyInstance()` method.\n\nThey're used for:\n- Aspect-oriented programming\n- ORM frameworks\n- Service invocation layers\n- Remote procedure calls\n- Decorating interfaces with cross-cutting concerns\n\nThe key components are:\n1. The interface(s) to implement\n2. An InvocationHandler that intercepts method calls"
            }
          ]
        }
      ]
    }
  ]
}
