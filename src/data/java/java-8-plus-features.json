{
  "title": "Java 8+ Features",
  "tags": ["java", "functional-programming", "streams", "lambda", "backend"],
  "sections": [
    {
      "id": "lambdaExpressions",
      "title": "Lambda Expressions",
      "content": "Lambda expressions are anonymous functions that enable functional programming in Java. They implement functional interfaces concisely and eliminate boilerplate code.",
      "syntax": "parameters -> expression",
      "subsections": [
        {
          "title": "Syntax",
          "code": [
            {
              "language": "java",
              "snippet": "// Basic syntax: (parameters) -> expression\n(int x, int y) -> x + y\n\n// With single parameter (parentheses optional)\nx -> x * x\n\n// With code block\n(String s) -> {\n    String result = s.toUpperCase();\n    return result;\n}"
            }
          ]
        },
        {
          "title": "Key Characteristics",
          "list": [
            "Concise alternative to anonymous classes",
            "No need for explicit type declaration (type inference)",
            "Can access effectively final variables from enclosing scope",
            "Cannot access default methods of the functional interface"
          ]
        },
        {
          "title": "Interview Examples",
          "code": [
            {
              "language": "java",
              "snippet": "// Runnable implementation (Before Java 8)\nnew Thread(new Runnable() {\n    @Override\n    public void run() {\n        System.out.println(\"Thread running\");\n    }\n}).start();\n\n// With Lambda (Java 8+)\nnew Thread(() -> System.out.println(\"Thread running\")).start();\n\n// Comparator for sorting\nCollections.sort(names, (a, b) -> a.compareToIgnoreCase(b));"
            }
          ]
        },
        {
          "title": "Examples",
          "examples": [
            {
              "scenario": "Simple Expression",
              "code": "(int x, int y) -> x + y",
              "description": "Adds two numbers together."
            },
            {
              "scenario": "Single Parameter",
              "code": "n -> n * n",
              "description": "Squares a number."
            },
            {
              "scenario": "Block of Code",
              "code": "(String s) -> { System.out.println(s); }",
              "description": "Prints a string using a code block."
            }
          ]
        }
      ]
    },
    {
      "id": "functionalInterfaces",
      "title": "Functional Interfaces",
      "content": "Functional interfaces provide the foundation for lambda expressions by defining a single abstract method (SAM) that the lambda implements.",
      "subsections": [
        {
          "title": "Core Characteristics",
          "list": [
            "Contains exactly one abstract method",
            "May contain default and static methods",
            "Annotated with `@FunctionalInterface` (optional but recommended)"
          ]
        },
        {
          "title": "Key Built-in Functional Interfaces",
          "tables": [
            {
              "headers": ["Interface", "Method", "Description", "Example Use Case"],
              "rows": [
                ["`Function<T,R>`", "`R apply(T t)`", "Transforms input into output", "String to Integer transformation"],
                ["`Predicate<T>`", "`boolean test(T t)`", "Boolean test on input", "Filtering collections"],
                ["`Consumer<T>`", "`void accept(T t)`", "Consumes input with no return", "Printing elements"],
                ["`Supplier<T>`", "`T get()`", "Supplies values with no input", "Lazy value generation"],
                ["`BiFunction<T,U,R>`", "`R apply(T t, U u)`", "Function with two inputs", "Combining two values"],
                ["`UnaryOperator<T>`", "`T apply(T t)`", "Special function where input and output types match", "Transforming a value of the same type"],
                ["`BinaryOperator<T>`", "`T apply(T t1, T t2)`", "Combines two arguments of same type", "Mathematical operations"]
              ]
            }
          ]
        },
        {
          "title": "Example Usage",
          "code": [
            {
              "language": "java",
              "snippet": "// Predicate for filtering\nPredicate<String> isLongString = s -> s.length() > 10;\nList<String> longStrings = stringList.stream()\n    .filter(isLongString)\n    .collect(Collectors.toList());\n\n// Function for transformation\nFunction<String, Integer> stringToLength = String::length;\nList<Integer> lengths = stringList.stream()\n    .map(stringToLength)\n    .collect(Collectors.toList());\n\n// Consumer for iteration\nConsumer<String> printer = System.out::println;\nstringList.forEach(printer);\n\n// Supplier for generation\nSupplier<Double> randomValue = Math::random;"
            }
          ]
        },
        {
          "title": "Creating Custom Functional Interfaces",
          "code": [
            {
              "language": "java",
              "snippet": "@FunctionalInterface\npublic interface TriFunction<A, B, C, R> {\n    R apply(A a, B b, C c);\n}\n\n// Usage\nTriFunction<Integer, Integer, Integer, Integer> sum = (a, b, c) -> a + b + c;"
            }
          ]
        },
        {
          "title": "Functional Interfaces and Inheritance",
          "code": [
            {
              "language": "java",
              "snippet": "// A functional interface extending another functional interface\n@FunctionalInterface\npublic interface ExtendedPredicate<T> extends Predicate<T> {\n    // No additional abstract methods - still a functional interface\n    \n    // Can add default methods\n    default ExtendedPredicate<T> and(Predicate<? super T> other) {\n        return t -> this.test(t) && other.test(t);\n    }\n}\n\n// Not a functional interface anymore (two abstract methods)\npublic interface NonFunctionalInterface<T> extends Predicate<T> {\n    void additionalMethod();\n}"
            }
          ]
        },
        {
          "title": "Standard Functional Interfaces",
          "examples": [
            {
              "name": "Predicate<T>",
              "description": "Represents a function that takes a value and returns a boolean result.",
              "method": "boolean test(T t)"
            },
            {
              "name": "Consumer<T>",
              "description": "Represents an operation that accepts a single input and performs an action without returning a result.",
              "method": "void accept(T t)"
            },
            {
              "name": "Function<T,R>",
              "description": "Represents a function that takes an argument and produces a result.",
              "method": "R apply(T t)"
            }
          ],
          "note": "Use the @FunctionalInterface annotation to clearly indicate functional interfaces."
        }
      ]
    },
    {
      "id": "methodReferences",
      "title": "Method References",
      "content": "Method references provide a more compact and readable alternative to certain lambda expressions, referencing existing methods by name.",
      "subsections": [
        {
          "title": "Types of Method References",
          "tables": [
            {
              "headers": ["Type", "Syntax", "Lambda Equivalent", "Example"],
              "rows": [
                ["Static Method", "`ClassName::staticMethod`", "`(args) -> ClassName.staticMethod(args)`", "`Math::max`"],
                ["Instance Method of Particular Object", "`instance::instanceMethod`", "`(args) -> instance.instanceMethod(args)`", "`System.out::println`"],
                ["Instance Method of Arbitrary Object", "`ClassName::instanceMethod`", "`(obj, args) -> obj.instanceMethod(args)`", "`String::length`"],
                ["Constructor", "`ClassName::new`", "`(args) -> new ClassName(args)`", "`ArrayList::new`"]
              ]
            }
          ]
        },
        {
          "title": "Examples",
          "code": [
            {
              "language": "java",
              "snippet": "// Static method reference\nFunction<Integer, String> converter = String::valueOf; // Instead of: n -> String.valueOf(n)\n\n// Instance method reference (particular object)\nConsumer<String> printer = System.out::println; // Instead of: s -> System.out.println(s)\n\n// Instance method reference (arbitrary object)\nComparator<String> comparator = String::compareToIgnoreCase; // Instead of: (s1, s2) -> s1.compareToIgnoreCase(s2)\n\n// Constructor reference\nSupplier<List<String>> listSupplier = ArrayList::new; // Instead of: () -> new ArrayList<>()"
            }
          ]
        },
        {
          "title": "Practical Examples",
          "examples": [
            {
              "scenario": "With Streams",
              "code": "list.stream().forEach(System.out::println)",
              "description": "Prints each element in the stream using a method reference."
            },
            {
              "scenario": "With Comparator",
              "code": "list.sort(String::compareToIgnoreCase)",
              "description": "Sorts a list of strings in a case-insensitive manner using a method reference."
            }
          ]
        }
      ]
    },
    {
      "id": "streams",
      "title": "Stream API",
      "content": "The Stream API provides a powerful and flexible way to process collections of objects in a functional style, supporting both sequential and parallel processing. It introduces a functional and declarative approach that makes it easy to perform complex data manipulations with concise and readable code.",
      "subsections": [
        {
          "title": "Key Characteristics",
          "list": [
            "Not a data structure but a view of data",
            "Supports functional-style operations (filter, map, reduce)",
            "Lazy evaluation: intermediate operations only execute when terminal operation is invoked",
            "\"Use-once\": cannot be reused after terminal operation"
          ]
        },
        {
          "title": "Stream Creation",
          "methods": [
            {
              "name": "stream()",
              "description": "Creates a sequential stream from a collection, enabling aggregate operations on its elements.",
              "example": "collection.stream()"
            },
            {
              "name": "of()",
              "description": "Creates a stream from specified values, which is useful for quickly constructing a stream from known elements.",
              "example": "Stream.of(1, 2, 3, 4, 5)"
            },
            {
              "name": "generate()",
              "description": "Creates an infinite stream using a Supplier, often used for generating random values or repeated patterns.",
              "example": "Stream.generate(Math::random)"
            },
            {
              "name": "iterate()",
              "description": "Creates an infinite stream by iteratively applying a function starting from an initial seed, useful for sequences.",
              "example": "Stream.iterate(0, n -> n + 2)"
            },
            {
              "name": "Arrays.stream()",
              "description": "Converts an array into a stream, enabling stream operations on the array's elements.",
              "example": "Arrays.stream(new int[]{1, 2, 3})"
            }
          ],
          "code": [
            {
              "language": "java",
              "snippet": "// From Collection\nList<String> list = Arrays.asList(\"a\", \"b\", \"c\");\nStream<String> stream = list.stream();\n\n// Direct creation\nStream<Integer> stream = Stream.of(1, 2, 3, 4, 5);\n\n// From array\nString[] array = {\"a\", \"b\", \"c\"};\nStream<String> stream = Arrays.stream(array);\n\n// Infinite streams\nStream<Double> randoms = Stream.generate(Math::random);\nStream<Integer> evenNumbers = Stream.iterate(0, n -> n + 2);"
            }
          ]
        },
        {
          "title": "Intermediate Operations",
          "methods": [
            {
              "name": "filter()",
              "description": "Retains only the elements that satisfy a given predicate.",
              "example": "list.stream().filter(n -> n > 10)"
            },
            {
              "name": "map()",
              "description": "Transforms each element in the stream using the provided function.",
              "example": "list.stream().map(String::toUpperCase)"
            },
            {
              "name": "flatMap()",
              "description": "Converts each element into a stream and then flattens the resulting streams into one contiguous stream.",
              "example": "list.stream().flatMap(List::stream)"
            },
            {
              "name": "sorted()",
              "description": "Sorts the elements of the stream in natural order or according to a custom comparator.",
              "example": "stream.sorted()"
            },
            {
              "name": "distinct()",
              "description": "Eliminates duplicate elements from the stream.",
              "example": "stream.distinct()"
            },
            {
              "name": "limit()",
              "description": "Restricts the stream to contain no more than the specified number of elements.",
              "example": "stream.limit(5)"
            },
            {
              "name": "skip()",
              "description": "Skips the first n elements of the stream, returning a stream that begins after these elements.",
              "example": "stream.skip(3)"
            },
            {
              "name": "peek()",
              "description": "Performs the provided action on each element as it is consumed, often used for debugging.",
              "example": "stream.peek(System.out::println)"
            }
          ],
          "tables": [
            {
              "headers": ["Operation", "Description", "Example"],
              "rows": [
                ["`filter()`", "Filters elements based on a predicate", "`stream.filter(n -> n > 10)`"],
                ["`map()`", "Transforms elements using a function", "`stream.map(String::toUpperCase)`"],
                ["`flatMap()`", "Transforms and flattens nested streams", "`stream.flatMap(Collection::stream)`"],
                ["`distinct()`", "Removes duplicates", "`stream.distinct()`"],
                ["`sorted()`", "Sorts elements", "`stream.sorted(Comparator.naturalOrder())`"],
                ["`peek()`", "Performs action on elements (debugging)", "`stream.peek(System.out::println)`"],
                ["`limit()`", "Limits stream to a size", "`stream.limit(10)`"],
                ["`skip()`", "Skips first n elements", "`stream.skip(5)`"]
              ]
            }
          ]
        },
        {
          "title": "Terminal Operations",
          "methods": [
            {
              "name": "collect()",
              "description": "Accumulates the stream elements into a collection or a summarized result using a Collector.",
              "example": "stream.collect(Collectors.toList())"
            },
            {
              "name": "reduce()",
              "description": "Reduces the stream elements to a single value using an accumulator function.",
              "example": "stream.reduce(0, Integer::sum)"
            },
            {
              "name": "forEach()",
              "description": "Performs an action on each element of the stream.",
              "example": "stream.forEach(System.out::println)"
            },
            {
              "name": "forEachOrdered()",
              "description": "Performs an action on each element in the stream while preserving the encounter order.",
              "example": "stream.forEachOrdered(System.out::println)"
            },
            {
              "name": "toArray()",
              "description": "Converts the stream into an array containing all its elements.",
              "example": "Object[] array = stream.toArray()"
            },
            {
              "name": "count()",
              "description": "Returns the total number of elements in the stream.",
              "example": "long count = stream.count()"
            },
            {
              "name": "anyMatch()",
              "description": "Returns true if any element in the stream satisfies the given predicate.",
              "example": "stream.anyMatch(n -> n > 10)"
            },
            {
              "name": "allMatch()",
              "description": "Returns true if every element in the stream satisfies the given predicate.",
              "example": "stream.allMatch(n -> n > 0)"
            },
            {
              "name": "noneMatch()",
              "description": "Returns true if no elements in the stream satisfy the given predicate.",
              "example": "stream.noneMatch(n -> n < 0)"
            },
            {
              "name": "findFirst()",
              "description": "Retrieves the first element of the stream, if present, wrapped in an Optional.",
              "example": "Optional<T> first = stream.findFirst()"
            },
            {
              "name": "findAny()",
              "description": "Retrieves any element of the stream, particularly useful in parallel streams, wrapped in an Optional.",
              "example": "Optional<T> any = stream.findAny()"
            },
            {
              "name": "max()",
              "description": "Finds the maximum element in the stream according to a provided comparator.",
              "example": "stream.max(Comparator.naturalOrder())"
            },
            {
              "name": "min()",
              "description": "Finds the minimum element in the stream according to a provided comparator.",
              "example": "stream.min(Comparator.naturalOrder())"
            },
            {
              "name": "summaryStatistics()",
              "description": "Generates summary statistics (count, sum, min, average, max) for numerical streams.",
              "example": "IntSummaryStatistics stats = intStream.summaryStatistics()"
            }
          ],
          "tables": [
            {
              "headers": ["Operation", "Description", "Example"],
              "rows": [
                ["`forEach()`", "Performs action on each element", "`stream.forEach(System.out::println)`"],
                ["`collect()`", "Collects elements into a container", "`stream.collect(Collectors.toList())`"],
                ["`reduce()`", "Reduces elements to a single value", "`stream.reduce(0, Integer::sum)`"],
                ["`count()`", "Counts elements", "`stream.count()`"],
                ["`anyMatch()`", "Returns true if any element matches", "`stream.anyMatch(s -> s.length() > 5)`"],
                ["`allMatch()`", "Returns true if all elements match", "`stream.allMatch(n -> n > 0)`"],
                ["`noneMatch()`", "Returns true if no elements match", "`stream.noneMatch(n -> n < 0)`"],
                ["`findFirst()`", "Returns first element (Optional)", "`stream.findFirst()`"],
                ["`findAny()`", "Returns any element (Optional)", "`stream.findAny()`"],
                ["`min()`", "Returns minimum element", "`stream.min(Comparator.naturalOrder())`"],
                ["`max()`", "Returns maximum element", "`stream.max(Comparator.naturalOrder())`"],
                ["`toArray()`", "Converts to array", "`stream.toArray()`"]
              ]
            }
          ]
        },
        {
          "title": "Specialized Streams",
          "content": "**IntStream**, **LongStream**, **DoubleStream**: Primitive specializations\n- More efficient than object streams for numeric operations\n- Provide specialized operations like `sum()`, `average()`, `range()`",
          "methods": [
            {
              "name": "IntStream",
              "description": "A specialized stream for primitive int values, designed to avoid the overhead of boxing.",
              "example": "IntStream.range(1, 10).sum()"
            },
            {
              "name": "LongStream",
              "description": "A specialized stream for primitive long values, offering efficient numerical operations.",
              "example": "LongStream.of(1L, 2L, 3L)"
            },
            {
              "name": "DoubleStream",
              "description": "A specialized stream for primitive double values, optimized for floating-point arithmetic.",
              "example": "DoubleStream.generate(Math::random).limit(5)"
            },
            {
              "name": "Stream Support Methods",
              "description": "Methods to convert between object streams and primitive streams, facilitating operations like mapping.",
              "example": "stream.mapToInt(String::length)"
            }
          ],
          "code": [
            {
              "language": "java",
              "snippet": "// IntStream example\nIntStream.range(1, 11)      // Creates 1 to 10\n    .filter(n -> n % 2 == 0) // Keep even numbers\n    .sum();                 // Sum them"
            }
          ]
        },
        {
          "title": "Collectors",
          "content": "Collectors are versatile terminal operations that gather stream elements into collections or perform reductions.",
          "methods": [
            {
              "name": "toList()",
              "description": "Collects stream elements into a List.",
              "example": "stream.collect(Collectors.toList())"
            },
            {
              "name": "toSet()",
              "description": "Collects stream elements into a Set, automatically removing duplicates.",
              "example": "stream.collect(Collectors.toSet())"
            },
            {
              "name": "toCollection()",
              "description": "Collects elements into a specific type of collection provided by a Supplier.",
              "example": "stream.collect(Collectors.toCollection(LinkedList::new))"
            },
            {
              "name": "toMap()",
              "description": "Transforms the stream into a Map by applying key and value mapping functions.",
              "example": "stream.collect(Collectors.toMap(keyMapper, valueMapper))"
            },
            {
              "name": "toConcurrentMap()",
              "description": "Transforms the stream into a thread-safe ConcurrentMap using key and value mapping functions.",
              "example": "stream.collect(Collectors.toConcurrentMap(keyMapper, valueMapper))"
            },
            {
              "name": "joining()",
              "description": "Concatenates the stream elements into a single String with an optional delimiter.",
              "example": "stream.collect(Collectors.joining(\", \"))"
            },
            {
              "name": "counting()",
              "description": "Counts the number of elements in the stream.",
              "example": "stream.collect(Collectors.counting())"
            },
            {
              "name": "summingInt()",
              "description": "Calculates the sum of integer values in the stream.",
              "example": "stream.collect(Collectors.summingInt(Integer::intValue))"
            },
            {
              "name": "summingLong()",
              "description": "Calculates the sum of long values in the stream.",
              "example": "stream.collect(Collectors.summingLong(Long::longValue))"
            },
            {
              "name": "summingDouble()",
              "description": "Calculates the sum of double values in the stream.",
              "example": "stream.collect(Collectors.summingDouble(Double::doubleValue))"
            },
            {
              "name": "averagingInt()",
              "description": "Calculates the average of integer values in the stream.",
              "example": "stream.collect(Collectors.averagingInt(Integer::intValue))"
            },
            {
              "name": "averagingLong()",
              "description": "Calculates the average of long values in the stream.",
              "example": "stream.collect(Collectors.averagingLong(Long::longValue))"
            },
            {
              "name": "averagingDouble()",
              "description": "Calculates the average of double values in the stream.",
              "example": "stream.collect(Collectors.averagingDouble(Double::doubleValue))"
            },
            {
              "name": "summarizingInt()",
              "description": "Produces summary statistics for integer values in the stream.",
              "example": "stream.collect(Collectors.summarizingInt(Integer::intValue))"
            },
            {
              "name": "summarizingLong()",
              "description": "Produces summary statistics for long values in the stream.",
              "example": "stream.collect(Collectors.summarizingLong(Long::longValue))"
            },
            {
              "name": "summarizingDouble()",
              "description": "Produces summary statistics for double values in the stream.",
              "example": "stream.collect(Collectors.summarizingDouble(Double::doubleValue))"
            },
            {
              "name": "maxBy()",
              "description": "Finds the maximum element in the stream using a provided comparator.",
              "example": "stream.collect(Collectors.maxBy(Comparator.naturalOrder()))"
            },
            {
              "name": "minBy()",
              "description": "Finds the minimum element in the stream using a provided comparator.",
              "example": "stream.collect(Collectors.minBy(Comparator.naturalOrder()))"
            },
            {
              "name": "reducing()",
              "description": "Reduces the stream elements to a single value using an associative binary operator.",
              "example": "stream.collect(Collectors.reducing(0, Integer::intValue, Integer::sum))"
            },
            {
              "name": "collectingAndThen()",
              "description": "Performs a finishing transformation on the result produced by a Collector.",
              "example": "stream.collect(Collectors.collectingAndThen(Collectors.toList(), Collections::unmodifiableList))"
            },
            {
              "name": "groupingBy()",
              "description": "Groups stream elements according to a classifier function into a Map.",
              "example": "stream.collect(Collectors.groupingBy(String::length))"
            },
            {
              "name": "groupingByConcurrent()",
              "description": "A concurrent version of groupingBy that returns a thread-safe ConcurrentMap.",
              "example": "stream.collect(Collectors.groupingByConcurrent(String::length))"
            },
            {
              "name": "partitioningBy()",
              "description": "Partitions stream elements into two groups based on a predicate, returning a Map with Boolean keys.",
              "example": "stream.collect(Collectors.partitioningBy(n -> n > 10))"
            },
            {
              "name": "mapping()",
              "description": "Applies a mapping function to the elements before collecting them into a collection.",
              "example": "stream.collect(Collectors.mapping(String::toUpperCase, Collectors.toList()))"
            }
          ],
          "code": [
            {
              "language": "java",
              "snippet": "// Basic collection operations\nList<String> list = stream.collect(Collectors.toList());\nSet<String> set = stream.collect(Collectors.toSet());\nString joined = stream.collect(Collectors.joining(\", \"));\n\n// Grouping and partitioning\nMap<Department, List<Employee>> byDept = employees.stream()\n    .collect(Collectors.groupingBy(Employee::getDepartment));\n\nMap<Boolean, List<Employee>> seniorJunior = employees.stream()\n    .collect(Collectors.partitioningBy(e -> e.getYears() > 5));\n\n// Aggregation\nDouble avgSalary = employees.stream()\n    .collect(Collectors.averagingDouble(Employee::getSalary));\n\n// Custom collection\nTreeSet<String> treeSet = stream.collect(\n    Collectors.toCollection(TreeSet::new));"
            }
          ]
        },
        {
          "title": "Parallel Streams",
          "methods": [
            {
              "name": "parallel()",
              "description": "Converts a sequential stream into a parallel stream to leverage multi-core processing for improved performance.",
              "example": "stream.parallel().forEach(System.out::println)"
            },
            {
              "name": "sequential()",
              "description": "Converts a parallel stream back into a sequential stream to preserve the order of elements.",
              "example": "stream.parallel().sequential()"
            },
            {
              "name": "parallelStream()",
              "description": "Creates a parallel stream directly from a collection, enabling concurrent processing.",
              "example": "collection.parallelStream()"
            }
          ],
          "code": [
            {
              "language": "java",
              "snippet": "// Creating parallel stream\nlist.parallelStream();\n// or\nstream.parallel();\n\n// Example of parallel processing\nlong count = bigList.parallelStream()\n    .filter(this::complexFilter)\n    .count();"
            }
          ],
          "subsections": [
            {
              "title": "Parallel Stream Considerations",
              "content": "- Best for computationally intensive operations\n- Performance depends on data size, operations, and hardware\n- Watch for thread safety when using shared state\n- Default thread count equals to available processors",
              "code": [
                {
                  "language": "java",
                  "snippet": "// Performance considerations for parallel streams\n// When to use (and when not to use) parallel streams\nlist.parallelStream()\n    .filter(item -> complexOperation(item)) // CPU-intensive task\n    .collect(Collectors.toList());\n\n// Common pitfall - operations with shared state\n// This can lead to race conditions\nAtomicInteger counter = new AtomicInteger(0);\nlist.parallelStream()\n    .forEach(item -> counter.incrementAndGet()); // Avoid this pattern\n\n// Better approach for counting\nlong count = list.parallelStream().count();\n\n// Better approach for mutable reduction\n// Use collectors that combine results correctly\nMap<String, Long> wordCounts = text.parallelStream()\n    .flatMap(line -> Arrays.stream(line.split(\"\\\\s+\")))\n    .collect(Collectors.groupingByConcurrent(\n        String::toLowerCase, Collectors.counting()));"
                }
              ]
            }
          ]
        },
        {
          "title": "Stream Examples",
          "methods": [
            {
              "name": "Processing a List of Names",
              "description": "Filters a list of names to include only those starting with 'A', converts them to uppercase, and collects the results into a new list.",
              "example": "names.stream().filter(n -> n.startsWith(\"A\")).map(String::toUpperCase).collect(Collectors.toList())"
            },
            {
              "name": "Calculating Total Order Amount",
              "description": "Sums the total amounts from a list of orders, providing a single aggregated value.",
              "example": "orders.stream().mapToDouble(Order::getAmount).sum()"
            },
            {
              "name": "Grouping Employees by Department",
              "description": "Organizes employees into groups based on their department using the groupingBy collector.",
              "example": "employees.stream().collect(Collectors.groupingBy(Employee::getDepartment))"
            },
            {
              "name": "Parallel Stream Processing",
              "description": "Processes a large data set in parallel to improve performance by leveraging multiple cores.",
              "example": "largeDataSet.parallelStream().filter(...).collect(...)"
            }
          ]
        }
      ]
    },
    {
      "id": "optional",
      "title": "Optional",
      "content": "Optional is a container object that may or may not contain a non-null value, helping to avoid explicit null checks and NullPointerExceptions.",
      "subsections": [
        {
          "title": "Key Methods",
          "methods": [
            {
              "name": "of()",
              "description": "Creates an Optional containing a non-null value.",
              "example": "Optional.of(value)"
            },
            {
              "name": "empty()",
              "description": "Creates an empty Optional instance.",
              "example": "Optional.empty()"
            },
            {
              "name": "ofNullable()",
              "description": "Creates an Optional that holds the given value, or is empty if the value is null.",
              "example": "Optional.ofNullable(value)"
            },
            {
              "name": "get()",
              "description": "Retrieves the value if present; throws NoSuchElementException if the Optional is empty.",
              "example": "optional.get()"
            },
            {
              "name": "isPresent()",
              "description": "Checks whether the Optional contains a value.",
              "example": "optional.isPresent()"
            },
            {
              "name": "ifPresent()",
              "description": "Executes the given action if a value is present in the Optional.",
              "example": "optional.ifPresent(value -> System.out.println(value))"
            }
          ],
          "tables": [
            {
              "headers": ["Method", "Description", "Example"],
              "rows": [
                ["`of(T value)`", "Creates Optional with non-null value", "`Optional.of(\"value\")`"],
                ["`ofNullable(T value)`", "Creates Optional that may be empty", "`Optional.ofNullable(getValue())`"],
                ["`empty()`", "Creates empty Optional", "`Optional.empty()`"],
                ["`isPresent()`", "Checks if value is present", "`optional.isPresent()`"],
                ["`ifPresent(Consumer)`", "Executes action if present", "`optional.ifPresent(System.out::println)`"],
                ["`get()`", "Returns value if present or throws", "`optional.get()`"],
                ["`orElse(T)`", "Returns value or provided default", "`optional.orElse(\"default\")`"],
                ["`orElseGet(Supplier)`", "Returns value or computed default", "`optional.orElseGet(() -> computeDefault())`"],
                ["`orElseThrow(Supplier)`", "Returns value or throws exception", "`optional.orElseThrow(NoSuchElementException::new)`"],
                ["`map(Function)`", "Transforms value if present", "`optional.map(String::toUpperCase)`"],
                ["`flatMap(Function)`", "Transforms and flattens", "`optional.flatMap(this::findRelated)`"],
                ["`filter(Predicate)`", "Applies filter to value", "`optional.filter(s -> s.length() > 3)`"]
              ]
            }
          ]
        },
        {
          "title": "Best Practices",
          "code": [
            {
              "language": "java",
              "snippet": "// Good: Using Optional APIs\nreturn userRepository.findById(id)\n    .map(User::getAddress)\n    .map(Address::getZipCode)\n    .orElse(\"Unknown\");\n\n// Bad: Using Optional as method parameter\npublic void process(Optional<User> userOpt) { /* ... */ }\n\n// Good: Returning Optional from methods that may not return a value\npublic Optional<User> findUser(String id) {\n    // ...\n    return Optional.ofNullable(user);\n}"
            }
          ]
        },
        {
          "title": "Java 9+ Enhancements",
          "code": [
            {
              "language": "java",
              "snippet": "// Java 9\noptional.ifPresentOrElse(\n    value -> System.out.println(\"Found: \" + value),\n    () -> System.out.println(\"Not found\")\n);\n\n// Java 9\nOptional<String> result = optional.or(() -> Optional.of(\"default\"));\n\n// Java 10\nStream<String> stream = optional.stream(); // Returns empty or singleton stream"
            }
          ]
        }
      ]
    },
    {
      "id": "defaultMethods",
      "title": "Default Methods",
      "content": "Default methods enable interfaces to have method implementations, allowing the evolution of interfaces without breaking existing implementations.",
      "subsections": [
        {
          "title": "Characteristics",
          "content": "- Defined with the `default` keyword in interfaces\n- All implementing classes inherit the default implementation\n- Can be overridden by implementing classes\n- Enable backward compatibility when adding methods to interfaces",
          "code": [
            {
              "language": "java",
              "snippet": "public interface Collection<E> {\n    // Existing abstract methods\n    \n    // Default method added in Java 8\n    default Stream<E> stream() {\n        // Implementation\n    }\n}"
            }
          ]
        },
        {
          "title": "Multiple Inheritance Resolution Rules",
          "content": "When a class implements multiple interfaces with the same default method:\n\n1. Class methods take priority over interface default methods\n2. More specific interface methods take priority over less specific ones\n3. If ambiguous, the class must explicitly override the method",
          "code": [
            {
              "language": "java",
              "snippet": "interface A {\n    default void hello() {\n        System.out.println(\"Hello from A\");\n    }\n}\n\ninterface B extends A {\n    @Override\n    default void hello() {\n        System.out.println(\"Hello from B\");\n    }\n}\n\nclass C implements A, B {\n    // B's hello() takes precedence since B is more specific than A\n}\n\nclass D implements A, B {\n    // Explicitly override to resolve ambiguity\n    @Override\n    public void hello() {\n        B.super.hello(); // Call B's implementation\n    }\n}"
            }
          ]
        },
        {
          "title": "Examples",
          "examples": [
            {
              "title": "Simple Default Method",
              "code": "interface Vehicle { default void start() { System.out.println(\"Starting vehicle\"); } }",
              "description": "Provides a standard default implementation for an interface method."
            },
            {
              "title": "Multiple Default Methods",
              "code": "interface Collection { default Stream<E> stream() { ... } default Stream<E> parallelStream() { ... } }",
              "description": "Shows how an interface can include several default methods."
            }
          ]
        }
      ]
    },
    {
      "id": "completableFuture",
      "title": "CompletableFuture",
      "content": "CompletableFuture extends Future to support asynchronous programming with a more functional approach and better composition.",
      "description": "CompletableFuture is an enhanced Future that supports asynchronous programming, providing a more flexible and functional approach to handling concurrent operations.",
      "subsections": [
        {
          "title": "Key Features",
          "list": [
            "Supports composition of asynchronous operations",
            "Provides callback mechanisms",
            "Enables exception handling for asynchronous code",
            "Can combine multiple async operations"
          ]
        },
        {
          "title": "Creation Methods",
          "methods": [
            {
              "name": "supplyAsync()",
              "description": "Creates a CompletableFuture that asynchronously supplies a result using a Supplier.",
              "example": "CompletableFuture.supplyAsync(() -> fetchData())"
            },
            {
              "name": "runAsync()",
              "description": "Creates a CompletableFuture that runs a Runnable task asynchronously without returning a result.",
              "example": "CompletableFuture.runAsync(() -> process())"
            }
          ],
          "code": [
            {
              "language": "java",
              "snippet": "// Supply a value asynchronously\nCompletableFuture<String> future1 = CompletableFuture.supplyAsync(() -> {\n    // Long running computation\n    return \"Result\";\n});\n\n// Run a task asynchronously (no result)\nCompletableFuture<Void> future2 = CompletableFuture.runAsync(() -> {\n    // Background task\n});\n\n// Create a completed future\nCompletableFuture<String> future3 = CompletableFuture.completedFuture(\"Done\");"
            }
          ]
        },
        {
          "title": "Transformation and Composition",
          "methods": [
            {
              "name": "thenApply()",
              "description": "Transforms the result of a CompletableFuture using a function, returning a new CompletableFuture with the transformed result.",
              "example": "future.thenApply(result -> result.toUpperCase())"
            },
            {
              "name": "thenCompose()",
              "description": "Chains multiple asynchronous operations by using the result of one future to start another.",
              "example": "future.thenCompose(result -> fetchMore(result))"
            },
            {
              "name": "thenCombine()",
              "description": "Combines the results of two independent CompletableFutures using a specified function.",
              "example": "future1.thenCombine(future2, (r1, r2) -> r1 + r2)"
            }
          ],
          "code": [
            {
              "language": "java",
              "snippet": "CompletableFuture<String> result = CompletableFuture.supplyAsync(() -> \"Hello\")\n    // Transform the result\n    .thenApply(s -> s + \" World\")\n    \n    // Perform action with result (returns CompletableFuture<Void>)\n    .thenAccept(System.out::println)\n    \n    // Chain with another CompletableFuture\n    .thenCompose(ignored -> CompletableFuture.supplyAsync(() -> \"Next step\"))\n    \n    // Combine with another independent CompletableFuture\n    .thenCombine(otherFuture, (result1, result2) -> result1 + \" & \" + result2);"
            }
          ]
        },
        {
          "title": "Error Handling",
          "methods": [
            {
              "name": "exceptionally()",
              "description": "Handles exceptions by providing an alternative result if an error occurs during the asynchronous operation.",
              "example": "future.exceptionally(ex -> handleError(ex))"
            },
            {
              "name": "handle()",
              "description": "Processes both successful results and exceptions, allowing you to return a value based on either outcome.",
              "example": "future.handle((result, ex) -> ex != null ? handleError(ex) : result)"
            }
          ],
          "code": [
            {
              "language": "java",
              "snippet": "CompletableFuture<String> future = CompletableFuture.supplyAsync(() -> {\n    if (Math.random() < 0.5) throw new RuntimeException(\"Failed\");\n    return \"Success\";\n})\n// Handle exception and provide fallback\n.exceptionally(ex -> {\n    System.err.println(\"Error occurred: \" + ex.getMessage());\n    return \"Fallback\";\n})\n// Handle both success and failure cases\n.handle((result, ex) -> {\n    if (ex != null) {\n        return \"Recovered from: \" + ex.getMessage();\n    }\n    return \"Got result: \" + result;\n});"
            }
          ]
        },
        {
          "title": "Combining Multiple Futures",
          "code": [
            {
              "language": "java",
              "snippet": "// Execute after both complete (results ignored)\nCompletableFuture<Void> combined1 = \n    CompletableFuture.allOf(future1, future2, future3);\n\n// Execute after any completes (get first result)\nCompletableFuture<Object> combined2 = \n    CompletableFuture.anyOf(future1, future2, future3);\n\n// Waiting for all futures and collecting results\nList<CompletableFuture<String>> futures = Arrays.asList(future1, future2, future3);\nCompletableFuture<List<String>> allResults = CompletableFuture.allOf(futures.toArray(new CompletableFuture[0]))\n    .thenApply(v -> futures.stream()\n        .map(CompletableFuture::join)\n        .collect(Collectors.toList()));"
            }
          ]
        }
      ]
    },
    {
      "id": "dateTime",
      "title": "Date/Time API (java.time)",
      "content": "Java 8 introduced a comprehensive, immutable, and thread-safe API for date and time operations, addressing the limitations of the legacy date classes.",
      "description": "Modern and comprehensive classes for handling dates and times in Java. These classes offer improved clarity, flexibility, and precision compared to the older date/time APIs.",
      "subsections": [
        {
          "title": "Core Classes",
          "classes": [
            {
              "name": "LocalDate",
              "description": "Represents a date without time or timezone information, ideal for representing calendar dates.",
              "examples": [
                {
                  "operation": "Creation",
                  "code": "LocalDate.now()"
                },
                {
                  "operation": "Parsing",
                  "code": "LocalDate.parse(\"2024-01-01\")"
                },
                {
                  "operation": "Manipulation",
                  "code": "date.plusDays(1).minusMonths(1)"
                }
              ]
            },
            {
              "name": "LocalTime",
              "description": "Represents a time without date or timezone information, useful for specifying times of day.",
              "examples": [
                {
                  "operation": "Creation",
                  "code": "LocalTime.of(13, 30)"
                },
                {
                  "operation": "Parsing",
                  "code": "LocalTime.parse(\"13:30:00\")"
                }
              ]
            },
            {
              "name": "LocalDateTime",
              "description": "Combines date and time without timezone information, providing a complete date-time representation.",
              "examples": [
                {
                  "operation": "Creation",
                  "code": "LocalDateTime.now()"
                },
                {
                  "operation": "Formatting",
                  "code": "dateTime.format(DateTimeFormatter.ISO_LOCAL_DATE_TIME)"
                }
              ]
            },
            {
              "name": "ZonedDateTime",
              "description": "Represents date and time with timezone information, allowing conversions between different time zones.",
              "examples": [
                {
                  "operation": "Creation",
                  "code": "ZonedDateTime.now(ZoneId.of(\"Europe/Paris\"))"
                },
                {
                  "operation": "Conversion",
                  "code": "zonedDateTime.withZoneSameInstant(ZoneId.of(\"America/New_York\"))"
                }
              ]
            }
          ],
          "tables": [
            {
              "headers": ["Class", "Description", "Example"],
              "rows": [
                ["`LocalDate`", "Date without time or timezone", "`LocalDate.now()`"],
                ["`LocalTime`", "Time without date or timezone", "`LocalTime.of(13, 30)`"],
                ["`LocalDateTime`", "Date and time without timezone", "`LocalDateTime.now()`"],
                ["`ZonedDateTime`", "Date and time with timezone", "`ZonedDateTime.now(ZoneId.of(\"Europe/Paris\"))`"],
                ["`Instant`", "Point in time (epoch-based)", "`Instant.now()`"],
                ["`Duration`", "Time-based amount", "`Duration.between(start, end)`"],
                ["`Period`", "Date-based amount", "`Period.between(startDate, endDate)`"]
              ]
            }
          ]
        },
        {
          "title": "Common Operations",
          "code": [
            {
              "language": "java",
              "snippet": "// Creating instances\nLocalDate date = LocalDate.of(2023, Month.JANUARY, 15);\nLocalTime time = LocalTime.of(13, 30, 15);\nLocalDateTime dateTime = LocalDateTime.of(date, time);\n\n// Current date/time\nLocalDate today = LocalDate.now();\nLocalDateTime now = LocalDateTime.now();\n\n// Date manipulation (immutable, returns new instance)\nLocalDate tomorrow = today.plusDays(1);\nLocalDate lastMonth = today.minusMonths(1);\nLocalDate withYear = today.withYear(2022);\n\n// Parsing and formatting\nDateTimeFormatter formatter = DateTimeFormatter.ofPattern(\"yyyy-MM-dd\");\nLocalDate parsed = LocalDate.parse(\"2023-01-15\", formatter);\nString formatted = today.format(formatter);\n\n// Calculations\nPeriod period = Period.between(date1, date2);\nlong days = ChronoUnit.DAYS.between(date1, date2);\n\n// With time zones\nZonedDateTime tokyo = ZonedDateTime.now(ZoneId.of(\"Asia/Tokyo\"));\nZonedDateTime converted = tokyo.withZoneSameInstant(ZoneId.of(\"America/New_York\"));"
            }
          ]
        },
        {
          "title": "Temporal Adjusters",
          "code": [
            {
              "language": "java",
              "snippet": "// Find next Monday\nLocalDate nextMonday = today.with(TemporalAdjusters.next(DayOfWeek.MONDAY));\n\n// Find last day of month\nLocalDate lastDay = today.with(TemporalAdjusters.lastDayOfMonth());"
            }
          ]
        }
      ]
    },
    {
      "id": "base64",
      "title": "Base64 Encoding/Decoding",
      "description": "Provides built-in support for encoding binary data into Base64 strings and decoding Base64 strings back into binary data, simplifying data conversions.",
      "methods": [
        {
          "name": "getEncoder()",
          "description": "Returns a Base64 encoder that converts binary data into a Base64 encoded string.",
          "example": "Base64.getEncoder().encodeToString(bytes)"
        },
        {
          "name": "getDecoder()",
          "description": "Returns a Base64 decoder that converts a Base64 encoded string back into binary data.",
          "example": "Base64.getDecoder().decode(string)"
        }
      ],
      "code": [
        {
          "language": "java",
          "snippet": "// Simple encoding\nString encoded = Base64.getEncoder().encodeToString(\"Hello, World!\".getBytes());\n\n// Decoding\nbyte[] decoded = Base64.getDecoder().decode(encoded);\n\n// URL-safe encoding\nString urlEncoded = Base64.getUrlEncoder().encodeToString(\"Hello?World&Special=Chars\".getBytes());"
        }
      ]
    },
    {
      "id": "modulesystem",
      "title": "Java 9 Module System",
      "content": "The Java Platform Module System (JPMS) introduced in Java 9 provides a way to group related packages and explicitly declare dependencies.",
      "subsections": [
        {
          "title": "Module Declaration",
          "code": [
            {
              "language": "java",
              "snippet": "// In module-info.java\nmodule com.example.myapp {\n    // Modules this module depends on\n    requires java.sql;\n    requires com.example.utils;\n    \n    // Packages this module makes available to other modules\n    exports com.example.myapp.api;\n    \n    // Restrict exports to specific modules\n    exports com.example.myapp.model to com.example.client;\n    \n    // Service provided by this module\n    provides com.example.spi.MyService with com.example.myapp.MyServiceImpl;\n    \n    // Services this module consumes\n    uses com.example.spi.ExternalService;\n}"
            }
          ]
        },
        {
          "title": "Key Module Concepts",
          "list": [
            "**Strong Encapsulation**: Only exported packages are accessible",
            "**Reliable Configuration**: Dependencies are explicitly declared",
            "**Improved Performance**: Better startup time and memory footprint",
            "**Scalability**: Better supports large applications"
          ]
        }
      ]
    },
    {
      "id": "nashorn",
      "title": "Nashorn JavaScript Engine",
      "description": "Nashorn is a lightweight JavaScript engine integrated into Java, enabling dynamic scripting by allowing JavaScript code to be embedded and executed within Java applications.",
      "features": [
        {
          "aspect": "Integration",
          "description": "Allows JavaScript code to be directly embedded into Java applications, facilitating dynamic scripting and seamless integration with Java libraries.",
          "example": "ScriptEngine engine = new ScriptEngineManager().getEngineByName(\"nashorn\");"
        },
        {
          "aspect": "Performance",
          "description": "Offers improved performance compared to previous JavaScript engines, making it more efficient for executing JavaScript code."
        }
      ],
      "code": [
        {
          "language": "java",
          "snippet": "// Get the Nashorn engine\nScriptEngine engine = new ScriptEngineManager().getEngineByName(\"nashorn\");\n\n// Evaluate JavaScript\nObject result = engine.eval(\"var x = 10; x * 2;\");\nSystem.out.println(result);  // 20\n\n// Access Java objects from JavaScript\nengine.put(\"javaList\", new ArrayList<String>());\nengine.eval(\"javaList.add('Hello from JavaScript');\");\n\n// Use JavaScript functions from Java\nengine.eval(\"function greet(name) { return 'Hello, ' + name; }\");\nInvocable invocable = (Invocable) engine;\nString greeting = (String) invocable.invokeFunction(\"greet\", \"World\");\nSystem.out.println(greeting);  // Hello, World"
        }
      ]
    },
    {
      "id": "annotations",
      "title": "Annotations Enhancements",
      "description": "Recent improvements in annotations allow for more expressive metadata. These enhancements include type annotations and repeating annotations, which help reduce boilerplate and improve clarity.",
      "features": [
        {
          "name": "Type Annotations",
          "description": "Annotations that can be applied wherever a type is used, providing additional metadata.",
          "example": "@Nonnull String text"
        },
        {
          "name": "Repeating Annotations",
          "description": "Allows the same annotation to be applied multiple times to a single declaration.",
          "example": "@Schedule(dayOfMonth=\"last\") @Schedule(dayOfWeek=\"Fri\") void doPeriodic() {}"
        }
      ],
      "code": [
        {
          "language": "java",
          "snippet": "// Type annotations\npublic void processString(@NotNull String text) {\n    List<@NotNull String> strings = new ArrayList<>();\n    strings.add(text);\n}\n\n// Repeating annotations\n@Retention(RetentionPolicy.RUNTIME)\n@Repeatable(Schedules.class)\n@interface Schedule {\n    String dayOfMonth() default \"first\";\n    String dayOfWeek() default \"Mon\";\n}\n\n@Retention(RetentionPolicy.RUNTIME)\n@interface Schedules {\n    Schedule[] value();\n}\n\n@Schedule(dayOfMonth = \"last\")\n@Schedule(dayOfWeek = \"Fri\")\nvoid performMonthlyTask() {\n    // Task implementation\n}"
        }
      ]
    },
    {
      "id": "concurrency",
      "title": "Concurrency Utilities",
      "description": "New concurrency APIs and enhancements in Java provide robust support for multi-threaded programming, making concurrent code safer and more efficient.",
      "classes": [
        {
          "name": "StampedLock",
          "description": "A lock with a stamped mechanism that supports both optimistic and pessimistic locking modes, allowing fine-grained control over read/write access.",
          "example": "StampedLock lock = new StampedLock();"
        },
        {
          "name": "LongAdder",
          "description": "A high-performance alternative to AtomicLong, designed for high contention scenarios to reduce contention overhead.",
          "example": "LongAdder adder = new LongAdder();"
        },
        {
          "name": "ConcurrentHashMap Enhancements",
          "description": "Enhanced methods for performing bulk operations and mapping functions concurrently, boosting performance in multi-threaded environments.",
          "example": "map.forEach((key, value) -> { /* process */ });"
        }
      ],
      "code": [
        {
          "language": "java",
          "snippet": "// StampedLock Example\nStampedLock lock = new StampedLock();\n\n// Optimistic read\nlong stamp = lock.tryOptimisticRead();\nDouble currentX = this.x;\nDouble currentY = this.y;\nif (!lock.validate(stamp)) {\n    // Data was modified, get a read lock\n    stamp = lock.readLock();\n    try {\n        currentX = this.x;\n        currentY = this.y;\n    } finally {\n        lock.unlockRead(stamp);\n    }\n}\n\n// LongAdder Example\nLongAdder counter = new LongAdder();\n// Multiple threads increment\ncounter.increment();\n// Get total\nlong sum = counter.sum();\n\n// ConcurrentHashMap bulk operations\nConcurrentHashMap<String, Integer> map = new ConcurrentHashMap<>();\nmap.put(\"one\", 1);\nmap.put(\"two\", 2);\n\n// Parallel forEach\nmap.forEach(1, (key, value) -> {\n    System.out.println(key + \" = \" + value);\n});\n\n// Compute if absent\nInteger value = map.computeIfAbsent(\"three\", k -> 3);\n\n// Reduce and Search operations\nInteger maxValue = map.reduceValues(1, Integer::max);"
        }
      ]
    },
    {
      "id": "additionalFeatures",
      "title": "Additional Java 8+ Features",
      "subsections": [
        {
          "title": "String Enhancements (Java 11+)",
          "code": [
            {
              "language": "java",
              "snippet": "// isBlank() checks if string is empty or only whitespace\nboolean emptyCheck = \"   \".isBlank(); // true\n\n// lines() splits string into stream of lines\nStream<String> lines = \"Line 1\\nLine 2\\nLine 3\".lines();\n\n// strip() removes whitespace from both ends (Unicode-aware)\nString stripped = \" Hello \".strip(); // \"Hello\"\n\n// repeat() repeats a string n times\nString repeated = \"abc\".repeat(3); // \"abcabcabc\""
            }
          ]
        },
        {
          "title": "Collection Factory Methods (Java 9+)",
          "code": [
            {
              "language": "java",
              "snippet": "// Immutable List\nList<String> list = List.of(\"a\", \"b\", \"c\");\n\n// Immutable Set\nSet<String> set = Set.of(\"a\", \"b\", \"c\");\n\n// Immutable Map\nMap<String, Integer> map = Map.of(\n    \"a\", 1,\n    \"b\", 2,\n    \"c\", 3\n);"
            }
          ]
        },
        {
          "title": "var Type Inference (Java 10+)",
          "code": [
            {
              "language": "java",
              "snippet": "// Type inferred from initializer\nvar list = new ArrayList<String>();\nvar map = new HashMap<String, Integer>();\nvar text = \"Hello\"; // inferred as String"
            }
          ]
        }
      ]
    },
    {
      "id": "practicalExample",
      "title": "Practical Combined Example",
      "code": [
        {
          "language": "java",
          "snippet": "// A real-world example combining multiple Java 8+ features\npublic class OrderProcessor {\n    // Process a list of orders using modern Java\n    public Map<String, Double> summarizeOrdersByCustomer(List<Order> orders) {\n        return orders.stream()                                 // Stream API\n            .filter(order -> order.getStatus().isComplete())   // Lambda\n            .collect(Collectors.groupingBy(                    // Collectors\n                Order::getCustomerName,                        // Method reference\n                Collectors.summingDouble(Order::getTotal)      // Function chaining\n            ));\n    }\n    \n    // Async processing with error handling\n    public CompletableFuture<List<OrderResult>> processOrdersAsync(List<Order> orders) {\n        List<CompletableFuture<OrderResult>> futures = orders.stream()\n            .map(order -> CompletableFuture\n                .supplyAsync(() -> processOrder(order))        // Async processing\n                .exceptionally(ex -> {                         // Error handling\n                    log(ex);\n                    return OrderResult.failed(order.getId());\n                }))\n            .collect(Collectors.toList());\n            \n        return CompletableFuture.allOf(futures.toArray(new CompletableFuture[0]))\n            .thenApply(v -> futures.stream()\n                .map(CompletableFuture::join)\n                .collect(Collectors.toList()));\n    }\n    \n    private OrderResult processOrder(Order order) {\n        // Processing logic here\n        return Optional.ofNullable(order)                      // Optional\n            .map(this::calculateDiscount)\n            .map(this::applyTaxes)\n            .map(this::generateInvoice)\n            .orElseThrow(() -> new OrderProcessingException());\n    }\n}"
        }
      ]
    },
    {
      "id": "interviewFAQs",
      "title": "Interview FAQs",
      "subsections": [
        {
          "title": "1. What are the major features introduced in Java 8?",
          "content": "Java 8 introduced several major features:\n\n- Lambda expressions for functional programming\n- Stream API for collection processing\n- Functional interfaces (marked with @FunctionalInterface)\n- Default methods in interfaces\n- Method references\n- Optional for better null handling\n- New Date/Time API (java.time package)\n- CompletableFuture for improved asynchronous programming"
        },
        {
          "title": "2. What is a lambda expression and how is it used?",
          "content": "A lambda expression is an anonymous function that implements a functional interface concisely. Syntax: `(parameters) -> expression` or `(parameters) -> { statements }`. It allows treating functionality as a method argument, enabling functional programming in Java."
        },
        {
          "title": "3. What is the difference between a normal interface and a functional interface?",
          "content": "A functional interface has exactly one abstract method, while a normal interface can have multiple abstract methods. Functional interfaces can be implemented using lambda expressions and are often annotated with @FunctionalInterface. Starting with Java 8, both types of interfaces can contain default and static methods."
        },
        {
          "title": "4. How does the Stream API differ from collections?",
          "list": [
            "Streams provide a view of data, not a data structure",
            "Streams don't modify the source data",
            "Streams use lazy evaluation (operations execute only on terminal operation)",
            "Streams can process data in sequence or parallel",
            "Streams can't be reused after terminal operation",
            "Streams focus on operations, while collections focus on data storage"
          ]
        },
        {
          "title": "5. What's the difference between map() and flatMap() in Stream API?",
          "list": [
            "`map()` transforms each element into exactly one output element",
            "`flatMap()` transforms each element into zero or more elements, flattening the result",
            "`map()` is used for simple transformations, while `flatMap()` is used when dealing with nested collections or streams"
          ]
        },
        {
          "title": "6. How do you execute operations in parallel using the Stream API?",
          "content": "You can create a parallel stream using:\n\n- `collection.parallelStream()` on a collection\n- `stream.parallel()` on an existing stream\n\nThe operations will then execute in parallel, leveraging multiple processor cores. However, you should consider thread safety, non-interference, and statelessness to avoid issues."
        },
        {
          "title": "7. What is the purpose of the Optional class?",
          "content": "Optional is a container object that may or may not contain a non-null value. Its primary purpose is to:\n\n- Avoid NullPointerExceptions\n- Make code more expressive about the possibility of missing values\n- Enforce explicit handling of null cases\n- Provide functional-style operations on optional values"
        },
        {
          "title": "8. What happens when multiple interfaces with default methods are implemented by a class?",
          "content": "When a class implements multiple interfaces with conflicting default methods, Java follows resolution rules:\n\n1. Class methods take priority over interface default methods\n2. More specific interface methods take priority over less specific ones\n3. If ambiguous, the class must explicitly override the method and choose which implementation to use"
        },
        {
          "title": "9. How are method references different from lambda expressions?",
          "content": "Method references are shorthand notations for lambda expressions that call an existing method. Key differences:\n\n- Method references are more concise for simple method calls\n- Lambda expressions allow more complex operations and transformations\n- Method references explicitly name the method being called\n- Lambdas can create new logic not tied to existing methods"
        },
        {
          "title": "10. What is the difference between Predicate, Function, and Consumer functional interfaces?",
          "list": [
            "`Predicate<T>`: Takes an object of type T and returns a boolean (used for filtering)",
            "`Function<T,R>`: Takes an object of type T and returns an object of type R (used for transformation)",
            "`Consumer<T>`: Takes an object of type T and returns nothing (void) (used for operations with side effects)"
          ]
        },
        {
          "title": "11. What are the limitations of parallel streams?",
          "content": "Parallel streams can sometimes be slower due to thread coordination overhead. They should be used for computationally intensive tasks on large data sets. Avoid them with operations that require a specific order or when working with shared mutable state."
        },
        {
          "title": "12. How do functional interfaces work with inheritance?",
          "content": "If an interface extends a functional interface and doesn't declare any additional abstract methods, it is still a functional interface. Multiple abstract methods make it a non-functional interface."
        },
        {
          "title": "13. Can you use both default and static methods in functional interfaces?",
          "content": "Yes, functional interfaces can have multiple default and static methods as long as they have exactly one abstract method."
        }
      ]
    },
    {
      "id": "advancedTopics",
      "title": "Advanced Topics",
      "subsections": [
        {
          "title": "Collectors Techniques",
          "code": [
            {
              "language": "java",
              "snippet": "// Grouping with downstream collectors\nMap<Department, Double> avgSalaryByDept = employees.stream()\n    .collect(Collectors.groupingBy(\n        Employee::getDepartment,\n        Collectors.averagingDouble(Employee::getSalary)\n    ));\n\n// Multi-level grouping\nMap<String, Map<String, List<Employee>>> byLocationAndDepartment = employees.stream()\n    .collect(Collectors.groupingBy(\n        Employee::getLocation,\n        Collectors.groupingBy(Employee::getDepartment)\n    ));\n\n// Custom collector\nCollector<Employee, ?, DoubleSummaryStatistics> salaryStats =\n    Collectors.summarizingDouble(Employee::getSalary);"
            }
          ]
        },
        {
          "title": "Reactive Streams (Java 9+)",
          "code": [
            {
              "language": "java",
              "snippet": "// Publisher-Subscriber model\nFlow.Publisher<String> publisher = subscriber -> {\n    // Publication logic\n};\n\nFlow.Subscriber<String> subscriber = new Flow.Subscriber<>() {\n    // Subscription handling\n};"
            }
          ]
        },
        {
          "title": "Enhanced Try-With-Resources (Java 9+)",
          "code": [
            {
              "language": "java",
              "snippet": "// Java 8\ntry (BufferedReader br = new BufferedReader(new FileReader(path))) {\n    // Use br\n}\n\n// Java 9+ (can use effectively final variables)\nBufferedReader br = new BufferedReader(new FileReader(path));\ntry (br) {\n    // Use br\n}"
            }
          ]
        }
      ]
    },
    {
      "id": "relatedTopics",
      "title": "Related Topics",
      "list": [
        "[[Functional Programming]]",
        "[[Java Fundamentals]]",
        "[[Collections]]",
        "[[Concurrency]]",
        "[[Effective Java Practices]]"
      ],
      "tags": ["lambda", "streams", "optional", "completablefuture", "functional-interfaces"]
    }
  ]
}
