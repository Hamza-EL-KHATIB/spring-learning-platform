{
  "title": "Java Concurrency",
  "id": "java-concurrency",
  "tags": ["java", "concurrency", "multithreading", "backend", "interview"],
  "sections": [
    {
      "id": "core-concepts",
      "title": "Core Concepts Overview",
      "content": "Java concurrency is a powerful but complex aspect of the language that enables concurrent execution and parallel processing. Mastering these concepts is essential for developing high-performance, responsive, and efficient applications.",
      "table": {
        "headers": ["Concept", "Primary Purpose", "Interview Relevance"],
        "rows": [
          ["Threads", "Basic unit of concurrent execution", "★★★★★"],
          ["Synchronization", "Controlling access to shared resources", "★★★★★"],
          ["Thread Safety", "Ensuring correct behavior in concurrent environments", "★★★★★"],
          ["Locks & Atomic Classes", "Fine-grained concurrency control", "★★★★☆"],
          ["Thread Coordination", "Communication between threads", "★★★★☆"],
          ["Executor Framework", "Higher-level thread management", "★★★★☆"],
          ["CompletableFuture", "Modern async programming", "★★★☆☆"],
          ["Concurrent Collections", "Thread-safe data structures", "★★★★☆"],
          ["Thread-Local Storage", "Thread-confined data", "★★★☆☆"],
          ["Concurrency Issues", "Deadlocks, race conditions, etc.", "★★★★★"]
        ]
      }
    },
    {
      "id": "thread-fundamentals",
      "title": "Thread Fundamentals",
      "content": "A thread is the smallest unit of execution within a process. Java supports multithreading, allowing multiple threads to execute concurrently within a single application.",
      "subsections": [
        {
          "id": "thread-lifecycle",
          "title": "Thread States",
          "content": "",
          "states": [
            {
              "state": "New",
              "description": "Thread is created but not started"
            },
            {
              "state": "Runnable",
              "description": "Thread is executing or ready to execute"
            },
            {
              "state": "Blocked",
              "description": "Thread is waiting for a monitor lock"
            },
            {
              "state": "Waiting",
              "description": "Thread is waiting indefinitely for another thread"
            },
            {
              "state": "Timed_Waiting",
              "description": "Thread is waiting for a specified time period"
            },
            {
              "state": "Terminated",
              "description": "Thread has completed execution"
            }
          ]
        }
      ]
    },
    {
      "id": "thread-creation",
      "title": "Thread Creation",
      "content": "There are three main approaches to creating and starting threads:",
      "methods": [
        {
          "method": "Extending Thread",
          "example": "class MyThread extends Thread {\n    public void run() {\n        // Thread logic here\n        System.out.println(\"Thread running\");\n    }\n}\n\n// Usage\nMyThread thread = new MyThread();\nthread.start();",
          "pros": ["Direct access to thread methods", "Simpler for beginners"],
          "cons": ["Cannot extend other classes", "Wastes single inheritance opportunity"]
        },
        {
          "method": "Implementing Runnable",
          "example": "class MyRunnable implements Runnable {\n    public void run() {\n        // Thread logic here\n        System.out.println(\"Thread running\");\n    }\n}\n\n// Usage\nThread thread = new Thread(new MyRunnable());\nthread.start();",
          "pros": ["Can extend other classes", "Better for task abstraction", "Better separates task from execution mechanism", "Allows same task to be executed by different thread implementations"],
          "cons": ["No direct access to thread methods", "Slightly more verbose"]
        },
        {
          "method": "Using Lambda Expressions",
          "example": "Thread thread = new Thread(() -> {\n    // Thread logic here\n    System.out.println(\"Thread running\");\n});\nthread.start();",
          "pros": ["Concise", "Functional style", "Modern approach (Java 8+)"],
          "cons": ["Limited to simple tasks", "Less readable for complex logic"]
        }
      ],
      "note": "Implementing Runnable is generally preferred over extending Thread because it doesn't waste your single inheritance opportunity, better separates the task from the execution mechanism, and allows the same task to be executed by different thread implementations."
    },
    {
      "id": "thread-vs-process",
      "title": "Thread vs Process",
      "table": {
        "headers": ["Process", "Thread"],
        "rows": [
          ["Independent program execution", "Lightweight execution unit within a process"],
          ["Has its own memory space", "Shares memory space with other threads in process"],
          ["More resource-intensive to create", "Less resource-intensive to create"],
          ["Inter-process communication is complex", "Inter-thread communication is simpler"],
          ["If one process crashes, others are unaffected", "If one thread crashes, it may crash the entire process"]
        ]
      }
    },
    {
      "id": "thread-safety",
      "title": "Thread Safety Mechanisms",
      "content": "Thread safety refers to code that functions correctly during simultaneous execution by multiple threads. Several mechanisms ensure thread safety:",
      "mechanisms": [
        {
          "type": "Synchronization",
          "content": "Synchronization ensures that only one thread can access the synchronized code at a time, using intrinsic locks (monitors).",
          "methods": [
            {
              "name": "synchronized method",
              "usage": "Method-level synchronization",
              "example": "public synchronized void synchronizedMethod() {\n    // Only one thread can execute this method on this object at a time\n    count++;\n}"
            },
            {
              "name": "synchronized block",
              "usage": "Block-level synchronization",
              "example": "public void method() {\n    // Unsynchronized code\n    synchronized(this) {\n        // Synchronized code block\n        count++;\n    }\n    // Unsynchronized code\n}"
            }
          ],
          "whenToUse": [
            "When multiple threads need to access shared mutable data",
            "When compound operations need to be atomic",
            "When you need both visibility and atomicity guarantees"
          ]
        },
        {
          "type": "Volatile",
          "content": "The `volatile` keyword ensures that a variable is always read from and written to main memory, not from thread-local caches.",
          "example": "private volatile boolean flag = false;\n\n// In one thread\nflag = true;\n\n// In another thread\nwhile (!flag) {\n    // This will see the update made by the other thread\n}",
          "properties": [
            "Guarantees visibility of changes across threads",
            "Prevents reordering of instructions around volatile accesses",
            "Does NOT provide atomicity for compound operations (like i++)"
          ],
          "whenToUse": [
            "For simple flags or state values",
            "When you need visibility but not mutual exclusion",
            "For double-checked locking pattern"
          ]
        },
        {
          "type": "Atomic Classes",
          "content": "Atomic classes in `java.util.concurrent.atomic` package provide operations that are atomic without using locks.",
          "example": "import java.util.concurrent.atomic.AtomicInteger;\n\nAtomicInteger counter = new AtomicInteger(0);\n\n// Thread-safe increment\ncounter.incrementAndGet();  // Returns the incremented value\ncounter.getAndIncrement();  // Returns the value before increment\n\n// Conditional update\ncounter.compareAndSet(expectedValue, newValue);",
          "classes": [
            "AtomicInteger, AtomicLong, AtomicBoolean",
            "AtomicReference<V>",
            "AtomicIntegerArray, AtomicLongArray, AtomicReferenceArray<V>",
            "LongAdder, LongAccumulator (higher performance for high contention)"
          ],
          "whenToUse": [
            "For simple counters or flags",
            "When performance is critical",
            "When lock contention is high"
          ]
        },
        {
          "type": "Locks",
          "content": "The `java.util.concurrent.locks` package provides more flexible locking mechanisms than synchronized blocks.",
          "example": "import java.util.concurrent.locks.Lock;\nimport java.util.concurrent.locks.ReentrantLock;\n\nLock lock = new ReentrantLock();\n\ntry {\n    lock.lock();  // Acquire the lock\n    // Critical section\n} finally {\n    lock.unlock();  // Always release in a finally block\n}\n\n// Timed lock acquisition\nif (lock.tryLock(1, TimeUnit.SECONDS)) {\n    try {\n        // Critical section\n    } finally {\n        lock.unlock();\n    }\n} else {\n    // Handle timeout\n}",
          "lockTypes": [
            "ReentrantLock: Basic lock implementation with reentrancy",
            "ReadWriteLock: Allows multiple concurrent reads or a single exclusive write",
            "StampedLock: Enhanced read-write lock with optimistic reading"
          ],
          "whenToUse": [
            "When you need more flexibility than synchronized",
            "When you need timed lock attempts",
            "When you need fairness guarantees",
            "When lock ownership information is needed"
          ]
        }
      ]
    },
    {
      "id": "thread-coordination",
      "title": "Thread Coordination",
      "subsections": [
        {
          "id": "wait-notify",
          "title": "wait(), notify(), and notifyAll()",
          "content": "These methods allow threads to communicate and coordinate:",
          "example": "// Consumer thread\nsynchronized (queue) {\n    while (queue.isEmpty()) {\n        queue.wait();  // Releases lock and waits\n    }\n    Object item = queue.remove();\n}\n\n// Producer thread\nsynchronized (queue) {\n    queue.add(item);\n    queue.notify();  // Wakes up a single waiting thread\n    // OR\n    queue.notifyAll();  // Wakes up all waiting threads\n}",
          "important": "wait(), notify(), and notifyAll() must be called from within a synchronized block on the object they're invoked on."
        },
        {
          "id": "join",
          "title": "join()",
          "content": "The join() method allows one thread to wait for another to complete:",
          "example": "Thread thread = new Thread(() -> {\n    // Task\n});\nthread.start();\n\n// Current thread will wait for the other thread to finish\nthread.join();\n// Or wait for a limited time\nthread.join(1000);  // Wait up to 1000ms"
        },
        {
          "id": "countdown-latch",
          "title": "CountDownLatch",
          "content": "A synchronization aid that allows one or more threads to wait until a set of operations completes.",
          "example": "CountDownLatch latch = new CountDownLatch(3);  // Initialize with count\n\n// In worker threads\nlatch.countDown();  // Decrements the count\n\n// In waiting thread\nlatch.await();  // Blocks until count reaches zero\n// or with timeout\nlatch.await(1, TimeUnit.SECONDS);",
          "useCases": [
            "Starting a group of threads at the same time",
            "Waiting for a group of threads to complete",
            "Implementing a one-time gate"
          ]
        },
        {
          "id": "cyclic-barrier",
          "title": "CyclicBarrier",
          "content": "A synchronization aid that allows a set of threads to wait for each other to reach a common point.",
          "example": "CyclicBarrier barrier = new CyclicBarrier(3, () -> {\n    // Optional runnable that executes when barrier is tripped\n    System.out.println(\"All threads have reached the barrier\");\n});\n\n// In each thread\nbarrier.await();  // Blocks until all threads reach this point",
          "differences": [
            "Reusable after threads are released",
            "All threads must call await() (symmetric)",
            "Can execute a task when the barrier is reached"
          ]
        },
        {
          "id": "phaser",
          "title": "Phaser",
          "content": "A more flexible synchronization barrier that can vary in parties and phases.",
          "example": "Phaser phaser = new Phaser(3);  // 3 parties\n\n// Register additional party\nphaser.register();\n\n// Deregister party\nphaser.arriveAndDeregister();\n\n// Wait for phase to complete\nphaser.arriveAndAwaitAdvance();",
          "useCases": [
            "Multi-phase computations",
            "Dynamic number of participating threads",
            "More complex synchronization scenarios"
          ]
        }
      ]
    },
    {
      "id": "executors",
      "title": "Executor Framework",
      "content": "The `java.util.concurrent.Executor` framework provides a higher-level replacement for direct thread manipulation.",
      "subsections": [
        {
          "id": "executor-service",
          "title": "ExecutorService",
          "example": "// Create a fixed thread pool with 5 threads\nExecutorService executor = Executors.newFixedThreadPool(5);\n\n// Submit tasks\nFuture<String> future = executor.submit(() -> {\n    // Task that returns a result\n    return \"Result\";\n});\n\n// Get result (blocks until available)\nString result = future.get();\n\n// Shutdown (waits for tasks to complete)\nexecutor.shutdown();\n// Force shutdown\nexecutor.shutdownNow();"
        },
        {
          "id": "thread-pool-types",
          "title": "Thread Pool Types",
          "types": [
            {
              "type": "Fixed Thread Pool",
              "creation": "ExecutorService fixed = Executors.newFixedThreadPool(nThreads);",
              "description": [
                "Creates a fixed number of threads",
                "Queue tasks if all threads are busy",
                "Good for limiting resource usage"
              ],
              "bestPractices": [
                "Size pool based on CPU cores and task type (CPU-bound or I/O-bound)",
                "Consider task queue size to avoid OutOfMemoryError",
                "Monitor for thread leaks and handle uncaught exceptions"
              ]
            },
            {
              "type": "Cached Thread Pool",
              "creation": "ExecutorService cached = Executors.newCachedThreadPool();",
              "description": [
                "Creates new threads as needed, reuses existing ones",
                "Terminates unused threads after 60 seconds",
                "Good for many short-lived tasks"
              ],
              "bestPractices": [
                "Use for short-lived and low-latency tasks",
                "Monitor thread creation to prevent resource exhaustion",
                "Not suitable for high volumes of long-running tasks"
              ]
            },
            {
              "type": "Scheduled Thread Pool",
              "creation": "ScheduledExecutorService scheduled = Executors.newScheduledThreadPool(corePoolSize);\n\n// Run once after delay\nscheduled.schedule(task, 1, TimeUnit.SECONDS);\n\n// Run repeatedly with fixed delay between completion and next start\nscheduled.scheduleWithFixedDelay(task, 1, 5, TimeUnit.SECONDS);\n\n// Run repeatedly with fixed rate (tries to maintain frequency)\nscheduled.scheduleAtFixedRate(task, 1, 5, TimeUnit.SECONDS);",
              "description": [
                "Allows scheduling tasks after a delay or periodically"
              ],
              "bestPractices": [
                "Consider task timing requirements carefully",
                "Handle task overlap scenarios (for fixed-rate execution)",
                "Monitor scheduling drift and adjust if necessary",
                "Use scheduleWithFixedDelay for tasks that must not overlap"
              ]
            },
            {
              "type": "Single Thread Executor",
              "creation": "ExecutorService single = Executors.newSingleThreadExecutor();",
              "description": [
                "Uses a single worker thread",
                "Guarantees sequential execution of tasks"
              ],
              "bestPractices": [
                "Use for tasks that must execute sequentially",
                "Good for eliminating thread safety concerns",
                "Consider task execution time to avoid blocking"
              ]
            }
          ]
        },
        {
          "id": "execute-vs-submit",
          "title": "execute() vs submit()",
          "table": {
            "headers": ["execute()", "submit()"],
            "rows": [
              ["Returns void", "Returns a Future object"],
              ["Only accepts Runnable", "Accepts both Runnable and Callable"],
              ["Exceptions go to the uncaught exception handler", "Exceptions are encapsulated in the Future"],
              ["Simpler usage", "More control and monitoring"]
            ]
          },
          "example": "// execute\nexecutor.execute(() -> System.out.println(\"Task executed\"));\n\n// submit with Runnable (Future<null>)\nFuture<?> future1 = executor.submit(() -> System.out.println(\"Task executed\"));\n\n// submit with Callable (Future<String>)\nFuture<String> future2 = executor.submit(() -> \"Task result\");"
        }
      ]
    },
    {
      "id": "completable-future",
      "title": "CompletableFuture (Java 8+)",
      "content": "`CompletableFuture` provides a more functional approach to asynchronous programming.",
      "example": "// Create and run asynchronous computation\nCompletableFuture<String> future = CompletableFuture.supplyAsync(() -> {\n    // Task that returns a result\n    return \"Result\";\n});\n\n// Chain operations\nCompletableFuture<String> transformed = future\n    .thenApply(s -> s.toUpperCase())  // Transform result\n    .thenCompose(s -> anotherAsyncOperation(s))  // Chain another async operation\n    .thenCombine(otherFuture, (s1, s2) -> s1 + s2);  // Combine with another future\n\n// Handle exceptions\nCompletableFuture<String> handled = future.exceptionally(ex -> {\n    return \"Default value due to error: \" + ex.getMessage();\n});\n\n// Register callback\nfuture.thenAccept(result -> System.out.println(\"Result: \" + result));\n\n// Wait for completion\nString result = future.get();  // Blocking",
      "features": [
        "Non-blocking operations",
        "Easy composition of async operations",
        "Functional-style error handling",
        "Combine multiple futures",
        "Default executor or custom executor"
      ]
    },
    {
      "id": "concurrent-collections",
      "title": "Concurrent Collections",
      "content": "Thread-safe collection implementations designed for concurrent access.",
      "collections": [
        {
          "name": "ConcurrentHashMap",
          "content": "Thread-safe alternative to `HashMap` with better concurrency.",
          "example": "ConcurrentHashMap<String, Integer> map = new ConcurrentHashMap<>();\n\n// Basic operations are thread-safe\nmap.put(\"key\", 1);\nmap.get(\"key\");\nmap.remove(\"key\");\n\n// Atomic operations\nmap.putIfAbsent(\"key\", 1);\nmap.replace(\"key\", 1, 2);\nmap.remove(\"key\", 1);\n\n// Aggregate operations (Java 8+)\nmap.forEach(4, (key, value) -> System.out.println(key + \"=\" + value));\nint sum = map.reduceValues(4, Integer::sum);",
          "characteristics": [
            "Thread-safe without external synchronization",
            "Better concurrency using segment locking",
            "Doesn't allow null keys or values",
            "Iteration doesn't throw ConcurrentModificationException",
            "Lock striping for better performance",
            "Atomic operations support"
          ]
        },
        {
          "name": "CopyOnWriteArrayList",
          "content": "Thread-safe collections optimized for read-heavy scenarios.",
          "example": "CopyOnWriteArrayList<String> list = new CopyOnWriteArrayList<>();\nlist.add(\"item\");\n\n// Iteration is safe even during concurrent modifications\nfor (String item : list) {\n    // Other threads can modify list safely\n}",
          "characteristics": [
            "Thread-safe without external synchronization",
            "All mutative operations create a new copy of the underlying array",
            "Ideal for rarely-modified, frequently-read collections",
            "Iteration doesn't throw ConcurrentModificationException",
            "Higher memory consumption due to copying"
          ]
        },
        {
          "name": "BlockingQueue",
          "content": "Thread-safe queues that support operations that wait for the queue to become non-empty or non-full.",
          "example": "// Bounded queue with fixed capacity\nBlockingQueue<Task> queue = new ArrayBlockingQueue<>(100);\n\n// Unbounded queue\nBlockingQueue<Task> unbounded = new LinkedBlockingQueue<>();\n\n// Priority-based queue\nBlockingQueue<Task> priorityQueue = new PriorityBlockingQueue<>();\n\n// Delayed queue (elements can't be taken until their delay expires)\nBlockingQueue<DelayedTask> delayedQueue = new DelayQueue<>();\n\n// Insert (waits if queue is full)\nqueue.put(task);\n\n// Remove (waits if queue is empty)\nTask task = queue.take();\n\n// Timed operations\nqueue.offer(task, 1, TimeUnit.SECONDS);  // Waits up to 1 second if full\nTask task = queue.poll(1, TimeUnit.SECONDS);  // Waits up to 1 second if empty",
          "implementations": [
            {
              "name": "ArrayBlockingQueue",
              "description": "Bounded blocking queue with array implementation"
            },
            {
              "name": "LinkedBlockingQueue",
              "description": "Optionally bounded blocking queue with linked nodes"
            },
            {
              "name": "PriorityBlockingQueue",
              "description": "Unbounded blocking priority queue"
            },
            {
              "name": "DelayQueue",
              "description": "Queue for delayed elements, sorted by expiration time"
            }
          ],
          "applications": [
            "Producer-consumer pattern",
            "Thread pools",
            "Message passing between threads",
            "Task scheduling"
          ]
        }
      ]
    },
    {
      "id": "concurrency-patterns",
      "title": "Concurrency Patterns",
      "patterns": [
        {
          "name": "Producer-Consumer Pattern",
          "description": "Separate data production and consumption, typically using a shared buffer.",
          "example": "class ProducerConsumer {\n    private final BlockingQueue<Item> queue;\n    \n    public ProducerConsumer(int capacity) {\n        this.queue = new ArrayBlockingQueue<>(capacity);\n    }\n    \n    public void produce(Item item) throws InterruptedException {\n        queue.put(item);\n    }\n    \n    public Item consume() throws InterruptedException {\n        return queue.take();\n    }\n}",
          "implementation": {
            "using": "BlockingQueue",
            "advantages": [
              "Decouples production and consumption",
              "Handles synchronization automatically",
              "Controls flow with backpressure"
            ]
          }
        },
        {
          "name": "Thread-Local Storage",
          "description": "Thread-confined variables which can only be read and written by the same thread.",
          "example": "// Define a ThreadLocal variable\nprivate static ThreadLocal<UserContext> userContextHolder = ThreadLocal.withInitial(() -> new UserContext());\n\n// Set value for current thread\nuserContextHolder.set(userContext);\n\n// Get value for current thread\nUserContext userContext = userContextHolder.get();\n\n// Remove value when done (important to prevent memory leaks in thread pools)\nuserContextHolder.remove();",
          "useCases": [
            "Per-thread context (user session, transaction, etc.)",
            "Thread-confined random number generators",
            "Caching that should be thread-specific"
          ],
          "warning": "ThreadLocal variables in thread pools can lead to memory leaks if not properly cleaned after thread reuse. Always call remove() when done."
        },
        {
          "name": "Work Stealing",
          "description": "Designed for tasks that can be broken into smaller pieces recursively.",
          "example": "// Fork/Join framework uses work stealing\nForkJoinPool pool = new ForkJoinPool();\n\n// Submit a task\nFuture<Result> future = pool.submit(new RecursiveTask<Result>() {\n    @Override\n    protected Result compute() {\n        if (workIsTooLarge()) {\n            // Split work and process in parallel\n            return ForkJoinTask.invokeAll(createSubtasks())\n                    .stream()\n                    .map(ForkJoinTask::join)\n                    .reduce(this::combine)\n                    .get();\n        } else {\n            return processSequentially();\n        }\n    }\n});",
          "implementation": {
            "using": "ForkJoinPool",
            "advantages": [
              "Efficient CPU utilization",
              "Automatic load balancing",
              "Suitable for divide-and-conquer algorithms"
            ]
          }
        },
        {
          "name": "Future Pattern",
          "description": "Get results from asynchronous computations.",
          "example": "CompletableFuture<Result> future = CompletableFuture.supplyAsync(() -> compute());",
          "implementation": {
            "using": "CompletableFuture",
            "advantages": [
              "Non-blocking operations",
              "Composable operations with thenApply, thenCompose",
              "Exception handling with exceptionally",
              "Combining multiple futures"
            ]
          }
        }
      ]
    },
    {
      "id": "concurrency-problems",
      "title": "Concurrency Problems & Solutions",
      "subsections": [
        {
          "id": "race-conditions",
          "title": "Race Conditions",
          "content": "A race condition occurs when the behavior of a program depends on the relative timing of events, such as the order in which threads execute.",
          "example": "// Unsafe counter\nclass Counter {\n    private int count = 0;\n    \n    public void increment() {\n        count++; // This is not atomic\n    }\n    \n    public int getCount() {\n        return count;\n    }\n}",
          "solutions": [
            {
              "title": "Use synchronization",
              "code": "public synchronized void increment() {\n    count++;\n}"
            },
            {
              "title": "Use AtomicInteger",
              "code": "private AtomicInteger count = new AtomicInteger(0);\n\npublic void increment() {\n    count.incrementAndGet();\n}"
            }
          ]
        },
        {
          "id": "deadlocks",
          "title": "Deadlocks",
          "content": "A deadlock occurs when two or more threads are blocked forever, each waiting for resources held by the other.",
          "example": "// Potential deadlock\nsynchronized(resourceA) {\n    // Do something\n    synchronized(resourceB) {\n        // Do something else\n    }\n}\n\n// In another thread\nsynchronized(resourceB) {\n    // Do something\n    synchronized(resourceA) {\n        // Do something else\n    }\n}",
          "solutions": [
            {
              "title": "Always acquire locks in the same order",
              "code": "// Both threads should acquire locks in the same order\nsynchronized(lock1) {\n    synchronized(lock2) {\n        // Safe code\n    }\n}"
            },
            {
              "title": "Use timeout when acquiring locks",
              "code": "Lock lock1 = new ReentrantLock();\nLock lock2 = new ReentrantLock();\n\nif (lock1.tryLock(1, TimeUnit.SECONDS)) {\n    try {\n        if (lock2.tryLock(1, TimeUnit.SECONDS)) {\n            try {\n                // Safe code\n            } finally {\n                lock2.unlock();\n            }\n        }\n    } finally {\n        lock1.unlock();\n    }\n}"
            }
          ]
        },
        {
          "id": "starvation",
          "title": "Starvation",
          "content": "Starvation occurs when a thread is unable to gain regular access to shared resources and is unable to make progress.",
          "solutions": [
            "1. Use fair locks",
            {
              "code": "Lock fairLock = new ReentrantLock(true); // true for fair ordering"
            },
            "2. Prioritize resource allocation"
          ]
        },
        {
          "id": "memory-consistency",
          "title": "Memory Consistency Errors",
          "content": "Memory consistency errors occur when different threads have inconsistent views of the same data.",
          "solutions": [
            "1. Use `volatile` for visibility",
            {
              "code": "private volatile boolean flag = false;"
            },
            "2. Use synchronization or concurrent utilities"
          ]
        },
        {
          "id": "thread-leakage",
          "title": "Thread Leakage",
          "content": "Thread leakage occurs when threads are created but not properly terminated or cleaned up.",
          "solutions": [
            "1. Always call `shutdown()` on ExecutorService",
            {
              "code": "try {\n    // Use the executor\n} finally {\n    executor.shutdown();\n}"
            },
            "2. Use try-with-resources with AutoCloseable ExecutorService wrapper"
          ]
        }
      ]
    },
    {
      "id": "advanced-topics",
      "title": "Advanced Topics",
      "subsections": [
        {
          "id": "forkjoinpool",
          "title": "ForkJoinPool and Parallelism",
          "content": "The ForkJoinPool is designed for tasks that can be broken into smaller pieces recursively. It's the default executor for parallel streams.",
          "example": "// Custom fork/join task\nclass SortTask extends RecursiveAction {\n    private final int[] array;\n    private final int start;\n    private final int end;\n    \n    // Constructor\n    \n    @Override\n    protected void compute() {\n        if (end - start < THRESHOLD) {\n            // Sort directly\n            Arrays.sort(array, start, end);\n        } else {\n            // Split and fork\n            int mid = start + (end - start) / 2;\n            invokeAll(\n                new SortTask(array, start, mid),\n                new SortTask(array, mid, end)\n            );\n            // Merge results\n            merge(array, start, mid, end);\n        }\n    }\n}\n\n// Usage\nForkJoinPool pool = new ForkJoinPool();\npool.invoke(new SortTask(array, 0, array.length));"
        },
        {
          "id": "parallel-streams",
          "title": "Parallel Streams",
          "content": "Parallel streams execute operations concurrently, potentially improving performance on multi-core systems.",
          "example": "// Sequential stream\nList<Integer> result = numbers.stream()\n    .filter(n -> n % 2 == 0)\n    .map(n -> n * 2)\n    .collect(Collectors.toList());\n\n// Parallel stream\nList<Integer> result = numbers.parallelStream()\n    .filter(n -> n % 2 == 0)\n    .map(n -> n * 2)\n    .collect(Collectors.toList());\n\n// Or convert from sequential\nList<Integer> result = numbers.stream()\n    .parallel()\n    .filter(n -> n % 2 == 0)\n    .map(n -> n * 2)\n    .collect(Collectors.toList());",
          "considerations": [
            "Best for computationally intensive operations",
            "Can be slower for small datasets due to overhead",
            "May not maintain order without explicit ordering",
            "Thread safety concerns for stateful operations",
            "Uses the common ForkJoinPool by default"
          ]
        },
        {
          "id": "stamped-lock",
          "title": "StampedLock",
          "content": "A capability-based lock with three modes: write, read, and optimistic read.",
          "example": "StampedLock lock = new StampedLock();\n\n// Write lock\nlong stamp = lock.writeLock();\ntry {\n    // Exclusive access\n} finally {\n    lock.unlockWrite(stamp);\n}\n\n// Read lock\nlong stamp = lock.readLock();\ntry {\n    // Shared access\n} finally {\n    lock.unlockRead(stamp);\n}\n\n// Optimistic read\nlong stamp = lock.tryOptimisticRead();\n// Read data\nif (!lock.validate(stamp)) {\n    // Data may have been modified, acquire read lock\n    stamp = lock.readLock();\n    try {\n        // Re-read data\n    } finally {\n        lock.unlockRead(stamp);\n    }\n}",
          "advantages": [
            "Better throughput in read-heavy scenarios",
            "Support for lock upgrading/downgrading",
            "Optimistic reading for high-contention scenarios"
          ]
        },
        {
          "id": "longadder",
          "title": "LongAdder and LongAccumulator",
          "content": "High-performance alternatives to AtomicLong for heavily contended counting.",
          "example": "LongAdder counter = new LongAdder();\ncounter.increment();\ncounter.add(5);\nlong current = counter.sum();\n\n// LongAccumulator for custom accumulation\nLongAccumulator accumulator = new LongAccumulator(Long::sum, 0L);\naccumulator.accumulate(10);\naccumulator.accumulate(5);\nlong result = accumulator.get(); // 15"
        },
        {
          "id": "threadlocalrandom",
          "title": "ThreadLocalRandom",
          "content": "Thread-local random number generation for better performance in concurrent scenarios.",
          "example": "// Instead of\nRandom random = new Random();\nint value = random.nextInt(100);\n\n// Use\nint value = ThreadLocalRandom.current().nextInt(100);"
        }
      ]
    },
    {
      "id": "interview-questions",
      "title": "Common Interview Questions",
      "questions": [
        {
          "question": "What is the difference between process and thread?",
          "answer": "A process is an independent program execution with its own memory space and resources, while a thread is a lightweight execution unit within a process. Threads within the same process share the memory space and resources.\n\nKey differences:\n- Processes have separate memory; threads share memory\n- Inter-process communication is more complex than inter-thread communication\n- Thread creation is faster than process creation\n- If one thread crashes, it may crash the entire process"
        },
        {
          "question": "What's the difference between `synchronized` and `volatile`?",
          "answer": "Both provide thread safety, but with different guarantees:\n\n**Synchronized:**\n- Provides mutual exclusion and visibility guarantees\n- Ensures only one thread executes synchronized code at a time\n- More heavyweight; involves acquiring and releasing locks\n- Can be applied to methods or blocks\n\n**Volatile:**\n- Provides only visibility guarantees, not atomicity\n- Ensures reads/writes go directly to main memory\n- Cannot make compound operations (like i++) atomic\n- Can only be applied to fields"
        },
        {
          "question": "What is the purpose of the `wait()`, `notify()`, and `notifyAll()` methods?",
          "answer": "These methods are used for inter-thread communication:\n\n- `wait()`: Causes the current thread to wait until another thread invokes `notify()` or `notifyAll()` on the same object\n- `notify()`: Wakes up a single thread waiting on the object\n- `notifyAll()`: Wakes up all threads waiting on the object\n\nImportant: They must be called from within a synchronized block on the object they're invoked on."
        },
        {
          "question": "How does ConcurrentHashMap provide thread safety?",
          "answer": "ConcurrentHashMap uses a segmented approach or fine-grained locking to provide thread safety without locking the entire map. Key features:\n\n- Uses multiple locks (one for each segment/bucket) for better concurrency\n- Allows concurrent reads without locking\n- Provides atomic operations like putIfAbsent, replace\n- Doesn't allow null keys or values\n- Efficient concurrent access without blocking all threads"
        },
        {
          "question": "What is a deadlock and how can it be prevented?",
          "answer": "A deadlock occurs when two or more threads are blocked forever, each waiting for resources held by the others. To prevent deadlocks:\n\n1. Always acquire locks in a consistent order\n2. Use timed lock acquisition (tryLock with timeout)\n3. Avoid nested locks where possible\n4. Use deadlock detection tools/strategies\n5. Release locks in a finally block"
        },
        {
          "question": "What is the purpose of ThreadLocal?",
          "answer": "ThreadLocal provides thread-confined variables that can only be read and written by the same thread, creating independent copies for each thread.\n\nCommon uses:\n- Storing per-thread context (user identity, transactions)\n- Thread-specific caching\n- Random number generators per thread\n- Avoiding synchronization when each thread needs its own variable\n\nImportant: Always clean up ThreadLocal variables when done to prevent memory leaks, especially in thread pools."
        },
        {
          "question": "Explain the difference between Callable and Runnable.",
          "answer": "Both represent tasks that can be executed by a thread, but:\n\n**Runnable:**\n- No return value (void run() method)\n- Cannot throw checked exceptions\n- Used with both Thread and ExecutorService\n\n**Callable:**\n- Returns a value (V call() method)\n- Can throw checked exceptions\n- Used primarily with ExecutorService\n- Returns a Future object to retrieve the result"
        },
        {
          "question": "What is the difference between CountDownLatch and CyclicBarrier?",
          "answer": "Both help synchronize threads, but:\n\n**CountDownLatch:**\n- One-time barrier with fixed count\n- Count decreases via countDown() calls\n- Waiting thread(s) released when count reaches zero\n- Cannot be reset once count reaches zero\n\n**CyclicBarrier:**\n- Reusable barrier for multiple threads\n- All threads wait at barrier until last thread arrives\n- Automatically resets for reuse\n- Optional action can be executed when barrier trips"
        },
        {
          "question": "How do you handle exceptions in threads?",
          "answer": "Exception handling in threads requires special approaches:\n\n1. Try-catch in run() method:\n```java\npublic void run() {\n    try {\n        // Code\n    } catch (Exception e) {\n        // Handle\n    }\n}\n```\n\n2. Set an UncaughtExceptionHandler:\n```java\nthread.setUncaughtExceptionHandler((t, e) -> {\n    // Handle exception from thread t\n});\n```\n\n3. With ExecutorService, use Future.get() which throws ExecutionException:\n```java\nFuture<?> future = executor.submit(task);\ntry {\n    future.get();\n} catch (ExecutionException e) {\n    Throwable cause = e.getCause(); // Original exception\n}\n```"
        },
        {
          "question": "What are the advantages of using CompletableFuture over Future?",
          "answer": "CompletableFuture offers significant improvements over Future:\n\n- Non-blocking composition of async operations (thenApply, thenCompose)\n- Exception handling (exceptionally, handle)\n- Ability to combine multiple futures (thenCombine, allOf)\n- Support for callbacks (thenAccept, thenRun)\n- Doesn't require manual checking for completion\n- Allows custom executor specification\n- Provides fluent API for functional programming style"
        }
      ]
    },
    {
      "id": "best-practices",
      "title": "Best Practices",
      "practices": [
        {
          "title": "Prefer higher-level concurrency utilities",
          "items": [
            "Use concurrent collections instead of synchronized collections",
            "Use ExecutorService instead of raw threads",
            "Use atomic classes for counters",
            "Use CompletableFuture for async operations"
          ]
        },
        {
          "title": "Design for thread safety",
          "items": [
            "Make immutable objects when possible",
            "Use thread confinement where appropriate",
            "Document thread safety guarantees",
            "Minimize sharing mutable data"
          ]
        },
        {
          "title": "Avoid common issues",
          "items": [
            "Acquire locks in a consistent order to prevent deadlocks",
            "Release resources in finally blocks",
            "Always clean up ThreadLocal variables",
            "Shut down ExecutorServices properly"
          ]
        },
        {
          "title": "Performance considerations",
          "items": [
            "Use lock splitting/striping for high-contention scenarios",
            "Consider read-write locks for read-heavy workloads",
            "Use non-blocking algorithms where possible",
            "Be careful with excessive synchronization"
          ]
        }
      ]
    },
    {
      "id": "related-topics",
      "title": "Related Topics",
      "topics": [
        "Java Fundamentals",
        "Java 8+ Features",
        "Collections Framework",
        "Performance Optimization",
        "Stream API",
        "Lambda Expressions"
      ]
    }
  ],
  "footer_tags": ["multithreading", "parallel-processing", "executor-framework", "thread-safety", "deadlocks", "race-conditions"]
}