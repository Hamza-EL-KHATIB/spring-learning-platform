{
  "title": "Java Concurrency and Multithreading",
  "topics": [
    {
      "id": "thread-lifecycle",
      "title": "Thread Lifecycle",
      "description": "Understanding the lifecycle of a thread in Java, including the various states and transitions.",
      "states": [
        {
          "state": "New",
          "description": "A thread that has been created but not yet started."
        },
        {
          "state": "Runnable",
          "description": "A thread that is ready to run and waiting for CPU allocation."
        },
        {
          "state": "Blocked",
          "description": "A thread that is blocked waiting for a monitor lock."
        },
        {
          "state": "Waiting",
          "description": "A thread that is waiting indefinitely for another thread to perform a particular action."
        },
        {
          "state": "Timed Waiting",
          "description": "A thread that is waiting for another thread to perform an action within a specified waiting time."
        },
        {
          "state": "Terminated",
          "description": "A thread that has completed its execution."
        }
      ]
    },
    {
      "id": "thread-creation",
      "title": "Creating Threads",
      "description": "Different ways to create threads in Java, using Runnable, Thread, and lambda expressions.",
      "methods": [
        {
          "method": "Extending Thread Class",
          "description": "Override the run method in a subclass of Thread.",
          "example": "public class MyThread extends Thread {\n    @Override\n    public void run() {\n        System.out.println(\"Thread running\");\n    }\n}"
        },
        {
          "method": "Implementing Runnable Interface",
          "description": "Pass a Runnable instance to the Thread constructor.",
          "example": "public class MyRunnable implements Runnable {\n    @Override\n    public void run() {\n        System.out.println(\"Runnable running\");\n    }\n}"
        },
        {
          "method": "Using Lambda Expressions",
          "description": "Simplified thread creation using lambdas with functional interfaces.",
          "example": "Thread thread = new Thread(() -> System.out.println(\"Lambda thread running\"));"
        }
      ]
    },
    {
      "id": "synchronization",
      "title": "Thread Synchronization",
      "description": "Ensuring thread safety by controlling access to shared resources.",
      "mechanisms": [
        {
          "name": "Synchronized Methods",
          "description": "Methods that can only be accessed by one thread at a time.",
          "example": "public synchronized void increment() {\n    count++;\n}"
        },
        {
          "name": "Synchronized Blocks",
          "description": "Code blocks synchronized on a specific object, allowing finer control over synchronization.",
          "example": "synchronized(this) {\n    // critical section\n}"
        },
        {
          "name": "Reentrant Locks",
          "description": "A more flexible alternative to synchronized blocks, allowing more complex locking mechanisms.",
          "example": "Lock lock = new ReentrantLock();\nlock.lock();\ntry {\n    // critical section\n} finally {\n    lock.unlock();\n}"
        }
      ]
    },
    {
      "id": "thread-communication",
      "title": "Thread Communication",
      "description": "Mechanisms that allow threads to communicate and coordinate their actions.",
      "methods": [
        {
          "method": "wait()",
          "description": "Causes the current thread to wait until another thread invokes notify or notifyAll on the same object."
        },
        {
          "method": "notify()",
          "description": "Wakes up a single thread that is waiting on this object's monitor."
        },
        {
          "method": "notifyAll()",
          "description": "Wakes up all threads that are waiting on this object's monitor."
        }
      ]
    },
    {
      "id": "thread-pools",
      "title": "Thread Pools",
      "description": "A thread pool reuses a fixed number of threads for executing tasks, improving resource management.",
      "types": [
        {
          "type": "Fixed Thread Pool",
          "description": "A pool with a fixed number of threads.",
          "example": "ExecutorService fixedPool = Executors.newFixedThreadPool(5);"
        },
        {
          "type": "Cached Thread Pool",
          "description": "A flexible pool that creates new threads as needed, but reuses previously constructed threads when available.",
          "example": "ExecutorService cachedPool = Executors.newCachedThreadPool();"
        },
        {
          "type": "Scheduled Thread Pool",
          "description": "A pool that can schedule commands to run after a given delay or periodically.",
          "example": "ScheduledExecutorService scheduledPool = Executors.newScheduledThreadPool(3);"
        }
      ]
    }
  ]
}
