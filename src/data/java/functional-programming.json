{
  "id": "java-functional-programming",
  "title": "Functional Programming",
  "tags": ["java", "functional-programming", "lambda", "streams", "backend"],
  "topics": [
    {
      "id": "introduction",
      "title": "Introduction",
      "description": "Functional Programming (FP) is a programming paradigm that treats computation as the evaluation of mathematical functions and avoids changing state and mutable data. Java 8 introduced significant features that brought functional programming capabilities to the language, transforming how Java developers approach problem-solving.",
      "quotes": [
        "Functional programming is not about eliminating all state; it's about controlling where and how state is managed."
      ]
    },
    {
      "id": "core-concepts",
      "title": "Core Concepts Overview",
      "description": "The fundamental principles that define functional programming paradigm",
      "conceptTable": {
        "headers": ["Concept", "Description", "Interview Relevance"],
        "rows": [
          ["Pure Functions", "Functions without side effects that return the same output for the same input", "★★★★☆"],
          ["Immutability", "Creating unchangeable objects to avoid state mutation", "★★★★☆"],
          ["First-Class Functions", "Functions that can be passed as arguments, returned from other functions, and assigned to variables", "★★★★★"],
          ["Higher-Order Functions", "Functions that take functions as parameters or return functions", "★★★★★"],
          ["Function Composition", "Building complex functions by combining simpler ones", "★★★☆☆"],
          ["Referential Transparency", "Expressions that can be replaced with their values without changing program behavior", "★★☆☆☆"],
          ["Declarative Programming", "Expressing logic without describing control flow", "★★★★☆"]
        ]
      }
    },
    {
      "id": "functional-interfaces",
      "title": "Functional Interfaces",
      "description": "Functional interfaces serve as the cornerstone of Java's functional programming support. They define a single abstract method (SAM) that lambdas implement.",
      "subtopics": [
        {
          "id": "built-in-interfaces",
          "title": "Key Built-in Functional Interfaces",
          "table": {
            "headers": ["Interface", "Method", "Description", "Example Use Case"],
            "rows": [
              ["`Function<T,R>`", "`R apply(T t)`", "Transforms input into output", "Converting String to Integer"],
              ["`Predicate<T>`", "`boolean test(T t)`", "Boolean test on input", "Filtering collections"],
              ["`Consumer<T>`", "`void accept(T t)`", "Performs operation with no return", "Printing elements"],
              ["`Supplier<T>`", "`T get()`", "Provides values without input", "Lazy value generation"],
              ["`UnaryOperator<T>`", "`T apply(T t)`", "Same input/output type transformation", "String transformation"],
              ["`BinaryOperator<T>`", "`T apply(T t1, T t2)`", "Combines two inputs into one output", "Summing two numbers"],
              ["`BiFunction<T,U,R>`", "`R apply(T t, U u)`", "Two inputs, one output operation", "Combining values"],
              ["`BiConsumer<T,U>`", "`void accept(T t, U u)`", "Consumes two inputs, no output", "Adding to a map"],
              ["`BiPredicate<T,U>`", "`boolean test(T t, U u)`", "Tests two inputs for condition", "Comparing objects"]
            ]
          }
        },
        {
          "id": "custom-interfaces",
          "title": "Creating Custom Functional Interfaces",
          "code": "// Example of creating custom functional interface\n@FunctionalInterface\npublic interface TriFunction<A, B, C, R> {\n    R apply(A a, B b, C c);\n    \n    // Can contain default and static methods\n    default TriFunction<A, B, C, R> andThen(Function<? super R, ? extends R> after) {\n        return (a, b, c) -> after.apply(apply(a, b, c));\n    }\n}\n\n// Usage\nTriFunction<Integer, Integer, Integer, Integer> sum = (a, b, c) -> a + b + c;\nint result = sum.apply(1, 2, 3); // Returns 6"
        }
      ]
    },
    {
      "id": "lambda-expressions",
      "title": "Lambda Expressions",
      "description": "Lambda expressions provide a concise way to implement functional interfaces, eliminating boilerplate code associated with anonymous classes.",
      "subtopics": [
        {
          "id": "syntax-variations",
          "title": "Syntax Variations",
          "code": "// (parameters) -> expression\n(int a, int b) -> a + b\n\n// (parameters) -> { statements }\n(String s) -> {\n    String result = s.toUpperCase();\n    return result;\n}\n\n// Parameter type inference\n(a, b) -> a + b\n\n// Single parameter (parentheses optional)\ns -> s.length()\n\n// No parameters\n() -> 42"
        },
        {
          "id": "variable-capture",
          "title": "Scope and Variable Capture",
          "code": "// Lambda expressions can access:\n// 1. Local variables (must be effectively final)\n// 2. Instance variables\n// 3. Static variables\n\n// Effectively final local variable capture\nString prefix = \"User: \";  \nlist.forEach(name -> System.out.println(prefix + name));  // OK\n\n// Attempting to modify captured variables causes compile error\nString counter = \"\"; \nlist.forEach(s -> counter += s.length());  // ERROR: Cannot modify counter"
        }
      ]
    },
    {
      "id": "method-references",
      "title": "Method References",
      "description": "Method references offer a more compact syntax for invoking existing methods, improving code readability when lambda expressions call only one method.",
      "subtopics": [
        {
          "id": "reference-types",
          "title": "Types of Method References",
          "table": {
            "headers": ["Type", "Syntax", "Lambda Equivalent", "Example"],
            "rows": [
              ["Static Method", "`ClassName::staticMethod`", "`(args) -> ClassName.staticMethod(args)`", "`Math::max`"],
              ["Instance Method of Particular Object", "`instance::instanceMethod`", "`(args) -> instance.instanceMethod(args)`", "`System.out::println`"],
              ["Instance Method of Arbitrary Object", "`ClassName::instanceMethod`", "`(obj, args) -> obj.instanceMethod(args)`", "`String::length`"],
              ["Constructor", "`ClassName::new`", "`(args) -> new ClassName(args)`", "`ArrayList::new`"]
            ]
          }
        },
        {
          "id": "reference-examples",
          "title": "Practical Examples",
          "code": "// Static method reference\nFunction<List<String>, Integer> size = List::size;\n\n// Instance method reference (specific object)\nConsumer<String> printer = System.out::println;\n\n// Instance method reference (arbitrary object)\nFunction<String, Integer> lengthFunc = String::length;\nComparator<String> comparator = String::compareToIgnoreCase;\n\n// Constructor reference\nSupplier<List<String>> listFactory = ArrayList::new;\nFunction<Integer, int[]> arrayCreator = int[]::new;"
        }
      ]
    },
    {
      "id": "function-composition",
      "title": "Function Composition",
      "description": "Function composition is building complex operations by combining simpler ones, creating a pipeline of transformations.",
      "code": "// Function composition with andThen (f → g)\nFunction<Integer, Integer> f = x -> x + 1;\nFunction<Integer, Integer> g = x -> x * 2;\nFunction<Integer, Integer> h = f.andThen(g);  // h(x) = g(f(x))\n// h(5) = g(f(5)) = g(6) = 12\n\n// Function composition with compose (g → f)\nFunction<Integer, Integer> h2 = f.compose(g);  // h2(x) = f(g(x))\n// h2(5) = f(g(5)) = f(10) = 11\n\n// Multiple compositions\nFunction<String, String> pipeline = \n    ((Function<String, String>) s -> s.trim())\n        .andThen(String::toLowerCase)\n        .andThen(s -> s.replaceAll(\"\\\\s+\", \"_\"));\n// pipeline(\"  Hello World  \") = \"hello_world\""
    },
    {
      "id": "exception-handling",
      "title": "Handling Exceptions in Functional Code",
      "description": "Handling exceptions in functional interfaces can be challenging since they don't declare checked exceptions.",
      "code": "// Using wrapper methods\npublic static <T, R> Function<T, R> wrap(CheckedFunction<T, R> checkedFunction) {\n    return t -> {\n        try {\n            return checkedFunction.apply(t);\n        } catch (Exception e) {\n            throw new RuntimeException(e);\n        }\n    };\n}\n\n// Define a checked function interface\n@FunctionalInterface\ninterface CheckedFunction<T, R> {\n    R apply(T t) throws Exception;\n}\n\n// Usage example\nFunction<String, URL> urlMapper = wrap(URL::new);\nList<URL> urls = strings.stream()\n    .map(urlMapper)\n    .collect(Collectors.toList());"
    },
    {
      "id": "streams",
      "title": "Functional Data Processing with Streams",
      "description": "The Stream API enables functional-style operations on collections, providing a powerful tool for data processing.",
      "subtopics": [
        {
          "id": "stream-pipeline",
          "title": "Stream Pipeline Construction",
          "code": "// A typical stream pipeline consists of:\n// 1. Source (collection, array, generator)\n// 2. Zero or more intermediate operations (filter, map, etc.)\n// 3. Terminal operation (collect, reduce, forEach, etc.)\n\nList<String> result = people.stream()          // Source\n    .filter(p -> p.getAge() > 18)              // Intermediate op\n    .map(Person::getName)                      // Intermediate op\n    .sorted()                                  // Intermediate op\n    .collect(Collectors.toList());             // Terminal op"
        },
        {
          "id": "lazy-evaluation",
          "title": "Lazy Evaluation",
          "description": "Stream operations use lazy evaluation, meaning:\n\n- Intermediate operations are not executed until a terminal operation is called\n- Operations are fused and optimized as a single pass\n- Elements are processed one by one through the entire pipeline (loop fusion)\n- Short-circuiting operations can stop processing early",
          "code": "// Operations only execute when collect() is called\nStream<String> stream = list.stream()\n    .filter(s -> {\n        System.out.println(\"Filtering: \" + s);\n        return s.startsWith(\"A\");\n    })\n    .map(s -> {\n        System.out.println(\"Mapping: \" + s);\n        return s.toLowerCase();\n    });\n// Nothing happens until here:\nList<String> result = stream.collect(Collectors.toList());"
        },
        {
          "id": "filtering-mapping",
          "title": "Filtering and Mapping",
          "code": "// filter(): Retains elements matching predicate\nList<Person> adults = people.stream()\n    .filter(person -> person.getAge() >= 18)\n    .collect(Collectors.toList());\n\n// map(): Transforms elements\nList<String> names = people.stream()\n    .map(Person::getName)\n    .collect(Collectors.toList());\n\n// flatMap(): Transforms and flattens\nList<String> allSkills = people.stream()\n    .flatMap(p -> p.getSkills().stream())\n    .distinct()\n    .collect(Collectors.toList());"
        },
        {
          "id": "sorting-limiting",
          "title": "Sorting and Limiting",
          "code": "// sorted(): Sorts elements\nList<Person> sortedByName = people.stream()\n    .sorted(Comparator.comparing(Person::getName))\n    .collect(Collectors.toList());\n\n// Compound sorting\nList<Person> sortedComplex = people.stream()\n    .sorted(Comparator.comparing(Person::getAge)\n            .thenComparing(Person::getName)\n            .reversed())\n    .collect(Collectors.toList());\n\n// limit() and skip(): Pagination\nList<Person> paginatedResults = people.stream()\n    .skip(pageSize * pageNumber)\n    .limit(pageSize)\n    .collect(Collectors.toList());"
        },
        {
          "id": "reduction",
          "title": "Aggregation with Reduction",
          "code": "// reduce(): Combines elements\n// 1. Identity value\n// 2. Accumulator function\n// 3. Optional combiner function (for parallel streams)\n\n// Sum of numbers\nint sum = numbers.stream()\n    .reduce(0, Integer::sum);\n\n// Joining strings\nString joined = strings.stream()\n    .reduce(\"\", (a, b) -> a + \",\" + b);\n\n// Finding maximum\nOptional<Person> oldest = people.stream()\n    .reduce((p1, p2) -> p1.getAge() > p2.getAge() ? p1 : p2);"
        },
        {
          "id": "collectors",
          "title": "Collectors for Complex Aggregations",
          "code": "// toList(), toSet(), toMap()\nMap<Integer, Person> peopleById = people.stream()\n    .collect(Collectors.toMap(Person::getId, Function.identity()));\n\n// joining()\nString allNames = people.stream()\n    .map(Person::getName)\n    .collect(Collectors.joining(\", \"));\n\n// groupingBy()\nMap<Department, List<Employee>> byDept = employees.stream()\n    .collect(Collectors.groupingBy(Employee::getDepartment));\n\n// Multi-level grouping\nMap<Department, Map<JobTitle, List<Employee>>> byDeptAndTitle = employees.stream()\n    .collect(Collectors.groupingBy(Employee::getDepartment,\n             Collectors.groupingBy(Employee::getJobTitle)));\n\n// Downstream collectors\nMap<Department, Double> avgSalaryByDept = employees.stream()\n    .collect(Collectors.groupingBy(Employee::getDepartment,\n             Collectors.averagingDouble(Employee::getSalary)));\n\n// partitioningBy(): Splits into two groups based on predicate\nMap<Boolean, List<Employee>> seniorJunior = employees.stream()\n    .collect(Collectors.partitioningBy(e -> e.getYears() > 5));\n\n// summarizingInt/Long/Double\nIntSummaryStatistics stats = employees.stream()\n    .collect(Collectors.summarizingInt(Employee::getAge));\n// stats: {count=x, sum=y, min=a, average=b, max=c}"
        },
        {
          "id": "parallel-streams",
          "title": "Parallel Stream Processing",
          "code": "// Creating parallel streams\nList<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5);\nnumbers.parallelStream()\n       .forEach(n -> System.out.println(n + \" \" + Thread.currentThread().getName()));\n\n// Or from sequential stream\nnumbers.stream()\n       .parallel()\n       .forEach(n -> System.out.println(n + \" \" + Thread.currentThread().getName()));\n\n// Performance considerations\n// - Size of data set (parallelism helps with large data sets)\n// - Splitting cost (ArrayList splits well, LinkedList does not)\n// - Merging cost (operations with expensive merging reduce benefits)\n// - Statelessness (avoid mutable state in parallel stream operations)"
        },
        {
          "id": "spring-boot-streams",
          "title": "Stream Operations in Spring Boot Applications",
          "code": "// Transforming entities to DTOs in a REST controller\n@GetMapping(\"/users\")\npublic List<UserDTO> getAllUsers() {\n    return userRepository.findAll().stream()\n        .map(this::convertToDto)\n        .collect(Collectors.toList());\n}\n\n// Filtering data based on criteria\npublic List<Product> findProductsByCategory(String category) {\n    return productRepository.findAll().stream()\n        .filter(p -> p.getCategory().equals(category))\n        .collect(Collectors.toList());\n}\n\n// Complex data transformations for reports\npublic Map<String, DoubleSummaryStatistics> getSalesStatsByRegion() {\n    return orderRepository.findAll().stream()\n        .collect(Collectors.groupingBy(\n            order -> order.getCustomer().getRegion(),\n            Collectors.summarizingDouble(Order::getTotal)\n        ));\n}"
        }
      ]
    },
    {
      "id": "immutability",
      "title": "Immutability and Functional Design",
      "description": "Designing with immutability is a cornerstone of functional programming in Java.",
      "subtopics": [
        {
          "id": "immutable-class",
          "title": "Immutable Class Design",
          "code": "// Principles for immutable classes\n// 1. All fields final\n// 2. No setters\n// 3. Don't allow subclassing (final class)\n// 4. Deep copies of mutable fields\n// 5. Defensive copies for mutable field getters\n\npublic final class ImmutablePerson {\n    private final String name;\n    private final int age;\n    private final List<String> skills;  // potentially mutable\n\n    public ImmutablePerson(String name, int age, List<String> skills) {\n        this.name = name;\n        this.age = age;\n        this.skills = new ArrayList<>(skills);  // defensive copy\n    }\n\n    public String getName() { return name; }\n    public int getAge() { return age; }\n    \n    // Return copy to prevent modification\n    public List<String> getSkills() { \n        return new ArrayList<>(skills); \n    }\n    \n    // Provide functional-style modifiers that return new objects\n    public ImmutablePerson withName(String newName) {\n        return new ImmutablePerson(newName, age, skills);\n    }\n    \n    public ImmutablePerson withAge(int newAge) {\n        return new ImmutablePerson(name, newAge, skills);\n    }\n    \n    public ImmutablePerson withSkill(String newSkill) {\n        List<String> newSkills = new ArrayList<>(skills);\n        newSkills.add(newSkill);\n        return new ImmutablePerson(name, age, newSkills);\n    }\n}"
        },
        {
          "id": "persistent-structures",
          "title": "Persistent Data Structures",
          "description": "While Java doesn't provide built-in persistent collections, libraries like Vavr offer immutable collections with functional interfaces.",
          "code": "// Using Vavr (example)\nimport io.vavr.collection.List;\n\nList<Integer> list1 = List.of(1, 2, 3);\nList<Integer> list2 = list1.prepend(0); // list2 = [0, 1, 2, 3], list1 unchanged\n\n// Java 9+ immutable collection factories\nList<String> immutableList = List.of(\"a\", \"b\", \"c\");\nSet<String> immutableSet = Set.of(\"a\", \"b\", \"c\");\nMap<String, Integer> immutableMap = Map.of(\"a\", 1, \"b\", 2);"
        }
      ]
    },
    {
      "id": "monads",
      "title": "Monads and Functional Structures",
      "description": "Java includes several monad-like structures that enable functional composition with effects.",
      "subtopics": [
        {
          "id": "optional",
          "title": "Optional as a Maybe Monad",
          "code": "// Optional for handling nullable values\nOptional<String> optional = Optional.ofNullable(getValue());\n\n// Transformation\nOptional<Integer> length = optional.map(String::length);\n\n// Chaining operations\nString result = optional\n    .map(String::trim)\n    .filter(s -> !s.isEmpty())\n    .map(String::toUpperCase)\n    .orElse(\"DEFAULT\");\n\n// flatMap for operations returning Optional\nOptional<User> user = findUserById(id);\nOptional<Address> address = user.flatMap(User::getAddress);\nOptional<String> zipCode = address.flatMap(Address::getZipCode);\n\n// Combining multiple Optionals\npublic Optional<Order> createOrder(\n        Optional<User> user, \n        Optional<Product> product) {\n    \n    return user.flatMap(u -> \n        product.map(p -> \n            new Order(u, p)));\n}"
        },
        {
          "id": "completable-future",
          "title": "CompletableFuture as a Future Monad",
          "code": "// Creating\nCompletableFuture<String> future = CompletableFuture.supplyAsync(() -> {\n    // Potentially long operation\n    return \"Result\";\n});\n\n// Transforming\nCompletableFuture<Integer> lengthFuture = future.thenApply(String::length);\n\n// Chaining (flatMap equivalent)\nCompletableFuture<Double> result = future\n    .thenCompose(str -> fetchNumberFor(str))\n    .thenApply(num -> num * 2.0);\n\n// Combining multiple futures\nCompletableFuture<Integer> future1 = CompletableFuture.supplyAsync(() -> 10);\nCompletableFuture<Integer> future2 = CompletableFuture.supplyAsync(() -> 20);\n\nCompletableFuture<Integer> combined = future1.thenCombine(future2, Integer::sum);"
        },
        {
          "id": "stream-monad",
          "title": "Stream as a Monad",
          "code": "// Stream can be viewed as a monad that represents a sequence of elements\nStream<String> stream = Stream.of(\"a\", \"b\", \"c\");\n\n// Map operation (functor)\nStream<Integer> lengths = stream.map(String::length);\n\n// FlatMap operation (monadic bind)\nStream<Character> chars = Stream.of(\"abc\", \"def\")\n    .flatMap(s -> s.chars().mapToObj(c -> (char)c));"
        }
      ]
    },
    {
      "id": "design-patterns",
      "title": "Design Patterns in Functional Style",
      "description": "Traditional design patterns can be reimplemented using functional programming techniques.",
      "patterns": [
        {
          "id": "strategy",
          "name": "Strategy Pattern",
          "code": "// Traditional OOP approach\ninterface PaymentStrategy {\n    void pay(int amount);\n}\n\nclass CreditCardStrategy implements PaymentStrategy {\n    public void pay(int amount) {\n        System.out.println(\"Paid \" + amount + \" using Credit Card\");\n    }\n}\n\n// Functional approach using lambdas\n// The functional interface IS the strategy\nConsumer<Integer> creditCardPayment = amount -> \n    System.out.println(\"Paid \" + amount + \" using Credit Card\");\nConsumer<Integer> paypalPayment = amount -> \n    System.out.println(\"Paid \" + amount + \" using PayPal\");\n\n// Usage\nvoid processPayment(int amount, Consumer<Integer> paymentStrategy) {\n    paymentStrategy.accept(amount);\n}"
        },
        {
          "id": "decorator",
          "name": "Decorator Pattern",
          "code": "// Functional decorators using Function composition\nFunction<Coffee, Coffee> withMilk = coffee -> {\n    coffee.ingredients.add(\"Milk\");\n    coffee.cost += 0.5;\n    return coffee;\n};\n\nFunction<Coffee, Coffee> withSugar = coffee -> {\n    coffee.ingredients.add(\"Sugar\");\n    coffee.cost += 0.2;\n    return coffee;\n};\n\n// Combining decorators\nFunction<Coffee, Coffee> sweetMilkyCoffee = withMilk.andThen(withSugar);\nCoffee myCoffee = sweetMilkyCoffee.apply(new Coffee());"
        },
        {
          "id": "command",
          "name": "Command Pattern",
          "code": "// Command as a functional interface\n@FunctionalInterface\ninterface Command {\n    void execute();\n}\n\n// Creating commands with lambdas\nCommand turnOnLight = () -> light.turnOn();\nCommand turnOffLight = () -> light.turnOff();\n\n// Using commands\nvoid executeCommand(Command command) {\n    command.execute();\n}\nexecuteCommand(turnOnLight);\n\n// Command with parameters\n@FunctionalInterface\ninterface ParameterizedCommand<T> {\n    void execute(T param);\n}\nParameterizedCommand<Integer> dimLight = level -> light.dim(level);"
        }
      ]
    },
    {
      "id": "spring-boot",
      "title": "Functional Programming with Spring Boot",
      "description": "Applying functional programming principles in Spring Boot applications.",
      "implementations": [
        {
          "id": "service-layer",
          "title": "Service Layer Implementations",
          "code": "// Traditional imperative approach\n@Service\npublic class UserServiceImperative {\n    @Autowired\n    private UserRepository userRepository;\n    \n    public List<UserDTO> getActiveUsersWithPremiumSubscription() {\n        List<User> allUsers = userRepository.findAll();\n        List<UserDTO> result = new ArrayList<>();\n        \n        for (User user : allUsers) {\n            if (user.isActive() && user.hasPremiumSubscription()) {\n                UserDTO dto = new UserDTO();\n                dto.setId(user.getId());\n                dto.setName(user.getName());\n                dto.setEmail(user.getEmail());\n                result.add(dto);\n            }\n        }\n        \n        return result;\n    }\n}\n\n// Functional approach\n@Service\npublic class UserServiceFunctional {\n    @Autowired\n    private UserRepository userRepository;\n    \n    public List<UserDTO> getActiveUsersWithPremiumSubscription() {\n        return userRepository.findAll().stream()\n            .filter(User::isActive)\n            .filter(User::hasPremiumSubscription)\n            .map(this::convertToDto)\n            .collect(Collectors.toList());\n    }\n    \n    private UserDTO convertToDto(User user) {\n        return new UserDTO(user.getId(), user.getName(), user.getEmail());\n    }\n}"
        },
        {
          "id": "validation",
          "title": "Request Validation and Error Handling",
          "code": "// Functional validation approach using Optional\n@PostMapping(\"/users\")\npublic ResponseEntity<?> createUser(@RequestBody UserRequest request) {\n    return validateUserRequest(request)\n        .map(userService::createUser)\n        .map(user -> ResponseEntity.status(HttpStatus.CREATED).body(user))\n        .orElseGet(() -> ResponseEntity.badRequest().build());\n}\n\nprivate Optional<UserRequest> validateUserRequest(UserRequest request) {\n    return Optional.ofNullable(request)\n        .filter(req -> req.getName() != null && !req.getName().isEmpty())\n        .filter(req -> req.getEmail() != null && req.getEmail().contains(\"@\"));\n}"
        }
      ]
    },
    {
      "id": "testing",
      "title": "Testing Functional Code",
      "description": "Approaches and techniques for testing functional programming constructs.",
      "testTypes": [
        {
          "id": "pure-functions",
          "title": "Testing Pure Functions",
          "code": "// Pure functions are easy to test - same input, same output\n@Test\nvoid testStringToLength() {\n    Function<String, Integer> stringToLength = String::length;\n    \n    assertEquals(3, stringToLength.apply(\"abc\"));\n    assertEquals(0, stringToLength.apply(\"\"));\n    assertEquals(5, stringToLength.apply(\"hello\"));\n}"
        },
        {
          "id": "streams",
          "title": "Testing with Streams",
          "code": "@Test\nvoid testFilterAndMap() {\n    List<String> input = Arrays.asList(\"apple\", \"banana\", \"cherry\");\n    \n    List<String> result = input.stream()\n        .filter(s -> s.startsWith(\"a\"))\n        .map(String::toUpperCase)\n        .collect(Collectors.toList());\n    \n    assertEquals(1, result.size());\n    assertEquals(\"APPLE\", result.get(0));\n}"
        },
        {
          "id": "higher-order",
          "title": "Testing Higher-Order Functions",
          "code": "@Test\nvoid testComposedFunction() {\n    Function<Integer, Integer> times2 = x -> x * 2;\n    Function<Integer, Integer> minus1 = x -> x - 1;\n    \n    // Test composition\n    Function<Integer, Integer> composed = times2.andThen(minus1);\n    \n    assertEquals(3, composed.apply(2));  // (2*2)-1 = 3\n    assertEquals(9, composed.apply(5));  // (5*2)-1 = 9\n}"
        }
      ]
    },
    {
      "id": "interview-questions",
      "title": "Top Interview Questions",
      "description": "Common interview questions about functional programming in Java with comprehensive answers.",
      "questions": [
        {
          "id": "fp-basics",
          "question": "What is functional programming and how does Java support it?",
          "answer": "Functional programming is a paradigm that treats computation as the evaluation of mathematical functions and avoids changing state and mutable data. Java supports functional programming through:\n\n- Functional interfaces (interfaces with a single abstract method)\n- Lambda expressions for implementing these interfaces concisely\n- Method references for referring to existing methods in a functional way\n- The Stream API for functional-style data processing\n- Optional for better null handling\n- CompletableFuture for functional async programming\n\nThese features enable writing more concise, expressive, and potentially more maintainable code by focusing on what to do rather than how to do it."
        },
        {
          "id": "lambda-vs-method-ref",
          "question": "What is the difference between a lambda expression and a method reference?",
          "answer": "Both lambda expressions and method references are ways to implement functional interfaces, but they differ in syntax and use cases:\n\n**Lambda Expressions**:\n\n- Define anonymous functions inline\n- Can contain multiple statements and custom logic\n- More flexible for custom implementations\n- Syntax: `(parameters) -> expression` or `(parameters) -> { statements }`\n\n**Method References**:\n\n- Reference existing methods by name\n- More concise when a lambda would only call one method\n- Limited to calling existing methods as-is\n- Syntax: `ClassName::staticMethod`, `instance::instanceMethod`, or `ClassName::new`\n\nExample:\n\n```java\n// Lambda\nConsumer<String> printer1 = s -> System.out.println(s);\n// Method reference equivalent\nConsumer<String> printer2 = System.out::println;\n```\n\nChoose method references when simply delegating to an existing method; use lambdas when more complex logic is needed."
        },
        {
          "id": "functional-interfaces",
          "question": "What are functional interfaces and how do they relate to lambda expressions?",
          "answer": "A functional interface is an interface with exactly one abstract method. They serve as the target types for lambda expressions and method references.\n\nKey points:\n\n- They can be annotated with `@FunctionalInterface` (optional but recommended)\n- They can contain default and static methods in addition to the single abstract method\n- A lambda expression provides the implementation for the abstract method in the functional interface\n- Common examples include: `Predicate<T>`, `Function<T,R>`, `Consumer<T>`, and `Supplier<T>`\n\nThe relationship between functional interfaces and lambdas is that a lambda expression can be assigned to a variable of a functional interface type if the lambda's parameter and return types are compatible with the interface's abstract method."
        },
        {
          "id": "stream-vs-loops",
          "question": "How does the Stream API differ from loops for collection processing?",
          "answer": "1. **Declarative vs. Imperative**:\n    \n    - Streams are declarative (you specify what to do, not how)\n    - Loops are imperative (you specify the exact steps to follow)\n2. **Lazy Evaluation**:\n    \n    - Streams use lazy evaluation; operations aren't performed until a terminal operation\n    - Loops execute immediately\n3. **Parallelism**:\n    \n    - Streams can easily switch to parallel processing with `parallel()`\n    - Parallelizing loops requires manual thread management\n4. **Immutability**:\n    \n    - Stream operations don't modify the source data\n    - Loops often modify collections in-place\n5. **Pipelining**:\n    \n    - Streams support operation chaining in a fluent API style\n    - Loops often require intermediate variables\n\nExample:\n\n```java\n// Imperative loop\nList<String> longNames = new ArrayList<>();\nfor (String name : names) {\n    if (name.length() > 5) {\n        String upperCase = name.toUpperCase();\n        longNames.add(upperCase);\n    }\n}\n\n// Functional stream equivalent\nList<String> longNames = names.stream()\n    .filter(name -> name.length() > 5)\n    .map(String::toUpperCase)\n    .collect(Collectors.toList());\n```"
        },
        {
          "id": "map-vs-flatmap",
          "question": "What is the difference between map() and flatMap() in the Stream API?",
          "answer": "Both `map()` and `flatMap()` are intermediate operations in the Stream API that transform elements, but they differ in how they handle hierarchical or nested structures:\n\n**map()**:\n\n- Transforms each element into exactly one result element\n- One-to-one transformation\n- The result is a stream with the same number of elements as the original\n- Use when each input produces a single discrete output\n\n**flatMap()**:\n\n- Transforms each element into zero or more elements, then flattens the results\n- One-to-many transformation\n- The result can have a different number of elements than the original\n- Use when dealing with nested collections or when each input produces multiple outputs or another stream\n\nExample:\n\n```java\n// map(): List of lengths\nList<Integer> lengths = words.stream()\n    .map(String::length)\n    .collect(Collectors.toList());\n\n// flatMap(): List of individual characters from all words\nList<Character> allChars = words.stream()\n    .flatMap(word -> word.chars().mapToObj(c -> (char)c))\n    .collect(Collectors.toList());\n\n// flatMap(): Combining multiple lists\nList<List<Integer>> listOfLists = Arrays.asList(\n    Arrays.asList(1, 2), Arrays.asList(3, 4, 5)\n);\nList<Integer> allNumbers = listOfLists.stream()\n    .flatMap(List::stream)\n    .collect(Collectors.toList()); // [1, 2, 3, 4, 5]\n```"
        },
        {
          "id": "exceptions",
          "question": "How can you handle exceptions in lambda expressions?",
          "answer": "Handling exceptions in lambda expressions can be challenging since functional interfaces don't typically declare checked exceptions. Here are several approaches:\n\n1. **Use try-catch inside lambda**:\n\n```java\nlist.forEach(s -> {\n    try {\n        // Code that might throw exception\n        processItem(s);\n    } catch (IOException e) {\n        // Handle exception\n        throw new RuntimeException(e);\n    }\n});\n```\n\n2. **Create a wrapper utility method**:\n\n```java\n@FunctionalInterface\ninterface CheckedFunction<T, R> {\n    R apply(T t) throws Exception;\n}\n\n// Wrapper method\npublic static <T, R> Function<T, R> wrap(CheckedFunction<T, R> function) {\n    return t -> {\n        try {\n            return function.apply(t);\n        } catch (Exception e) {\n            throw new RuntimeException(e);\n        }\n    };\n}\n\n// Usage\nList<URL> urls = strings.stream()\n    .map(wrap(URL::new))\n    .collect(Collectors.toList());\n```\n\n3. **Use specialized libraries** like Vavr or jOOλ which provide exception-handling utilities.\n    \n4. **Refactor to avoid checked exceptions** when possible.\n    \n\nThe most elegant solution often depends on your specific requirements for exception handling and error propagation."
        },
        {
          "id": "pure-functions",
          "question": "What are pure functions and why are they important in functional programming?",
          "answer": "A pure function is a function that:\n\n1. Always produces the same output for the same input (deterministic)\n2. Has no side effects (doesn't modify state outside its scope)\n3. Doesn't depend on external state (relies only on its parameters)\n\nPure functions are important in functional programming for several reasons:\n\n- **Predictability**: They always produce the same result given the same inputs\n- **Testability**: They're easier to test since they don't depend on context or state\n- **Parallelization**: They can safely run in parallel without synchronization concerns\n- **Memoization**: Results can be cached since calling the function again with the same inputs will produce the same result\n- **Reasoning**: Code becomes easier to understand and reason about\n\nExample of a pure function:\n\n```java\n// Pure function\nint add(int a, int b) {\n    return a + b;\n}\n\n// Impure function (has side effect)\nvoid addAndPrint(int a, int b) {\n    System.out.println(a + b);  // Side effect: I/O operation\n}\n\n// Impure function (depends on external state)\nint addToCounter(int a) {\n    return a + counter;  // Depends on external 'counter' variable\n}\n```\n\nIn Java, many Stream API operations encourage a pure functional style, although Java doesn't enforce purity like some functional languages do."
        },
        {
          "id": "optional",
          "question": "How does the Optional class help in functional programming?",
          "answer": "The `Optional<T>` class is a container object that may or may not contain a non-null value. It aligns with functional programming principles by:\n\n1. **Making nullability explicit**: It clearly indicates a value might be absent\n2. **Preventing null pointer exceptions**: Forces explicit handling of possible null conditions\n3. **Supporting functional operations**: Provides map(), flatMap(), and filter() methods for functional composition\n4. **Encouraging immutability**: Optional is immutable and doesn't allow setting a value after creation\n5. **Promoting declarative style**: Allows expressing logic in a declarative rather than imperative style\n\nExample usage:\n\n```java\n// Instead of null checks:\nUser user = getUser(id);\nif (user != null) {\n    Address address = user.getAddress();\n    if (address != null) {\n        ZipCode zipCode = address.getZipCode();\n        if (zipCode != null) {\n            return zipCode.getValue();\n        }\n    }\n}\nreturn \"Unknown\";\n\n// With Optional:\nreturn getUserOptional(id)\n    .flatMap(User::getAddressOptional)\n    .flatMap(Address::getZipCodeOptional)\n    .map(ZipCode::getValue)\n    .orElse(\"Unknown\");\n```\n\nBest practices:\n\n- Use Optional as a return type, not as a parameter type or field type\n- Use Optional.empty() instead of null for Optional variables\n- Prefer orElseGet() over orElse() when the default value is expensive to create\n- Don't use Optional.get() without first checking isPresent()"
        },
        {
          "id": "function-composition",
          "question": "What is function composition and how is it implemented in Java?",
          "answer": "Function composition is a technique from functional programming where two or more functions are combined to form a new function. The output of one function becomes the input to the next function in the chain.\n\nIn Java, function composition is implemented through the `andThen()` and `compose()` methods of the `Function` interface:\n\n- `andThen(Function after)`: Creates a composite function that first applies this function and then applies the after function\n- `compose(Function before)`: Creates a composite function that first applies the before function and then applies this function\n\n```java\nFunction<Integer, Integer> multiplyBy2 = x -> x * 2;\nFunction<Integer, Integer> add3 = x -> x + 3;\n\n// Function composition using andThen\nFunction<Integer, Integer> multiplyBy2ThenAdd3 = multiplyBy2.andThen(add3);\nint result1 = multiplyBy2ThenAdd3.apply(5); // (5 * 2) + 3 = 13\n\n// Function composition using compose\nFunction<Integer, Integer> add3ThenMultiplyBy2 = multiplyBy2.compose(add3);\nint result2 = add3ThenMultiplyBy2.apply(5); // (5 + 3) * 2 = 16\n\n// Complex compositions\nFunction<String, String> pipeline = \n    ((Function<String, String>) String::trim)\n        .andThen(String::toLowerCase)\n        .andThen(s -> s.replaceAll(\"\\\\s+\", \"_\"));\n        \nString result = pipeline.apply(\"  Hello World  \"); // \"hello_world\"\n```\n\nFunction composition enables building complex transformations from simpler, reusable functions, promoting code reuse and modularity."
        },
        {
          "id": "advantages-challenges",
          "question": "What are the advantages and challenges of functional programming in Java?",
          "answer": "**Advantages**:\n\n1. **Readability and Expressiveness**: Concise, declarative code that shows what's being done rather than how\n2. **Reduced Mutable State**: Less state mutation means fewer bugs related to state management\n3. **Easier Concurrency**: Pure functions and immutability simplify parallel processing\n4. **Improved Testability**: Pure functions are easier to test as they depend only on their inputs\n5. **Composition**: Building complex operations from simpler ones increases reusability\n6. **Higher Abstraction Level**: Focus on operations rather than implementation details\n\n**Challenges**:\n\n1. **Learning Curve**: Developers from imperative backgrounds may find functional concepts challenging\n2. **Performance Overhead**: Immutability can sometimes lead to increased object creation\n3. **Debugging**: Stack traces for streams and lambdas can be harder to interpret\n4. **Type Inference Limitations**: Java's type inference isn't as powerful as in some functional languages\n5. **Exception Handling**: Checked exceptions don't work well with functional interfaces\n6. **Integration with Legacy Code**: Mixing functional and imperative styles can be challenging\n7. **Limited Pattern Matching**: Java lacks comprehensive pattern matching (though this is improving in recent versions)\n\nJava's approach to functional programming is pragmatic, offering functional features within an object-oriented language rather than being a pure functional language. This provides flexibility but requires understanding both paradigms for effective use."
        }
      ]
    },
    {
      "id": "advanced-topics",
      "title": "Advanced Topics",
      "description": "Advanced functional programming concepts and techniques in Java.",
      "subtopics": [
        {
          "id": "recursion",
          "title": "Recursion in Functional Programming",
          "code": "// Recursive factorial with pure functions\nFunction<Integer, Integer> factorial = n -> {\n    if (n <= 1) return 1;\n    return n * factorial.apply(n - 1);  // Doesn't work - factorial reference not yet defined\n};\n\n// Solution using Y-combinator pattern or explicit recursion\npublic static Function<Integer, Integer> factorial() {\n    return new Function<Integer, Integer>() {\n        @Override\n        public Integer apply(Integer n) {\n            if (n <= 1) return 1;\n            return n * apply(n - 1);\n        }\n    };\n}\n\n// Tail recursion (not optimized in Java)\npublic static int factorialTailRec(int n, int accumulator) {\n    if (n <= 1) return accumulator;\n    return factorialTailRec(n - 1, n * accumulator);\n}"
        },
        {
          "id": "currying",
          "title": "Currying and Partial Application",
          "code": "// Currying: transforming a function with multiple arguments into a sequence of functions\n// Original function: (X, Y) -> Z\n// Curried form: X -> (Y -> Z)\n\n// Manual currying\nBiFunction<Integer, Integer, Integer> add = (a, b) -> a + b;\nFunction<Integer, Function<Integer, Integer>> curriedAdd = \n    a -> b -> a + b;\n\n// Usage\nint result1 = add.apply(3, 4);  // 7\nint result2 = curriedAdd.apply(3).apply(4);  // 7\n\n// Partial application\nFunction<Integer, Integer> add3 = curriedAdd.apply(3);\nint result3 = add3.apply(4);  // 7\nint result4 = add3.apply(5);  // 8\n\n// Generic currying utility\npublic static <T, U, R> Function<T, Function<U, R>> curry(BiFunction<T, U, R> biFunction) {\n    return t -> u -> biFunction.apply(t, u);\n}\n\n// Usage\nFunction<Integer, Function<Integer, Integer>> curriedAdd2 = curry(add);"
        },
        {
          "id": "data-structures",
          "title": "Functional Data Structures",
          "code": "// Java lacks built-in persistent data structures, but libraries like Vavr provide them\n// Example using Vavr (not built into Java)\n\n// Immutable list\nio.vavr.collection.List<Integer> list1 = io.vavr.collection.List.of(1, 2, 3);\nio.vavr.collection.List<Integer> list2 = list1.prepend(0);\nio.vavr.collection.List<Integer> list3 = list2.append(4);\n\nSystem.out.println(list1);  // [1, 2, 3] - original unchanged\nSystem.out.println(list2);  // [0, 1, 2, 3]\nSystem.out.println(list3);  // [0, 1, 2, 3, 4]\n\n// Java's built-in alternatives (since Java 9)\nList<Integer> immutableList = List.of(1, 2, 3);\n// Following attempts to modify will throw UnsupportedOperationException"
        },
        {
          "id": "memoization",
          "title": "Lazy Evaluation and Memoization",
          "code": "// Lazy evaluation with Supplier\nSupplier<ExpensiveObject> lazySingleton = () -> {\n    System.out.println(\"Creating expensive object...\");\n    return new ExpensiveObject(\"data\");\n};\n\n// Object created only when needed\nExpensiveObject object = lazySingleton.get();\n\n// Simple memoization\npublic static <T, R> Function<T, R> memoize(Function<T, R> function) {\n    Map<T, R> cache = new ConcurrentHashMap<>();\n    return input -> cache.computeIfAbsent(input, function);\n}\n\n// Usage\nFunction<Integer, BigInteger> factorial = memoize(n -> {\n    System.out.println(\"Computing factorial for \" + n);\n    return n <= 1 ? BigInteger.ONE : \n        BigInteger.valueOf(n).multiply(factorial.apply(n - 1));\n});\n\n// First call computes, subsequent calls use cached value\nfactorial.apply(5);  // Computes and caches\nfactorial.apply(5);  // Returns cached value"
        }
      ]
    },
    {
      "id": "learning-resources",
      "title": "Resources for Further Learning",
      "resources": [
        {
          "category": "Books",
          "items": [
            "\"Modern Java in Action\" by Raoul-Gabriel Urma",
            "\"Functional Programming in Java\" by Venkat Subramaniam",
            "\"Java 8 Lambdas\" by Richard Warburton"
          ]
        },
        {
          "category": "Online Resources",
          "items": [
            "Oracle's Java Tutorials on Lambda Expressions",
            "Baeldung's Functional Programming articles",
            "JetBrains Academy Java Functional Programming Track"
          ]
        },
        {
          "category": "Related Topics",
          "items": [
            "Java 8+ Features",
            "Streams API",
            "Lambda Expressions",
            "Design Patterns",
            "Concurrency"
          ]
        }
      ]
    }
  ],
  "relatedTopics": [
    "Java 8+ Features",
    "Stream API",
    "Concurrency",
    "Collections Framework",
    "Design Patterns"
  ],
  "additionalTags": [
    "lambda-expressions",
    "higher-order-functions",
    "immutability",
    "monads",
    "functional-interfaces",
    "streams",
    "optional",
    "completable-future"
  ]
}
