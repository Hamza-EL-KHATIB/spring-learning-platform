{
  "title": "Fonctionnalités Java 8+",
  "tags": ["java", "functional-programming", "streams", "lambda", "backend"],
  "sections": [
    {
      "id": "lambdaExpressions",
      "title": "Expressions Lambda",
      "content": "Les expressions lambda sont des fonctions anonymes qui permettent la programmation fonctionnelle en Java. Elles implémentent les interfaces fonctionnelles de manière concise et éliminent le code redondant.",
      "syntax": "paramètres -> expression",
      "subsections": [
        {
          "title": "Syntaxe",
          "code": [
            {
              "language": "java",
              "snippet": "// Syntaxe de base: (paramètres) -> expression\n(int x, int y) -> x + y\n\n// Avec un seul paramètre (parenthèses optionnelles)\nx -> x * x\n\n// Avec un bloc de code\n(String s) -> {\n    String result = s.toUpperCase();\n    return result;\n}"
            }
          ]
        },
        {
          "title": "Caractéristiques Principales",
          "list": [
            "Alternative concise aux classes anonymes",
            "Pas besoin de déclaration explicite de type (inférence de type)",
            "Peut accéder aux variables effectivement finales de la portée englobante",
            "Ne peut pas accéder aux méthodes par défaut de l'interface fonctionnelle"
          ]
        },
        {
          "title": "Exemples pour Entretien",
          "code": [
            {
              "language": "java",
              "snippet": "// Implémentation de Runnable (Avant Java 8)\nnew Thread(new Runnable() {\n    @Override\n    public void run() {\n        System.out.println(\"Thread running\");\n    }\n}).start();\n\n// Avec Lambda (Java 8+)\nnew Thread(() -> System.out.println(\"Thread running\")).start();\n\n// Comparator pour le tri\nCollections.sort(names, (a, b) -> a.compareToIgnoreCase(b));"
            }
          ]
        },
        {
          "title": "Exemples",
          "examples": [
            {
              "scenario": "Expression Simple",
              "code": "(int x, int y) -> x + y",
              "description": "Additionne deux nombres."
            },
            {
              "scenario": "Paramètre Unique",
              "code": "n -> n * n",
              "description": "Élève un nombre au carré."
            },
            {
              "scenario": "Bloc de Code",
              "code": "(String s) -> { System.out.println(s); }",
              "description": "Affiche une chaîne de caractères en utilisant un bloc de code."
            }
          ]
        }
      ]
    },
    {
      "id": "functionalInterfaces",
      "title": "Interfaces Fonctionnelles",
      "content": "Les interfaces fonctionnelles fournissent la base pour les expressions lambda en définissant une seule méthode abstraite (SAM) que l'expression lambda implémente.",
      "subsections": [
        {
          "title": "Caractéristiques Fondamentales",
          "list": [
            "Contient exactement une méthode abstraite",
            "Peut contenir des méthodes par défaut et statiques",
            "Annotée avec `@FunctionalInterface` (optionnel mais recommandé)"
          ]
        },
        {
          "title": "Interfaces Fonctionnelles Principales",
          "tables": [
            {
              "headers": ["Interface", "Méthode", "Description", "Cas d'Utilisation"],
              "rows": [
                ["`Function<T,R>`", "`R apply(T t)`", "Transforme une entrée en sortie", "Transformation de String en Integer"],
                ["`Predicate<T>`", "`boolean test(T t)`", "Test booléen sur l'entrée", "Filtrage des collections"],
                ["`Consumer<T>`", "`void accept(T t)`", "Consomme l'entrée sans retour", "Affichage des éléments"],
                ["`Supplier<T>`", "`T get()`", "Fournit des valeurs sans entrée", "Génération paresseuse de valeurs"],
                ["`BiFunction<T,U,R>`", "`R apply(T t, U u)`", "Fonction avec deux entrées", "Combinaison de deux valeurs"],
                ["`UnaryOperator<T>`", "`T apply(T t)`", "Fonction spéciale où les types d'entrée et de sortie sont identiques", "Transformation d'une valeur du même type"],
                ["`BinaryOperator<T>`", "`T apply(T t1, T t2)`", "Combine deux arguments du même type", "Opérations mathématiques"]
              ]
            }
          ]
        },
        {
          "title": "Exemples d'Utilisation",
          "code": [
            {
              "language": "java",
              "snippet": "// Predicate pour le filtrage\nPredicate<String> isLongString = s -> s.length() > 10;\nList<String> longStrings = stringList.stream()\n    .filter(isLongString)\n    .collect(Collectors.toList());\n\n// Function pour la transformation\nFunction<String, Integer> stringToLength = String::length;\nList<Integer> lengths = stringList.stream()\n    .map(stringToLength)\n    .collect(Collectors.toList());\n\n// Consumer pour l'itération\nConsumer<String> printer = System.out::println;\nstringList.forEach(printer);\n\n// Supplier pour la génération\nSupplier<Double> randomValue = Math::random;"
            }
          ]
        },
        {
          "title": "Création d'Interfaces Fonctionnelles Personnalisées",
          "code": [
            {
              "language": "java",
              "snippet": "@FunctionalInterface\npublic interface TriFunction<A, B, C, R> {\n    R apply(A a, B b, C c);\n}\n\n// Utilisation\nTriFunction<Integer, Integer, Integer, Integer> sum = (a, b, c) -> a + b + c;"
            }
          ]
        },
        {
          "title": "Interfaces Fonctionnelles et Héritage",
          "code": [
            {
              "language": "java",
              "snippet": "// Une interface fonctionnelle qui étend une autre interface fonctionnelle\n@FunctionalInterface\npublic interface ExtendedPredicate<T> extends Predicate<T> {\n    // Pas de méthodes abstraites supplémentaires - toujours une interface fonctionnelle\n    \n    // Peut ajouter des méthodes par défaut\n    default ExtendedPredicate<T> and(Predicate<? super T> other) {\n        return t -> this.test(t) && other.test(t);\n    }\n}\n\n// N'est plus une interface fonctionnelle (deux méthodes abstraites)\npublic interface NonFunctionalInterface<T> extends Predicate<T> {\n    void additionalMethod();\n}"
            }
          ]
        },
        {
          "title": "Interfaces Fonctionnelles Standard",
          "examples": [
            {
              "name": "Predicate<T>",
              "description": "Représente une fonction qui prend une valeur et renvoie un résultat booléen.",
              "method": "boolean test(T t)"
            },
            {
              "name": "Consumer<T>",
              "description": "Représente une opération qui accepte une entrée unique et n'effectue aucun retour de résultat.",
              "method": "void accept(T t)"
            },
            {
              "name": "Function<T,R>",
              "description": "Représente une fonction qui prend un argument et produit un résultat.",
              "method": "R apply(T t)"
            }
          ],
          "note": "Utilisez l'annotation @FunctionalInterface pour indiquer clairement les interfaces fonctionnelles."
        }
      ]
    },
    {
      "id": "methodReferences",
      "title": "Références de Méthodes",
      "content": "Les références de méthodes fournissent une alternative plus compacte et lisible à certaines expressions lambda, en référençant des méthodes existantes par leur nom.",
      "subsections": [
        {
          "title": "Types de Références de Méthodes",
          "tables": [
            {
              "headers": ["Type", "Syntaxe", "Équivalent Lambda", "Exemple"],
              "rows": [
                ["Méthode Statique", "`NomDeClasse::méthodeStatique`", "`(args) -> NomDeClasse.méthodeStatique(args)`", "`Math::max`"],
                ["Méthode d'Instance d'un Objet Particulier", "`instance::méthodeInstance`", "`(args) -> instance.méthodeInstance(args)`", "`System.out::println`"],
                ["Méthode d'Instance d'un Objet Arbitraire", "`NomDeClasse::méthodeInstance`", "`(obj, args) -> obj.méthodeInstance(args)`", "`String::length`"],
                ["Constructeur", "`NomDeClasse::new`", "`(args) -> new NomDeClasse(args)`", "`ArrayList::new`"]
              ]
            }
          ]
        },
        {
          "title": "Exemples",
          "code": [
            {
              "language": "java",
              "snippet": "// Référence de méthode statique\nFunction<Integer, String> converter = String::valueOf; // Au lieu de: n -> String.valueOf(n)\n\n// Référence de méthode d'instance (objet particulier)\nConsumer<String> printer = System.out::println; // Au lieu de: s -> System.out.println(s)\n\n// Référence de méthode d'instance (objet arbitraire)\nComparator<String> comparator = String::compareToIgnoreCase; // Au lieu de: (s1, s2) -> s1.compareToIgnoreCase(s2)\n\n// Référence de constructeur\nSupplier<List<String>> listSupplier = ArrayList::new; // Au lieu de: () -> new ArrayList<>()"
            }
          ]
        },
        {
          "title": "Exemples Pratiques",
          "examples": [
            {
              "scenario": "Avec Streams",
              "code": "list.stream().forEach(System.out::println)",
              "description": "Affiche chaque élément du stream en utilisant une référence de méthode."
            },
            {
              "scenario": "Avec Comparator",
              "code": "list.sort(String::compareToIgnoreCase)",
              "description": "Trie une liste de chaînes sans tenir compte de la casse en utilisant une référence de méthode."
            }
          ]
        }
      ]
    },
    {
      "id": "streams",
      "title": "API Stream",
      "content": "L'API Stream fournit une façon puissante et flexible de traiter des collections d'objets dans un style fonctionnel, supportant à la fois le traitement séquentiel et parallèle. Elle introduit une approche fonctionnelle et déclarative qui facilite les manipulations complexes de données avec un code concis et lisible.",
      "subsections": [
        {
          "title": "Caractéristiques Clés",
          "list": [
            "Pas une structure de données mais une vue des données",
            "Supporte les opérations de style fonctionnel (filter, map, reduce)",
            "Évaluation paresseuse: les opérations intermédiaires ne s'exécutent que lorsque l'opération terminale est invoquée",
            "\"Usage unique\": ne peut pas être réutilisé après une opération terminale"
          ]
        },
        {
          "title": "Création de Stream",
          "methods": [
            {
              "name": "stream()",
              "description": "Crée un stream séquentiel à partir d'une collection, permettant des opérations agrégées sur ses éléments.",
              "example": "collection.stream()"
            },
            {
              "name": "of()",
              "description": "Crée un stream à partir de valeurs spécifiées, utile pour construire rapidement un stream à partir d'éléments connus.",
              "example": "Stream.of(1, 2, 3, 4, 5)"
            },
            {
              "name": "generate()",
              "description": "Crée un stream infini en utilisant un Supplier, souvent utilisé pour générer des valeurs aléatoires ou des motifs répétés.",
              "example": "Stream.generate(Math::random)"
            },
            {
              "name": "iterate()",
              "description": "Crée un stream infini en appliquant itérativement une fonction à partir d'une valeur initiale, utile pour les séquences.",
              "example": "Stream.iterate(0, n -> n + 2)"
            },
            {
              "name": "Arrays.stream()",
              "description": "Convertit un tableau en stream, permettant des opérations sur les éléments du tableau.",
              "example": "Arrays.stream(new int[]{1, 2, 3})"
            }
          ],
          "code": [
            {
              "language": "java",
              "snippet": "// À partir d'une Collection\nList<String> list = Arrays.asList(\"a\", \"b\", \"c\");\nStream<String> stream = list.stream();\n\n// Création directe\nStream<Integer> stream = Stream.of(1, 2, 3, 4, 5);\n\n// À partir d'un tableau\nString[] array = {\"a\", \"b\", \"c\"};\nStream<String> stream = Arrays.stream(array);\n\n// Streams infinis\nStream<Double> randoms = Stream.generate(Math::random);\nStream<Integer> evenNumbers = Stream.iterate(0, n -> n + 2);"
            }
          ]
        },
        {
          "title": "Opérations Intermédiaires",
          "methods": [
            {
              "name": "filter()",
              "description": "Ne conserve que les éléments qui satisfont un prédicat donné.",
              "example": "list.stream().filter(n -> n > 10)"
            },
            {
              "name": "map()",
              "description": "Transforme chaque élément du stream en utilisant la fonction fournie.",
              "example": "list.stream().map(String::toUpperCase)"
            },
            {
              "name": "flatMap()",
              "description": "Convertit chaque élément en stream puis aplatit les streams résultants en un seul stream contigu.",
              "example": "list.stream().flatMap(List::stream)"
            },
            {
              "name": "sorted()",
              "description": "Trie les éléments du stream dans l'ordre naturel ou selon un comparateur personnalisé.",
              "example": "stream.sorted()"
            },
            {
              "name": "distinct()",
              "description": "Élimine les éléments dupliqués du stream.",
              "example": "stream.distinct()"
            },
            {
              "name": "limit()",
              "description": "Restreint le stream à contenir au maximum le nombre spécifié d'éléments.",
              "example": "stream.limit(5)"
            },
            {
              "name": "skip()",
              "description": "Ignore les n premiers éléments du stream, renvoyant un stream qui commence après ces éléments.",
              "example": "stream.skip(3)"
            },
            {
              "name": "peek()",
              "description": "Exécute l'action fournie sur chaque élément consommé, souvent utilisé pour le débogage.",
              "example": "stream.peek(System.out::println)"
            }
          ],
          "tables": [
            {
              "headers": ["Opération", "Description", "Exemple"],
              "rows": [
                ["`filter()`", "Filtre les éléments basés sur un prédicat", "`stream.filter(n -> n > 10)`"],
                ["`map()`", "Transforme les éléments en utilisant une fonction", "`stream.map(String::toUpperCase)`"],
                ["`flatMap()`", "Transforme et aplatit les streams imbriqués", "`stream.flatMap(Collection::stream)`"],
                ["`distinct()`", "Supprime les doublons", "`stream.distinct()`"],
                ["`sorted()`", "Trie les éléments", "`stream.sorted(Comparator.naturalOrder())`"],
                ["`peek()`", "Effectue une action sur les éléments (débogage)", "`stream.peek(System.out::println)`"],
                ["`limit()`", "Limite le stream à une taille", "`stream.limit(10)`"],
                ["`skip()`", "Ignore les n premiers éléments", "`stream.skip(5)`"]
              ]
            }
          ]
        },
        {
          "title": "Opérations Terminales",
          "methods": [
            {
              "name": "collect()",
              "description": "Accumule les éléments du stream dans une collection ou un résultat résumé en utilisant un Collector.",
              "example": "stream.collect(Collectors.toList())"
            },
            {
              "name": "reduce()",
              "description": "Réduit les éléments du stream à une seule valeur en utilisant une fonction d'accumulation.",
              "example": "stream.reduce(0, Integer::sum)"
            },
            {
              "name": "forEach()",
              "description": "Effectue une action sur chaque élément du stream.",
              "example": "stream.forEach(System.out::println)"
            },
            {
              "name": "forEachOrdered()",
              "description": "Effectue une action sur chaque élément du stream tout en préservant l'ordre de rencontre.",
              "example": "stream.forEachOrdered(System.out::println)"
            },
            {
              "name": "toArray()",
              "description": "Convertit le stream en tableau contenant tous ses éléments.",
              "example": "Object[] array = stream.toArray()"
            },
            {
              "name": "count()",
              "description": "Renvoie le nombre total d'éléments dans le stream.",
              "example": "long count = stream.count()"
            },
            {
              "name": "anyMatch()",
              "description": "Renvoie true si un élément du stream satisfait le prédicat donné.",
              "example": "stream.anyMatch(n -> n > 10)"
            },
            {
              "name": "allMatch()",
              "description": "Renvoie true si tous les éléments du stream satisfont le prédicat donné.",
              "example": "stream.allMatch(n -> n > 0)"
            },
            {
              "name": "noneMatch()",
              "description": "Renvoie true si aucun élément du stream ne satisfait le prédicat donné.",
              "example": "stream.noneMatch(n -> n < 0)"
            },
            {
              "name": "findFirst()",
              "description": "Récupère le premier élément du stream, s'il est présent, emballé dans un Optional.",
              "example": "Optional<T> first = stream.findFirst()"
            },
            {
              "name": "findAny()",
              "description": "Récupère n'importe quel élément du stream, particulièrement utile dans les streams parallèles, emballé dans un Optional.",
              "example": "Optional<T> any = stream.findAny()"
            },
            {
              "name": "max()",
              "description": "Trouve l'élément maximum dans le stream selon un comparateur fourni.",
              "example": "stream.max(Comparator.naturalOrder())"
            },
            {
              "name": "min()",
              "description": "Trouve l'élément minimum dans le stream selon un comparateur fourni.",
              "example": "stream.min(Comparator.naturalOrder())"
            },
            {
              "name": "summaryStatistics()",
              "description": "Génère des statistiques récapitulatives (count, sum, min, average, max) pour les streams numériques.",
              "example": "IntSummaryStatistics stats = intStream.summaryStatistics()"
            }
          ],
          "tables": [
            {
              "headers": ["Opération", "Description", "Exemple"],
              "rows": [
                ["`forEach()`", "Effectue une action sur chaque élément", "`stream.forEach(System.out::println)`"],
                ["`collect()`", "Collecte les éléments dans un conteneur", "`stream.collect(Collectors.toList())`"],
                ["`reduce()`", "Réduit les éléments à une seule valeur", "`stream.reduce(0, Integer::sum)`"],
                ["`count()`", "Compte les éléments", "`stream.count()`"],
                ["`anyMatch()`", "Renvoie true si un élément correspond", "`stream.anyMatch(s -> s.length() > 5)`"],
                ["`allMatch()`", "Renvoie true si tous les éléments correspondent", "`stream.allMatch(n -> n > 0)`"],
                ["`noneMatch()`", "Renvoie true si aucun élément ne correspond", "`stream.noneMatch(n -> n < 0)`"],
                ["`findFirst()`", "Renvoie le premier élément (Optional)", "`stream.findFirst()`"],
                ["`findAny()`", "Renvoie n'importe quel élément (Optional)", "`stream.findAny()`"],
                ["`min()`", "Renvoie l'élément minimum", "`stream.min(Comparator.naturalOrder())`"],
                ["`max()`", "Renvoie l'élément maximum", "`stream.max(Comparator.naturalOrder())`"],
                ["`toArray()`", "Convertit en tableau", "`stream.toArray()`"]
              ]
            }
          ]
        },
        {
          "title": "Streams Spécialisés",
          "content": "**IntStream**, **LongStream**, **DoubleStream**: Spécialisations primitives\n- Plus efficaces que les streams d'objets pour les opérations numériques\n- Fournissent des opérations spécialisées comme `sum()`, `average()`, `range()`",
          "methods": [
            {
              "name": "IntStream",
              "description": "Un stream spécialisé pour les valeurs primitives int, conçu pour éviter la surcharge de boxing.",
              "example": "IntStream.range(1, 10).sum()"
            },
            {
              "name": "LongStream",
              "description": "Un stream spécialisé pour les valeurs primitives long, offrant des opérations numériques efficaces.",
              "example": "LongStream.of(1L, 2L, 3L)"
            },
            {
              "name": "DoubleStream",
              "description": "Un stream spécialisé pour les valeurs primitives double, optimisé pour l'arithmétique à virgule flottante.",
              "example": "DoubleStream.generate(Math::random).limit(5)"
            },
            {
              "name": "Méthodes de Support Stream",
              "description": "Méthodes pour convertir entre streams d'objets et streams primitifs, facilitant les opérations comme le mapping.",
              "example": "stream.mapToInt(String::length)"
            }
          ],
          "code": [
            {
              "language": "java",
              "snippet": "// Exemple IntStream\nIntStream.range(1, 11)      // Crée 1 à 10\n    .filter(n -> n % 2 == 0) // Garde les nombres pairs\n    .sum();                 // Les additionne"
            }
          ]
        },
        {
          "title": "Collectors",
          "content": "Les collectors sont des opérations terminales versatiles qui rassemblent les éléments d'un stream dans des collections ou effectuent des réductions.",
          "methods": [
            {
              "name": "toList()",
              "description": "Collecte les éléments du stream dans une List.",
              "example": "stream.collect(Collectors.toList())"
            },
            {
              "name": "toSet()",
              "description": "Collecte les éléments du stream dans un Set, supprimant automatiquement les doublons.",
              "example": "stream.collect(Collectors.toSet())"
            },
            {
              "name": "toCollection()",
              "description": "Collecte les éléments dans un type spécifique de collection fourni par un Supplier.",
              "example": "stream.collect(Collectors.toCollection(LinkedList::new))"
            },
            {
              "name": "toMap()",
              "description": "Transforme le stream en Map en appliquant des fonctions de mapping de clé et de valeur.",
              "example": "stream.collect(Collectors.toMap(keyMapper, valueMapper))"
            },
            {
              "name": "toConcurrentMap()",
              "description": "Transforme le stream en ConcurrentMap thread-safe en utilisant des fonctions de mapping de clé et de valeur.",
              "example": "stream.collect(Collectors.toConcurrentMap(keyMapper, valueMapper))"
            },
            {
              "name": "joining()",
              "description": "Concatène les éléments du stream en une seule chaîne String avec un délimiteur optionnel.",
              "example": "stream.collect(Collectors.joining(\", \"))"
            },
            {
              "name": "counting()",
              "description": "Compte le nombre d'éléments dans le stream.",
              "example": "stream.collect(Collectors.counting())"
            },
            {
              "name": "summingInt()",
              "description": "Calcule la somme des valeurs entières dans le stream.",
              "example": "stream.collect(Collectors.summingInt(Integer::intValue))"
            },
            {
              "name": "summingLong()",
              "description": "Calcule la somme des valeurs long dans le stream.",
              "example": "stream.collect(Collectors.summingLong(Long::longValue))"
            },
            {
              "name": "summingDouble()",
              "description": "Calcule la somme des valeurs double dans le stream.",
              "example": "stream.collect(Collectors.summingDouble(Double::doubleValue))"
            },
            {
              "name": "averagingInt()",
              "description": "Calcule la moyenne des valeurs entières dans le stream.",
              "example": "stream.collect(Collectors.averagingInt(Integer::intValue))"
            },
            {
              "name": "averagingLong()",
              "description": "Calcule la moyenne des valeurs long dans le stream.",
              "example": "stream.collect(Collectors.averagingLong(Long::longValue))"
            },
            {
              "name": "averagingDouble()",
              "description": "Calcule la moyenne des valeurs double dans le stream.",
              "example": "stream.collect(Collectors.averagingDouble(Double::doubleValue))"
            },
            {
              "name": "summarizingInt()",
              "description": "Produit des statistiques récapitulatives pour les valeurs entières dans le stream.",
              "example": "stream.collect(Collectors.summarizingInt(Integer::intValue))"
            },
            {
              "name": "summarizingLong()",
              "description": "Produit des statistiques récapitulatives pour les valeurs long dans le stream.",
              "example": "stream.collect(Collectors.summarizingLong(Long::longValue))"
            },
            {
              "name": "summarizingDouble()",
              "description": "Produit des statistiques récapitulatives pour les valeurs double dans le stream.",
              "example": "stream.collect(Collectors.summarizingDouble(Double::doubleValue))"
            },
            {
              "name": "maxBy()",
              "description": "Trouve l'élément maximum dans le stream en utilisant un comparateur fourni.",
              "example": "stream.collect(Collectors.maxBy(Comparator.naturalOrder()))"
            },
            {
              "name": "minBy()",
              "description": "Trouve l'élément minimum dans le stream en utilisant un comparateur fourni.",
              "example": "stream.collect(Collectors.minBy(Comparator.naturalOrder()))"
            },
            {
              "name": "reducing()",
              "description": "Réduit les éléments du stream à une seule valeur en utilisant un opérateur binaire associatif.",
              "example": "stream.collect(Collectors.reducing(0, Integer::intValue, Integer::sum))"
            },
            {
              "name": "collectingAndThen()",
              "description": "Effectue une transformation finale sur le résultat produit par un Collector.",
              "example": "stream.collect(Collectors.collectingAndThen(Collectors.toList(), Collections::unmodifiableList))"
            },
            {
              "name": "groupingBy()",
              "description": "Groupe les éléments du stream selon une fonction de classification dans une Map.",
              "example": "stream.collect(Collectors.groupingBy(String::length))"
            },
            {
              "name": "groupingByConcurrent()",
              "description": "Une version concurrente de groupingBy qui renvoie une ConcurrentMap thread-safe.",
              "example": "stream.collect(Collectors.groupingByConcurrent(String::length))"
            },
            {
              "name": "partitioningBy()",
              "description": "Partitionne les éléments du stream en deux groupes basés sur un prédicat, renvoyant une Map avec des clés booléennes.",
              "example": "stream.collect(Collectors.partitioningBy(n -> n > 10))"
            },
            {
              "name": "mapping()",
              "description": "Applique une fonction de mapping aux éléments avant de les collecter dans une collection.",
              "example": "stream.collect(Collectors.mapping(String::toUpperCase, Collectors.toList()))"
            }
          ],
          "code": [
            {
              "language": "java",
              "snippet": "// Opérations de collection de base\nList<String> list = stream.collect(Collectors.toList());\nSet<String> set = stream.collect(Collectors.toSet());\nString joined = stream.collect(Collectors.joining(\", \"));\n\n// Groupement et partitionnement\nMap<Department, List<Employee>> byDept = employees.stream()\n    .collect(Collectors.groupingBy(Employee::getDepartment));\n\nMap<Boolean, List<Employee>> seniorJunior = employees.stream()\n    .collect(Collectors.partitioningBy(e -> e.getYears() > 5));\n\n// Agrégation\nDouble avgSalary = employees.stream()\n    .collect(Collectors.averagingDouble(Employee::getSalary));\n\n// Collection personnalisée\nTreeSet<String> treeSet = stream.collect(\n    Collectors.toCollection(TreeSet::new));"
            }
          ]
        },
        {
          "title": "Streams Parallèles",
          "methods": [
            {
              "name": "parallel()",
              "description": "Convertit un stream séquentiel en stream parallèle pour exploiter le traitement multi-cœur et améliorer les performances.",
              "example": "stream.parallel().forEach(System.out::println)"
            },
            {
              "name": "sequential()",
              "description": "Convertit un stream parallèle en stream séquentiel pour préserver l'ordre des éléments.",
              "example": "stream.parallel().sequential()"
            },
            {
              "name": "parallelStream()",
              "description": "Crée un stream parallèle directement à partir d'une collection, permettant un traitement concurrent.",
              "example": "collection.parallelStream()"
            }
          ],
          "code": [
            {
              "language": "java",
              "snippet": "// Création d'un stream parallèle\nlist.parallelStream();\n// ou\nstream.parallel();\n\n// Exemple de traitement parallèle\nlong count = bigList.parallelStream()\n    .filter(this::complexFilter)\n    .count();"
            }
          ],
          "subsections": [
            {
              "title": "Considérations pour les Streams Parallèles",
              "content": "- Meilleur pour les opérations intensives en calcul\n- La performance dépend de la taille des données, des opérations et du matériel\n- Attention à la sécurité des threads lors de l'utilisation d'état partagé\n- Le nombre de threads par défaut est égal aux processeurs disponibles",
              "code": [
                {
                  "language": "java",
                  "snippet": "// Considérations de performance pour les streams parallèles\n// Quand utiliser (et quand ne pas utiliser) les streams parallèles\nlist.parallelStream()\n    .filter(item -> complexOperation(item)) // Tâche intensive en CPU\n    .collect(Collectors.toList());\n\n// Piège courant - opérations avec état partagé\n// Cela peut conduire à des conditions de course\nAtomicInteger counter = new AtomicInteger(0);\nlist.parallelStream()\n    .forEach(item -> counter.incrementAndGet()); // Éviter ce modèle\n\n// Meilleure approche pour le comptage\nlong count = list.parallelStream().count();\n\n// Meilleure approche pour la réduction mutable\n// Utiliser des collectors qui combinent correctement les résultats\nMap<String, Long> wordCounts = text.parallelStream()\n    .flatMap(line -> Arrays.stream(line.split(\"\\\\s+\")))\n    .collect(Collectors.groupingByConcurrent(\n        String::toLowerCase, Collectors.counting()));"
                }
              ]
            }
          ]
        },
        {
          "title": "Exemples de Streams",
          "methods": [
            {
              "name": "Traitement d'une Liste de Noms",
              "description": "Filtre une liste de noms pour n'inclure que ceux commençant par 'A', les convertit en majuscules et collecte les résultats dans une nouvelle liste.",
              "example": "names.stream().filter(n -> n.startsWith(\"A\")).map(String::toUpperCase).collect(Collectors.toList())"
            },
            {
              "name": "Calcul du Montant Total des Commandes",
              "description": "Additionne les montants totaux d'une liste de commandes, fournissant une seule valeur agrégée.",
              "example": "orders.stream().mapToDouble(Order::getAmount).sum()"
            },
            {
              "name": "Regroupement des Employés par Département",
              "description": "Organise les employés en groupes basés sur leur département en utilisant le collector groupingBy.",
              "example": "employees.stream().collect(Collectors.groupingBy(Employee::getDepartment))"
            },
            {
              "name": "Traitement de Stream Parallèle",
              "description": "Traite un grand ensemble de données en parallèle pour améliorer les performances en exploitant plusieurs cœurs.",
              "example": "largeDataSet.parallelStream().filter(...).collect(...)"
            }
          ]
        }
      ]
    },
    {
      "id": "optional",
      "title": "Optional",
      "content": "Optional est un objet conteneur qui peut ou non contenir une valeur non-null, aidant à éviter les vérifications explicites de null et les NullPointerExceptions.",
      "subsections": [
        {
          "title": "Méthodes Clés",
          "methods": [
            {
              "name": "of()",
              "description": "Crée un Optional contenant une valeur non-null.",
              "example": "Optional.of(value)"
            },
            {
              "name": "empty()",
              "description": "Crée une instance Optional vide.",
              "example": "Optional.empty()"
            },
            {
              "name": "ofNullable()",
              "description": "Crée un Optional qui contient la valeur donnée, ou est vide si la valeur est null.",
              "example": "Optional.ofNullable(value)"
            },
            {
              "name": "get()",
              "description": "Récupère la valeur si présente; lance NoSuchElementException si l'Optional est vide.",
              "example": "optional.get()"
            },
            {
              "name": "isPresent()",
              "description": "Vérifie si l'Optional contient une valeur.",
              "example": "optional.isPresent()"
            },
            {
              "name": "ifPresent()",
              "description": "Exécute l'action donnée si une valeur est présente dans l'Optional.",
              "example": "optional.ifPresent(value -> System.out.println(value))"
            }
          ],
          "tables": [
            {
              "headers": ["Méthode", "Description", "Exemple"],
              "rows": [
                ["`of(T value)`", "Crée Optional avec une valeur non-null", "`Optional.of(\"value\")`"],
                ["`ofNullable(T value)`", "Crée Optional qui peut être vide", "`Optional.ofNullable(getValue())`"],
                ["`empty()`", "Crée Optional vide", "`Optional.empty()`"],
                ["`isPresent()`", "Vérifie si la valeur est présente", "`optional.isPresent()`"],
                ["`ifPresent(Consumer)`", "Exécute une action si présente", "`optional.ifPresent(System.out::println)`"],
                ["`get()`", "Renvoie la valeur si présente ou lance une exception", "`optional.get()`"],
                ["`orElse(T)`", "Renvoie la valeur ou une valeur par défaut fournie", "`optional.orElse(\"default\")`"],
                ["`orElseGet(Supplier)`", "Renvoie la valeur ou une valeur par défaut calculée", "`optional.orElseGet(() -> computeDefault())`"],
                ["`orElseThrow(Supplier)`", "Renvoie la valeur ou lance une exception", "`optional.orElseThrow(NoSuchElementException::new)`"],
                ["`map(Function)`", "Transforme la valeur si présente", "`optional.map(String::toUpperCase)`"],
                ["`flatMap(Function)`", "Transforme et aplatit", "`optional.flatMap(this::findRelated)`"],
                ["`filter(Predicate)`", "Applique un filtre à la valeur", "`optional.filter(s -> s.length() > 3)`"]
              ]
            }
          ]
        },
        {
          "title": "Bonnes Pratiques",
          "code": [
            {
              "language": "java",
              "snippet": "// Bon: Utilisation des API Optional\nreturn userRepository.findById(id)\n    .map(User::getAddress)\n    .map(Address::getZipCode)\n    .orElse(\"Unknown\");\n\n// Mauvais: Utilisation d'Optional comme paramètre de méthode\npublic void process(Optional<User> userOpt) { /* ... */ }\n\n// Bon: Retourner Optional depuis des méthodes qui peuvent ne pas renvoyer de valeur\npublic Optional<User> findUser(String id) {\n    // ...\n    return Optional.ofNullable(user);\n}"
            }
          ]
        },
        {
          "title": "Améliorations Java 9+",
          "code": [
            {
              "language": "java",
              "snippet": "// Java 9\noptional.ifPresentOrElse(\n    value -> System.out.println(\"Trouvé: \" + value),\n    () -> System.out.println(\"Non trouvé\")\n);\n\n// Java 9\nOptional<String> result = optional.or(() -> Optional.of(\"default\"));\n\n// Java 10\nStream<String> stream = optional.stream(); // Renvoie un stream vide ou singleton"
            }
          ]
        }
      ]
    },
    {
      "id": "defaultMethods",
      "title": "Méthodes par Défaut",
      "content": "Les méthodes par défaut permettent aux interfaces d'avoir des implémentations de méthodes, permettant l'évolution des interfaces sans casser les implémentations existantes.",
      "subsections": [
        {
          "title": "Caractéristiques",
          "content": "- Définies avec le mot-clé `default` dans les interfaces\n- Toutes les classes d'implémentation héritent de l'implémentation par défaut\n- Peuvent être redéfinies par les classes d'implémentation\n- Permettent la compatibilité ascendante lors de l'ajout de méthodes aux interfaces",
          "code": [
            {
              "language": "java",
              "snippet": "public interface Collection<E> {\n    // Méthodes abstraites existantes\n    \n    // Méthode par défaut ajoutée dans Java 8\n    default Stream<E> stream() {\n        // Implémentation\n    }\n}"
            }
          ]
        },
        {
          "title": "Règles de Résolution d'Héritage Multiple",
          "content": "Lorsqu'une classe implémente plusieurs interfaces avec la même méthode par défaut:\n\n1. Les méthodes de classe ont priorité sur les méthodes par défaut d'interface\n2. Les méthodes d'interface plus spécifiques ont priorité sur les moins spécifiques\n3. Si ambigu, la classe doit explicitement redéfinir la méthode",
          "code": [
            {
              "language": "java",
              "snippet": "interface A {\n    default void hello() {\n        System.out.println(\"Hello from A\");\n    }\n}\n\ninterface B extends A {\n    @Override\n    default void hello() {\n        System.out.println(\"Hello from B\");\n    }\n}\n\nclass C implements A, B {\n    // La méthode hello() de B a priorité car B est plus spécifique que A\n}\n\nclass D implements A, B {\n    // Redéfinir explicitement pour résoudre l'ambiguïté\n    @Override\n    public void hello() {\n        B.super.hello(); // Appelle l'implémentation de B\n    }\n}"
            }
          ]
        },
        {
          "title": "Exemples",
          "examples": [
            {
              "title": "Méthode par Défaut Simple",
              "code": "interface Vehicle { default void start() { System.out.println(\"Starting vehicle\"); } }",
              "description": "Fournit une implémentation par défaut standard pour une méthode d'interface."
            },
            {
              "title": "Méthodes par Défaut Multiples",
              "code": "interface Collection { default Stream<E> stream() { ... } default Stream<E> parallelStream() { ... } }",
              "description": "Montre comment une interface peut inclure plusieurs méthodes par défaut."
            }
          ]
        }
      ]
    },
    {
      "id": "completableFuture",
      "title": "CompletableFuture",
      "content": "CompletableFuture étend Future pour supporter la programmation asynchrone avec une approche plus fonctionnelle et une meilleure composition.",
      "description": "CompletableFuture est une amélioration de Future qui supporte la programmation asynchrone, fournissant une approche plus flexible et fonctionnelle pour gérer les opérations concurrentes.",
      "subsections": [
        {
          "title": "Caractéristiques Clés",
          "list": [
            "Supporte la composition d'opérations asynchrones",
            "Fournit des mécanismes de callback",
            "Permet la gestion des exceptions pour le code asynchrone",
            "Peut combiner plusieurs opérations asynchrones"
          ]
        },
        {
          "title": "Méthodes de Création",
          "methods": [
            {
              "name": "supplyAsync()",
              "description": "Crée un CompletableFuture qui fournit de manière asynchrone un résultat en utilisant un Supplier.",
              "example": "CompletableFuture.supplyAsync(() -> fetchData())"
            },
            {
              "name": "runAsync()",
              "description": "Crée un CompletableFuture qui exécute une tâche Runnable de manière asynchrone sans renvoyer de résultat.",
              "example": "CompletableFuture.runAsync(() -> process())"
            }
          ],
          "code": [
            {
              "language": "java",
              "snippet": "// Fournir une valeur de manière asynchrone\nCompletableFuture<String> future1 = CompletableFuture.supplyAsync(() -> {\n    // Calcul long\n    return \"Résultat\";\n});\n\n// Exécuter une tâche de manière asynchrone (pas de résultat)\nCompletableFuture<Void> future2 = CompletableFuture.runAsync(() -> {\n    // Tâche en arrière-plan\n});\n\n// Créer un future complété\nCompletableFuture<String> future3 = CompletableFuture.completedFuture(\"Terminé\");"
            }
          ]
        },
        {
          "title": "Transformation et Composition",
          "methods": [
            {
              "name": "thenApply()",
              "description": "Transforme le résultat d'un CompletableFuture en utilisant une fonction, renvoyant un nouveau CompletableFuture avec le résultat transformé.",
              "example": "future.thenApply(result -> result.toUpperCase())"
            },
            {
              "name": "thenCompose()",
              "description": "Enchaîne plusieurs opérations asynchrones en utilisant le résultat d'un future pour en démarrer un autre.",
              "example": "future.thenCompose(result -> fetchMore(result))"
            },
            {
              "name": "thenCombine()",
              "description": "Combine les résultats de deux CompletableFuture indépendants en utilisant une fonction spécifiée.",
              "example": "future1.thenCombine(future2, (r1, r2) -> r1 + r2)"
            }
          ],
          "code": [
            {
              "language": "java",
              "snippet": "CompletableFuture<String> result = CompletableFuture.supplyAsync(() -> \"Hello\")\n    // Transformer le résultat\n    .thenApply(s -> s + \" World\")\n    \n    // Effectuer une action avec le résultat (renvoie CompletableFuture<Void>)\n    .thenAccept(System.out::println)\n    \n    // Chaîner avec un autre CompletableFuture\n    .thenCompose(ignored -> CompletableFuture.supplyAsync(() -> \"Étape suivante\"))\n    \n    // Combiner avec un autre CompletableFuture indépendant\n    .thenCombine(otherFuture, (result1, result2) -> result1 + \" & \" + result2);"
            }
          ]
        },
        {
          "title": "Gestion des Erreurs",
          "methods": [
            {
              "name": "exceptionally()",
              "description": "Gère les exceptions en fournissant un résultat alternatif si une erreur se produit pendant l'opération asynchrone.",
              "example": "future.exceptionally(ex -> handleError(ex))"
            },
            {
              "name": "handle()",
              "description": "Traite à la fois les résultats réussis et les exceptions, vous permettant de renvoyer une valeur basée sur l'un ou l'autre résultat.",
              "example": "future.handle((result, ex) -> ex != null ? handleError(ex) : result)"
            }
          ],
          "code": [
            {
              "language": "java",
              "snippet": "CompletableFuture<String> future = CompletableFuture.supplyAsync(() -> {\n    if (Math.random() < 0.5) throw new RuntimeException(\"Échec\");\n    return \"Succès\";\n})\n// Gérer l'exception et fournir une alternative\n.exceptionally(ex -> {\n    System.err.println(\"Erreur survenue: \" + ex.getMessage());\n    return \"Fallback\";\n})\n// Gérer à la fois les cas de succès et d'échec\n.handle((result, ex) -> {\n    if (ex != null) {\n        return \"Récupéré de: \" + ex.getMessage();\n    }\n    return \"Résultat obtenu: \" + result;\n});"
            }
          ]
        },
        {
          "title": "Combinaison de Multiples Futures",
          "code": [
            {
              "language": "java",
              "snippet": "// Exécuter après que les deux soient terminés (résultats ignorés)\nCompletableFuture<Void> combined1 = \n    CompletableFuture.allOf(future1, future2, future3);\n\n// Exécuter après que l'un d'eux se termine (obtenir le premier résultat)\nCompletableFuture<Object> combined2 = \n    CompletableFuture.anyOf(future1, future2, future3);\n\n// Attendre que tous les futures se terminent et collecter les résultats\nList<CompletableFuture<String>> futures = Arrays.asList(future1, future2, future3);\nCompletableFuture<List<String>> allResults = CompletableFuture.allOf(futures.toArray(new CompletableFuture[0]))\n    .thenApply(v -> futures.stream()\n        .map(CompletableFuture::join)\n        .collect(Collectors.toList()));"
            }
          ]
        }
      ]
    },
    {
      "id": "dateTime",
      "title": "API Date/Time (java.time)",
      "content": "Java 8 a introduit une API complète, immuable et thread-safe pour les opérations de date et d'heure, répondant aux limitations des classes date héritées.",
      "description": "Classes modernes et complètes pour gérer les dates et les heures en Java. Ces classes offrent une clarté, une flexibilité et une précision améliorées par rapport aux anciennes API date/time.",
      "subsections": [
        {
          "title": "Classes Principales",
          "classes": [
            {
              "name": "LocalDate",
              "description": "Représente une date sans heure ni fuseau horaire, idéale pour représenter des dates de calendrier.",
              "examples": [
                {
                  "operation": "Création",
                  "code": "LocalDate.now()"
                },
                {
                  "operation": "Analyse",
                  "code": "LocalDate.parse(\"2024-01-01\")"
                },
                {
                  "operation": "Manipulation",
                  "code": "date.plusDays(1).minusMonths(1)"
                }
              ]
            },
            {
              "name": "LocalTime",
              "description": "Représente une heure sans date ni fuseau horaire, utile pour spécifier des heures de la journée.",
              "examples": [
                {
                  "operation": "Création",
                  "code": "LocalTime.of(13, 30)"
                },
                {
                  "operation": "Analyse",
                  "code": "LocalTime.parse(\"13:30:00\")"
                }
              ]
            },
            {
              "name": "LocalDateTime",
              "description": "Combine la date et l'heure sans information de fuseau horaire, fournissant une représentation complète date-heure.",
              "examples": [
                {
                  "operation": "Création",
                  "code": "LocalDateTime.now()"
                },
                {
                  "operation": "Formatage",
                  "code": "dateTime.format(DateTimeFormatter.ISO_LOCAL_DATE_TIME)"
                }
              ]
            },
            {
              "name": "ZonedDateTime",
              "description": "Représente la date et l'heure avec des informations de fuseau horaire, permettant des conversions entre différents fuseaux horaires.",
              "examples": [
                {
                  "operation": "Création",
                  "code": "ZonedDateTime.now(ZoneId.of(\"Europe/Paris\"))"
                },
                {
                  "operation": "Conversion",
                  "code": "zonedDateTime.withZoneSameInstant(ZoneId.of(\"America/New_York\"))"
                }
              ]
            }
          ],
          "tables": [
            {
              "headers": ["Classe", "Description", "Exemple"],
              "rows": [
                ["`LocalDate`", "Date sans heure ni fuseau horaire", "`LocalDate.now()`"],
                ["`LocalTime`", "Heure sans date ni fuseau horaire", "`LocalTime.of(13, 30)`"],
                ["`LocalDateTime`", "Date et heure sans fuseau horaire", "`LocalDateTime.now()`"],
                ["`ZonedDateTime`", "Date et heure avec fuseau horaire", "`ZonedDateTime.now(ZoneId.of(\"Europe/Paris\"))`"],
                ["`Instant`", "Point dans le temps (basé sur epoch)", "`Instant.now()`"],
                ["`Duration`", "Quantité basée sur le temps", "`Duration.between(start, end)`"],
                ["`Period`", "Quantité basée sur la date", "`Period.between(startDate, endDate)`"]
              ]
            }
          ]
        },
        {
          "title": "Opérations Courantes",
          "code": [
            {
              "language": "java",
              "snippet": "// Création d'instances\nLocalDate date = LocalDate.of(2023, Month.JANUARY, 15);\nLocalTime time = LocalTime.of(13, 30, 15);\nLocalDateTime dateTime = LocalDateTime.of(date, time);\n\n// Date/heure actuelle\nLocalDate today = LocalDate.now();\nLocalDateTime now = LocalDateTime.now();\n\n// Manipulation de date (immuable, renvoie une nouvelle instance)\nLocalDate tomorrow = today.plusDays(1);\nLocalDate lastMonth = today.minusMonths(1);\nLocalDate withYear = today.withYear(2022);\n\n// Analyse et formatage\nDateTimeFormatter formatter = DateTimeFormatter.ofPattern(\"yyyy-MM-dd\");\nLocalDate parsed = LocalDate.parse(\"2023-01-15\", formatter);\nString formatted = today.format(formatter);\n\n// Calculs\nPeriod period = Period.between(date1, date2);\nlong days = ChronoUnit.DAYS.between(date1, date2);\n\n// Avec fuseaux horaires\nZonedDateTime tokyo = ZonedDateTime.now(ZoneId.of(\"Asia/Tokyo\"));\nZonedDateTime converted = tokyo.withZoneSameInstant(ZoneId.of(\"America/New_York\"));"
            }
          ]
        },
        {
          "title": "Ajusteurs Temporels",
          "code": [
            {
              "language": "java",
              "snippet": "// Trouver le prochain lundi\nLocalDate nextMonday = today.with(TemporalAdjusters.next(DayOfWeek.MONDAY));\n\n// Trouver le dernier jour du mois\nLocalDate lastDay = today.with(TemporalAdjusters.lastDayOfMonth());"
            }
          ]
        }
      ]
    },
    {
      "id": "base64",
      "title": "Encodage/Décodage Base64",
      "description": "Fournit un support intégré pour l'encodage de données binaires en chaînes Base64 et le décodage de chaînes Base64 en données binaires, simplifiant les conversions de données.",
      "methods": [
        {
          "name": "getEncoder()",
          "description": "Renvoie un encodeur Base64 qui convertit des données binaires en chaîne encodée Base64.",
          "example": "Base64.getEncoder().encodeToString(bytes)"
        },
        {
          "name": "getDecoder()",
          "description": "Renvoie un décodeur Base64 qui convertit une chaîne encodée Base64 en données binaires.",
          "example": "Base64.getDecoder().decode(string)"
        }
      ],
      "code": [
        {
          "language": "java",
          "snippet": "// Encodage simple\nString encoded = Base64.getEncoder().encodeToString(\"Hello, World!\".getBytes());\n\n// Décodage\nbyte[] decoded = Base64.getDecoder().decode(encoded);\n\n// Encodage URL-safe\nString urlEncoded = Base64.getUrlEncoder().encodeToString(\"Hello?World&Special=Chars\".getBytes());"
        }
      ]
    },
    {
      "id": "modulesystem",
      "title": "Système de Modules Java 9",
      "content": "Le système de modules de la plateforme Java (JPMS) introduit dans Java 9 fournit un moyen de grouper des packages connexes et de déclarer explicitement des dépendances.",
      "subsections": [
        {
          "title": "Déclaration de Module",
          "code": [
            {
              "language": "java",
              "snippet": "// Dans module-info.java\nmodule com.example.myapp {\n    // Modules dont ce module dépend\n    requires java.sql;\n    requires com.example.utils;\n    \n    // Packages que ce module rend disponibles pour d'autres modules\n    exports com.example.myapp.api;\n    \n    // Restreindre les exports à des modules spécifiques\n    exports com.example.myapp.model to com.example.client;\n    \n    // Service fourni par ce module\n    provides com.example.spi.MyService with com.example.myapp.MyServiceImpl;\n    \n    // Services que ce module consomme\n    uses com.example.spi.ExternalService;\n}"
            }
          ]
        },
        {
          "title": "Concepts Clés des Modules",
          "list": [
            "**Encapsulation Forte**: Seuls les packages exportés sont accessibles",
            "**Configuration Fiable**: Les dépendances sont explicitement déclarées",
            "**Performance Améliorée**: Meilleur temps de démarrage et empreinte mémoire",
            "**Évolutivité**: Supporte mieux les grandes applications"
          ]
        }
      ]
    },
    {
      "id": "nashorn",
      "title": "Moteur JavaScript Nashorn",
      "description": "Nashorn est un moteur JavaScript léger intégré à Java, permettant le scripting dynamique en autorisant l'intégration et l'exécution de code JavaScript au sein d'applications Java.",
      "features": [
        {
          "aspect": "Intégration",
          "description": "Permet au code JavaScript d'être directement intégré dans les applications Java, facilitant le scripting dynamique et l'intégration transparente avec les bibliothèques Java.",
          "example": "ScriptEngine engine = new ScriptEngineManager().getEngineByName(\"nashorn\");"
        },
        {
          "aspect": "Performance",
          "description": "Offre des performances améliorées par rapport aux moteurs JavaScript précédents, le rendant plus efficace pour l'exécution de code JavaScript."
        }
      ],
      "code": [
        {
          "language": "java",
          "snippet": "// Obtenir le moteur Nashorn\nScriptEngine engine = new ScriptEngineManager().getEngineByName(\"nashorn\");\n\n// Évaluer JavaScript\nObject result = engine.eval(\"var x = 10; x * 2;\");\nSystem.out.println(result);  // 20\n\n// Accéder aux objets Java depuis JavaScript\nengine.put(\"javaList\", new ArrayList<String>());\nengine.eval(\"javaList.add('Hello from JavaScript');\");\n\n// Utiliser des fonctions JavaScript depuis Java\nengine.eval(\"function greet(name) { return 'Hello, ' + name; }\");\nInvocable invocable = (Invocable) engine;\nString greeting = (String) invocable.invokeFunction(\"greet\", \"World\");\nSystem.out.println(greeting);  // Hello, World"
        }
      ]
    },
    {
      "id": "annotations",
      "title": "Améliorations des Annotations",
      "description": "Les améliorations récentes des annotations permettent des métadonnées plus expressives. Ces améliorations incluent les annotations de type et les annotations répétables, qui aident à réduire le code redondant et à améliorer la clarté.",
      "features": [
        {
          "name": "Annotations de Type",
          "description": "Annotations qui peuvent être appliquées partout où un type est utilisé, fournissant des métadonnées supplémentaires.",
          "example": "@Nonnull String text"
        },
        {
          "name": "Annotations Répétables",
          "description": "Permet d'appliquer la même annotation plusieurs fois à une seule déclaration.",
          "example": "@Schedule(dayOfMonth=\"last\") @Schedule(dayOfWeek=\"Fri\") void doPeriodic() {}"
        }
      ],
      "code": [
        {
          "language": "java",
          "snippet": "// Annotations de type\npublic void processString(@NotNull String text) {\n    List<@NotNull String> strings = new ArrayList<>();\n    strings.add(text);\n}\n\n// Annotations répétables\n@Retention(RetentionPolicy.RUNTIME)\n@Repeatable(Schedules.class)\n@interface Schedule {\n    String dayOfMonth() default \"first\";\n    String dayOfWeek() default \"Mon\";\n}\n\n@Retention(RetentionPolicy.RUNTIME)\n@interface Schedules {\n    Schedule[] value();\n}\n\n@Schedule(dayOfMonth = \"last\")\n@Schedule(dayOfWeek = \"Fri\")\nvoid performMonthlyTask() {\n    // Implémentation de la tâche\n}"
        }
      ]
    },
    {
      "id": "concurrency",
      "title": "Utilitaires de Concurrence",
      "description": "Les nouvelles API de concurrence et les améliorations dans Java fournissent un support robuste pour la programmation multi-thread, rendant le code concurrent plus sûr et plus efficace.",
      "classes": [
        {
          "name": "StampedLock",
          "description": "Un verrou avec un mécanisme d'estampillage qui prend en charge à la fois les modes de verrouillage optimiste et pessimiste, permettant un contrôle fin sur l'accès en lecture/écriture.",
          "example": "StampedLock lock = new StampedLock();"
        },
        {
          "name": "LongAdder",
          "description": "Une alternative haute performance à AtomicLong, conçue pour les scénarios de forte contention afin de réduire les frais de contention.",
          "example": "LongAdder adder = new LongAdder();"
        },
        {
          "name": "Améliorations ConcurrentHashMap",
          "description": "Méthodes améliorées pour effectuer des opérations en masse et des fonctions de mapping de manière concurrente, améliorant les performances dans les environnements multi-threads.",
          "example": "map.forEach((key, value) -> { /* process */ });"
        }
      ],
      "code": [
        {
          "language": "java",
          "snippet": "// Exemple StampedLock\nStampedLock lock = new StampedLock();\n\n// Lecture optimiste\nlong stamp = lock.tryOptimisticRead();\nDouble currentX = this.x;\nDouble currentY = this.y;\nif (!lock.validate(stamp)) {\n    // Les données ont été modifiées, obtenir un verrou de lecture\n    stamp = lock.readLock();\n    try {\n        currentX = this.x;\n        currentY = this.y;\n    } finally {\n        lock.unlockRead(stamp);\n    }\n}\n\n// Exemple LongAdder\nLongAdder counter = new LongAdder();\n// Plusieurs threads incrémentent\ncounter.increment();\n// Obtenir le total\nlong sum = counter.sum();\n\n// Opérations en masse de ConcurrentHashMap\nConcurrentHashMap<String, Integer> map = new ConcurrentHashMap<>();\nmap.put(\"one\", 1);\nmap.put(\"two\", 2);\n\n// forEach parallèle\nmap.forEach(1, (key, value) -> {\n    System.out.println(key + \" = \" + value);\n});\n\n// Compute if absent\nInteger value = map.computeIfAbsent(\"three\", k -> 3);\n\n// Opérations de réduction et de recherche\nInteger maxValue = map.reduceValues(1, Integer::max);"
        }
      ]
    },
    {
      "id": "additionalFeatures",
      "title": "Fonctionnalités Java 8+ Additionnelles",
      "subsections": [
        {
          "title": "Améliorations String (Java 11+)",
          "code": [
            {
              "language": "java",
              "snippet": "// isBlank() vérifie si la chaîne est vide ou ne contient que des espaces\nboolean emptyCheck = \"   \".isBlank(); // true\n\n// lines() divise une chaîne en stream de lignes\nStream<String> lines = \"Line 1\\nLine 2\\nLine 3\".lines();\n\n// strip() supprime les espaces aux deux extrémités (compatible Unicode)\nString stripped = \" Hello \".strip(); // \"Hello\"\n\n// repeat() répète une chaîne n fois\nString repeated = \"abc\".repeat(3); // \"abcabcabc\""
            }
          ]
        },
        {
          "title": "Méthodes Factory de Collection (Java 9+)",
          "code": [
            {
              "language": "java",
              "snippet": "// List immuable\nList<String> list = List.of(\"a\", \"b\", \"c\");\n\n// Set immuable\nSet<String> set = Set.of(\"a\", \"b\", \"c\");\n\n// Map immuable\nMap<String, Integer> map = Map.of(\n    \"a\", 1,\n    \"b\", 2,\n    \"c\", 3\n);"
            }
          ]
        },
        {
          "title": "Inférence de Type var (Java 10+)",
          "code": [
            {
              "language": "java",
              "snippet": "// Type inféré à partir de l'initialiseur\nvar list = new ArrayList<String>();\nvar map = new HashMap<String, Integer>();\nvar text = \"Hello\"; // inféré comme String"
            }
          ]
        }
      ]
    },
    {
      "id": "practicalExample",
      "title": "Exemple Pratique Combiné",
      "code": [
        {
          "language": "java",
          "snippet": "// Un exemple du monde réel combinant plusieurs fonctionnalités Java 8+\npublic class OrderProcessor {\n    // Traitement d'une liste de commandes avec Java moderne\n    public Map<String, Double> summarizeOrdersByCustomer(List<Order> orders) {\n        return orders.stream()                                 // API Stream\n            .filter(order -> order.getStatus().isComplete())   // Lambda\n            .collect(Collectors.groupingBy(                    // Collectors\n                Order::getCustomerName,                        // Référence de méthode\n                Collectors.summingDouble(Order::getTotal)      // Chaînage de fonctions\n            ));\n    }\n    \n    // Traitement asynchrone avec gestion d'erreurs\n    public CompletableFuture<List<OrderResult>> processOrdersAsync(List<Order> orders) {\n        List<CompletableFuture<OrderResult>> futures = orders.stream()\n            .map(order -> CompletableFuture\n                .supplyAsync(() -> processOrder(order))        // Traitement asynchrone\n                .exceptionally(ex -> {                         // Gestion d'erreurs\n                    log(ex);\n                    return OrderResult.failed(order.getId());\n                }))\n            .collect(Collectors.toList());\n            \n        return CompletableFuture.allOf(futures.toArray(new CompletableFuture[0]))\n            .thenApply(v -> futures.stream()\n                .map(CompletableFuture::join)\n                .collect(Collectors.toList()));\n    }\n    \n    private OrderResult processOrder(Order order) {\n        // Logique de traitement ici\n        return Optional.ofNullable(order)                      // Optional\n            .map(this::calculateDiscount)\n            .map(this::applyTaxes)\n            .map(this::generateInvoice)\n            .orElseThrow(() -> new OrderProcessingException());\n    }\n}"
        }
      ]
    },
    {
      "id": "interviewFAQs",
      "title": "FAQs d'Entretien",
      "subsections": [
        {
          "title": "1. Quelles sont les principales fonctionnalités introduites dans Java 8?",
          "content": "Java 8 a introduit plusieurs fonctionnalités majeures:\n\n- Expressions lambda pour la programmation fonctionnelle\n- API Stream pour le traitement des collections\n- Interfaces fonctionnelles (marquées avec @FunctionalInterface)\n- Méthodes par défaut dans les interfaces\n- Références de méthodes\n- Optional pour une meilleure gestion des null\n- Nouvelle API Date/Time (package java.time)\n- CompletableFuture pour une programmation asynchrone améliorée"
        },
        {
          "title": "2. Qu'est-ce qu'une expression lambda et comment est-elle utilisée?",
          "content": "Une expression lambda est une fonction anonyme qui implémente une interface fonctionnelle de manière concise. Syntaxe: `(paramètres) -> expression` ou `(paramètres) -> { instructions }`. Elle permet de traiter la fonctionnalité comme un argument de méthode, permettant la programmation fonctionnelle en Java."
        },
        {
          "title": "3. Quelle est la différence entre une interface normale et une interface fonctionnelle?",
          "content": "Une interface fonctionnelle a exactement une méthode abstraite, tandis qu'une interface normale peut avoir plusieurs méthodes abstraites. Les interfaces fonctionnelles peuvent être implémentées à l'aide d'expressions lambda et sont souvent annotées avec @FunctionalInterface. À partir de Java 8, les deux types d'interfaces peuvent contenir des méthodes par défaut et statiques."
        },
        {
          "title": "4. En quoi l'API Stream diffère-t-elle des collections?",
          "list": [
            "Les streams fournissent une vue des données, pas une structure de données",
            "Les streams ne modifient pas les données source",
            "Les streams utilisent l'évaluation paresseuse (les opérations ne s'exécutent que lors de l'opération terminale)",
            "Les streams peuvent traiter les données en séquence ou en parallèle",
            "Les streams ne peuvent pas être réutilisés après une opération terminale",
            "Les streams se concentrent sur les opérations, tandis que les collections se concentrent sur le stockage des données"
          ]
        },
        {
          "title": "5. Quelle est la différence entre map() et flatMap() dans l'API Stream?",
          "list": [
            "`map()` transforme chaque élément en exactement un élément de sortie",
            "`flatMap()` transforme chaque élément en zéro ou plusieurs éléments, aplatissant le résultat",
            "`map()` est utilisé pour les transformations simples, tandis que `flatMap()` est utilisé pour traiter des collections ou des streams imbriqués"
          ]
        },
        {
          "title": "6. Comment exécuter des opérations en parallèle à l'aide de l'API Stream?",
          "content": "Vous pouvez créer un stream parallèle en utilisant:\n\n- `collection.parallelStream()` sur une collection\n- `stream.parallel()` sur un stream existant\n\nLes opérations s'exécuteront alors en parallèle, exploitant plusieurs cœurs de processeur. Cependant, vous devriez considérer la sécurité des threads, la non-interférence et l'absence d'état pour éviter les problèmes."
        },
        {
          "title": "7. Quel est l'objectif de la classe Optional?",
          "content": "Optional est un objet conteneur qui peut ou non contenir une valeur non-null. Son objectif principal est de:\n\n- Éviter les NullPointerExceptions\n- Rendre le code plus expressif quant à la possibilité de valeurs manquantes\n- Imposer une gestion explicite des cas null\n- Fournir des opérations de style fonctionnel sur les valeurs optionnelles"
        },
        {
          "title": "8. Que se passe-t-il lorsque plusieurs interfaces avec des méthodes par défaut sont implémentées par une classe?",
          "content": "Lorsqu'une classe implémente plusieurs interfaces avec des méthodes par défaut conflictuelles, Java suit des règles de résolution:\n\n1. Les méthodes de classe ont priorité sur les méthodes par défaut d'interface\n2. Les méthodes d'interface plus spécifiques ont priorité sur les moins spécifiques\n3. Si ambigu, la classe doit explicitement redéfinir la méthode et choisir quelle implémentation utiliser"
        },
        {
          "title": "9. En quoi les références de méthodes diffèrent-elles des expressions lambda?",
          "content": "Les références de méthodes sont des notations abrégées pour les expressions lambda qui appellent une méthode existante. Principales différences:\n\n- Les références de méthodes sont plus concises pour les appels de méthode simples\n- Les expressions lambda permettent des opérations et transformations plus complexes\n- Les références de méthodes nomment explicitement la méthode appelée\n- Les lambdas peuvent créer une nouvelle logique non liée aux méthodes existantes"
        },
        {
          "title": "10. Quelle est la différence entre les interfaces fonctionnelles Predicate, Function et Consumer?",
          "list": [
            "`Predicate<T>`: Prend un objet de type T et renvoie un booléen (utilisé pour le filtrage)",
            "`Function<T,R>`: Prend un objet de type T et renvoie un objet de type R (utilisé pour la transformation)",
            "`Consumer<T>`: Prend un objet de type T et ne renvoie rien (void) (utilisé pour les opérations avec effets secondaires)"
          ]
        },
        {
          "title": "11. Quelles sont les limitations des streams parallèles?",
          "content": "Les streams parallèles peuvent parfois être plus lents en raison des frais généraux de coordination des threads. Ils devraient être utilisés pour des tâches intensives en calcul sur de grands ensembles de données. Évitez-les avec des opérations qui nécessitent un ordre spécifique ou lors de l'utilisation d'état mutable partagé."
        },
        {
          "title": "12. Comment fonctionnent les interfaces fonctionnelles avec l'héritage?",
          "content": "Si une interface étend une interface fonctionnelle et ne déclare pas de méthodes abstraites supplémentaires, elle reste une interface fonctionnelle. Plusieurs méthodes abstraites en font une interface non fonctionnelle."
        },
        {
          "title": "13. Peut-on utiliser à la fois des méthodes par défaut et des méthodes statiques dans les interfaces fonctionnelles?",
          "content": "Oui, les interfaces fonctionnelles peuvent avoir plusieurs méthodes par défaut et statiques tant qu'elles ont exactement une méthode abstraite."
        }
      ]
    },
    {
      "id": "advancedTopics",
      "title": "Sujets Avancés",
      "subsections": [
        {
          "title": "Techniques de Collectors",
          "code": [
            {
              "language": "java",
              "snippet": "// Groupement avec collectors en aval\nMap<Department, Double> avgSalaryByDept = employees.stream()\n    .collect(Collectors.groupingBy(\n        Employee::getDepartment,\n        Collectors.averagingDouble(Employee::getSalary)\n    ));\n\n// Groupement multi-niveaux\nMap<String, Map<String, List<Employee>>> byLocationAndDepartment = employees.stream()\n    .collect(Collectors.groupingBy(\n        Employee::getLocation,\n        Collectors.groupingBy(Employee::getDepartment)\n    ));\n\n// Collector personnalisé\nCollector<Employee, ?, DoubleSummaryStatistics> salaryStats =\n    Collectors.summarizingDouble(Employee::getSalary);"
            }
          ]
        },
        {
          "title": "Streams Réactifs (Java 9+)",
          "code": [
            {
              "language": "java",
              "snippet": "// Modèle Publisher-Subscriber\nFlow.Publisher<String> publisher = subscriber -> {\n    // Logique de publication\n};\n\nFlow.Subscriber<String> subscriber = new Flow.Subscriber<>() {\n    // Gestion de l'abonnement\n};"
            }
          ]
        },
        {
          "title": "Try-With-Resources Amélioré (Java 9+)",
          "code": [
            {
              "language": "java",
              "snippet": "// Java 8\ntry (BufferedReader br = new BufferedReader(new FileReader(path))) {\n    // Utilisation de br\n}\n\n// Java 9+ (peut utiliser des variables effectivement finales)\nBufferedReader br = new BufferedReader(new FileReader(path));\ntry (br) {\n    // Utilisation de br\n}"
            }
          ]
        }
      ]
    },
    {
      "id": "relatedTopics",
      "title": "Sujets Connexes",
      "list": [
        "[[Programmation Fonctionnelle]]",
        "[[Fondamentaux Java]]",
        "[[Collections]]",
        "[[Concurrence]]",
        "[[Pratiques Java Efficaces]]"
      ],
      "tags": ["lambda", "streams", "optional", "completablefuture", "functional-interfaces"]
    }
  ]
}
